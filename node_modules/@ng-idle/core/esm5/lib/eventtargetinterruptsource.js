/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Subscription, fromEvent, merge } from 'rxjs';
import { filter, throttleTime } from 'rxjs/operators';
import { InterruptArgs } from './interruptargs';
import { InterruptSource } from './interruptsource';
/**
 * Options for EventTargetInterruptSource
 * @record
 */
export function EventTargetInterruptOptions() { }
if (false) {
    /**
     * The number of milliseconds to throttle the events coming from the target.
     * @type {?|undefined}
     */
    EventTargetInterruptOptions.prototype.throttleDelay;
    /**
     * Whether or not to use passive event listeners.
     * Note: you need to detect if the browser supports passive listeners, and only set this to true if it does.
     * @type {?|undefined}
     */
    EventTargetInterruptOptions.prototype.passive;
}
/** @type {?} */
var defaultThrottleDelay = 500;
/*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
var /*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
EventTargetInterruptSource = /** @class */ (function (_super) {
    tslib_1.__extends(EventTargetInterruptSource, _super);
    function EventTargetInterruptSource(target, events, options) {
        var _this = _super.call(this, null, null) || this;
        _this.target = target;
        _this.events = events;
        _this.eventSubscription = new Subscription();
        if (typeof options === 'number') {
            options = { throttleDelay: options, passive: false };
        }
        options = options || {
            throttleDelay: defaultThrottleDelay,
            passive: false
        };
        if (options.throttleDelay === undefined || options.throttleDelay === null) {
            options.throttleDelay = defaultThrottleDelay;
        }
        _this.throttleDelay = options.throttleDelay;
        _this.passive = !!options.passive;
        /** @type {?} */
        var opts = _this.passive ? { passive: true } : null;
        /** @type {?} */
        var fromEvents = events
            .split(' ')
            .map((/**
         * @param {?} eventName
         * @return {?}
         */
        function (eventName) { return fromEvent(target, eventName, opts); }));
        _this.eventSrc = merge.apply(void 0, tslib_1.__spread(fromEvents));
        _this.eventSrc = _this.eventSrc.pipe(filter((/**
         * @param {?} innerArgs
         * @return {?}
         */
        function (innerArgs) { return !_this.filterEvent(innerArgs); })));
        if (_this.throttleDelay > 0) {
            _this.eventSrc = _this.eventSrc.pipe(throttleTime(_this.throttleDelay));
        }
        /** @type {?} */
        var handler = (/**
         * @param {?} innerArgs
         * @return {?}
         */
        function (innerArgs) {
            return _this.onInterrupt.emit(new InterruptArgs(_this, innerArgs));
        });
        _this.attachFn = (/**
         * @return {?}
         */
        function () {
            return (_this.eventSubscription = _this.eventSrc.subscribe(handler));
        });
        _this.detachFn = (/**
         * @return {?}
         */
        function () { return _this.eventSubscription.unsubscribe(); });
        return _this;
    }
    /*
     * Checks to see if the event should be filtered. Always returns false unless overriden.
     * @param event - The original event object.
     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
     */
    /*
       * Checks to see if the event should be filtered. Always returns false unless overriden.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    EventTargetInterruptSource.prototype.filterEvent = /*
       * Checks to see if the event should be filtered. Always returns false unless overriden.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return false;
    };
    Object.defineProperty(EventTargetInterruptSource.prototype, "options", {
        /**
         * Returns the current options being used.
         * @return The current option values.
         */
        get: /**
         * Returns the current options being used.
         * @return {?} The current option values.
         */
        function () {
            return { throttleDelay: this.throttleDelay, passive: this.passive };
        },
        enumerable: true,
        configurable: true
    });
    return EventTargetInterruptSource;
}(InterruptSource));
/*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
export { EventTargetInterruptSource };
if (false) {
    /**
     * @type {?}
     * @private
     */
    EventTargetInterruptSource.prototype.eventSrc;
    /**
     * @type {?}
     * @private
     */
    EventTargetInterruptSource.prototype.eventSubscription;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.throttleDelay;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.passive;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.target;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.events;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnR0YXJnZXRpbnRlcnJ1cHRzb3VyY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmctaWRsZS9jb3JlLyIsInNvdXJjZXMiOlsibGliL2V2ZW50dGFyZ2V0aW50ZXJydXB0c291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFjLFlBQVksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7Ozs7QUFLcEQsaURBV0M7Ozs7OztJQVBDLG9EQUF1Qjs7Ozs7O0lBTXZCLDhDQUFrQjs7O0lBR2Qsb0JBQW9CLEdBQUcsR0FBRzs7OztBQUtoQzs7OztJQUFnRCxzREFBZTtJQU03RCxvQ0FDWSxNQUFXLEVBQ1gsTUFBYyxFQUN4QixPQUE4QztRQUhoRCxZQUtFLGtCQUFNLElBQUksRUFBRSxJQUFJLENBQUMsU0FxQ2xCO1FBekNXLFlBQU0sR0FBTixNQUFNLENBQUs7UUFDWCxZQUFNLEdBQU4sTUFBTSxDQUFRO1FBTmxCLHVCQUFpQixHQUFpQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBVzNELElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1lBQy9CLE9BQU8sR0FBRyxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDO1NBQ3REO1FBRUQsT0FBTyxHQUFHLE9BQU8sSUFBSTtZQUNuQixhQUFhLEVBQUUsb0JBQW9CO1lBQ25DLE9BQU8sRUFBRSxLQUFLO1NBQ2YsQ0FBQztRQUVGLElBQUksT0FBTyxDQUFDLGFBQWEsS0FBSyxTQUFTLElBQUksT0FBTyxDQUFDLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDekUsT0FBTyxDQUFDLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQztTQUM5QztRQUVELEtBQUksQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQztRQUMzQyxLQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDOztZQUUzQixJQUFJLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUk7O1lBQzlDLFVBQVUsR0FBRyxNQUFNO2FBQ3RCLEtBQUssQ0FBQyxHQUFHLENBQUM7YUFDVixHQUFHOzs7O1FBQUMsVUFBQSxTQUFTLElBQUksT0FBQSxTQUFTLENBQU0sTUFBTSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBdkMsQ0FBdUMsRUFBQztRQUM1RCxLQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssZ0NBQUksVUFBVSxFQUFDLENBQUM7UUFDckMsS0FBSSxDQUFDLFFBQVEsR0FBRyxLQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FDaEMsTUFBTTs7OztRQUFDLFVBQUEsU0FBUyxJQUFJLE9BQUEsQ0FBQyxLQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUE1QixDQUE0QixFQUFDLENBQ2xELENBQUM7UUFDRixJQUFJLEtBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLEtBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1NBQ3RFOztZQUVLLE9BQU87Ozs7UUFBRyxVQUFDLFNBQWM7WUFDN0IsT0FBQSxLQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLGFBQWEsQ0FBQyxLQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFBekQsQ0FBeUQsQ0FBQTtRQUUzRCxLQUFJLENBQUMsUUFBUTs7O1FBQUc7WUFDZCxPQUFBLENBQUMsS0FBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQTNELENBQTJELENBQUEsQ0FBQztRQUU5RCxLQUFJLENBQUMsUUFBUTs7O1FBQUcsY0FBTSxPQUFBLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsRUFBcEMsQ0FBb0MsQ0FBQSxDQUFDOztJQUM3RCxDQUFDO0lBRUQ7Ozs7T0FJRzs7Ozs7Ozs7Ozs7SUFDTyxnREFBVzs7Ozs7Ozs7OztJQUFyQixVQUFzQixLQUFVO1FBQzlCLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQU1ELHNCQUFJLCtDQUFPO1FBSlg7OztXQUdHOzs7OztRQUNIO1lBQ0UsT0FBTyxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEUsQ0FBQzs7O09BQUE7SUFDSCxpQ0FBQztBQUFELENBQUMsQUFsRUQsQ0FBZ0QsZUFBZSxHQWtFOUQ7Ozs7Ozs7Ozs7SUFqRUMsOENBQWtDOzs7OztJQUNsQyx1REFBNkQ7Ozs7O0lBQzdELG1EQUFnQzs7Ozs7SUFDaEMsNkNBQTJCOzs7OztJQUd6Qiw0Q0FBcUI7Ozs7O0lBQ3JCLDRDQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiwgZnJvbUV2ZW50LCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0aHJvdHRsZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEludGVycnVwdEFyZ3MgfSBmcm9tICcuL2ludGVycnVwdGFyZ3MnO1xuaW1wb3J0IHsgSW50ZXJydXB0U291cmNlIH0gZnJvbSAnLi9pbnRlcnJ1cHRzb3VyY2UnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEV2ZW50VGFyZ2V0SW50ZXJydXB0U291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRUYXJnZXRJbnRlcnJ1cHRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIHRoZSBldmVudHMgY29taW5nIGZyb20gdGhlIHRhcmdldC5cbiAgICovXG4gIHRocm90dGxlRGVsYXk/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycy5cbiAgICogTm90ZTogeW91IG5lZWQgdG8gZGV0ZWN0IGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgbGlzdGVuZXJzLCBhbmQgb25seSBzZXQgdGhpcyB0byB0cnVlIGlmIGl0IGRvZXMuXG4gICAqL1xuICBwYXNzaXZlPzogYm9vbGVhbjtcbn1cblxuY29uc3QgZGVmYXVsdFRocm90dGxlRGVsYXkgPSA1MDA7XG5cbi8qXG4gKiBBbiBpbnRlcnJ1cHQgc291cmNlIG9uIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgc3VjaCBhcyBhIFdpbmRvdyBvciBIVE1MRWxlbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50VGFyZ2V0SW50ZXJydXB0U291cmNlIGV4dGVuZHMgSW50ZXJydXB0U291cmNlIHtcbiAgcHJpdmF0ZSBldmVudFNyYzogT2JzZXJ2YWJsZTxhbnk+O1xuICBwcml2YXRlIGV2ZW50U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gIHByb3RlY3RlZCB0aHJvdHRsZURlbGF5OiBudW1iZXI7XG4gIHByb3RlY3RlZCBwYXNzaXZlOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCB0YXJnZXQ6IGFueSxcbiAgICBwcm90ZWN0ZWQgZXZlbnRzOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IG51bWJlciB8IEV2ZW50VGFyZ2V0SW50ZXJydXB0T3B0aW9uc1xuICApIHtcbiAgICBzdXBlcihudWxsLCBudWxsKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMgPSB7IHRocm90dGxlRGVsYXk6IG9wdGlvbnMsIHBhc3NpdmU6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgdGhyb3R0bGVEZWxheTogZGVmYXVsdFRocm90dGxlRGVsYXksXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy50aHJvdHRsZURlbGF5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50aHJvdHRsZURlbGF5ID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zLnRocm90dGxlRGVsYXkgPSBkZWZhdWx0VGhyb3R0bGVEZWxheTtcbiAgICB9XG5cbiAgICB0aGlzLnRocm90dGxlRGVsYXkgPSBvcHRpb25zLnRocm90dGxlRGVsYXk7XG4gICAgdGhpcy5wYXNzaXZlID0gISFvcHRpb25zLnBhc3NpdmU7XG5cbiAgICBjb25zdCBvcHRzID0gdGhpcy5wYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBudWxsO1xuICAgIGNvbnN0IGZyb21FdmVudHMgPSBldmVudHNcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGV2ZW50TmFtZSA9PiBmcm9tRXZlbnQ8YW55Pih0YXJnZXQsIGV2ZW50TmFtZSwgb3B0cykpO1xuICAgIHRoaXMuZXZlbnRTcmMgPSBtZXJnZSguLi5mcm9tRXZlbnRzKTtcbiAgICB0aGlzLmV2ZW50U3JjID0gdGhpcy5ldmVudFNyYy5waXBlKFxuICAgICAgZmlsdGVyKGlubmVyQXJncyA9PiAhdGhpcy5maWx0ZXJFdmVudChpbm5lckFyZ3MpKVxuICAgICk7XG4gICAgaWYgKHRoaXMudGhyb3R0bGVEZWxheSA+IDApIHtcbiAgICAgIHRoaXMuZXZlbnRTcmMgPSB0aGlzLmV2ZW50U3JjLnBpcGUodGhyb3R0bGVUaW1lKHRoaXMudGhyb3R0bGVEZWxheSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSAoaW5uZXJBcmdzOiBhbnkpID0+XG4gICAgICB0aGlzLm9uSW50ZXJydXB0LmVtaXQobmV3IEludGVycnVwdEFyZ3ModGhpcywgaW5uZXJBcmdzKSk7XG5cbiAgICB0aGlzLmF0dGFjaEZuID0gKCkgPT5cbiAgICAgICh0aGlzLmV2ZW50U3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudFNyYy5zdWJzY3JpYmUoaGFuZGxlcikpO1xuXG4gICAgdGhpcy5kZXRhY2hGbiA9ICgpID0+IHRoaXMuZXZlbnRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGV2ZW50IHNob3VsZCBiZSBmaWx0ZXJlZC4gQWx3YXlzIHJldHVybnMgZmFsc2UgdW5sZXNzIG92ZXJyaWRlbi5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiBUcnVlIGlmIHRoZSBldmVudCBzaG91bGQgYmUgZmlsdGVyZWQgKGRvbid0IGNhdXNlIGFuIGludGVycnVwdCk7IG90aGVyd2lzZSwgZmFsc2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgZmlsdGVyRXZlbnQoZXZlbnQ6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9wdGlvbnMgYmVpbmcgdXNlZC5cbiAgICogQHJldHVybiBUaGUgY3VycmVudCBvcHRpb24gdmFsdWVzLlxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKTogRXZlbnRUYXJnZXRJbnRlcnJ1cHRPcHRpb25zIHtcbiAgICByZXR1cm4geyB0aHJvdHRsZURlbGF5OiB0aGlzLnRocm90dGxlRGVsYXksIHBhc3NpdmU6IHRoaXMucGFzc2l2ZSB9O1xuICB9XG59XG4iXX0=
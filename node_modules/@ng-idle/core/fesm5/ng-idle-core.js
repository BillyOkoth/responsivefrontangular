import { __extends, __values, __spread } from 'tslib';
import { Injectable, NgZone, Optional, EventEmitter, NgModule } from '@angular/core';
import { Subscription, fromEvent, merge } from 'rxjs';
import { filter, throttleTime } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Represents a base class for types that provide expiry detection for the Idle service.
 */
/**
 * @abstract
 */
var  /*
 * Represents a base class for types that provide expiry detection for the Idle service.
 */
/**
 * @abstract
 */
IdleExpiry = /** @class */ (function () {
    function IdleExpiry() {
        this.idValue = new Date();
        this.idlingValue = false;
    }
    /*
     * Gets or sets a unique ID for the window
     * @param id - The id.
     * @return The current id.
     */
    /*
       * Gets or sets a unique ID for the window
       * @param id - The id.
       * @return The current id.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    IdleExpiry.prototype.id = /*
       * Gets or sets a unique ID for the window
       * @param id - The id.
       * @return The current id.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value !== void 0) {
            if (!value) {
                throw new Error('A value must be specified for the ID.');
            }
            this.idValue = value;
        }
        return this.idValue;
    };
    /*
     * Gets or sets the idling value.
     * @param value - The value to set.
     * @return The idling value.
     */
    /*
       * Gets or sets the idling value.
       * @param value - The value to set.
       * @return The idling value.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    IdleExpiry.prototype.idling = /*
       * Gets or sets the idling value.
       * @param value - The value to set.
       * @return The idling value.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value !== void 0) {
            this.idlingValue = value;
        }
        return this.idlingValue;
    };
    /*
     * Returns the current Date.
     * @return The current Date.
     */
    /*
       * Returns the current Date.
       * @return The current Date.
       */
    /**
     * @return {?}
     */
    IdleExpiry.prototype.now = /*
       * Returns the current Date.
       * @return The current Date.
       */
    /**
     * @return {?}
     */
    function () {
        /* istanbul ignore next */
        return new Date();
    };
    /*
     * Returns whether or not it is expired.
     * @return True if expired; otherwise, false.
     */
    /*
       * Returns whether or not it is expired.
       * @return True if expired; otherwise, false.
       */
    /**
     * @return {?}
     */
    IdleExpiry.prototype.isExpired = /*
       * Returns whether or not it is expired.
       * @return True if expired; otherwise, false.
       */
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var expiry = this.last();
        return expiry != null && expiry <= this.now();
    };
    return IdleExpiry;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * A class for managing an interrupt from an interrupt source.
 */
var /*
 * A class for managing an interrupt from an interrupt source.
 */
Interrupt = /** @class */ (function () {
    function Interrupt(source) {
        this.source = source;
    }
    /*
     * Subscribes to the interrupt using the specified function.
     * @param fn - The subscription function.
     */
    /*
       * Subscribes to the interrupt using the specified function.
       * @param fn - The subscription function.
       */
    /**
     * @param {?} fn
     * @return {?}
     */
    Interrupt.prototype.subscribe = /*
       * Subscribes to the interrupt using the specified function.
       * @param fn - The subscription function.
       */
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.sub = this.source.onInterrupt.subscribe(fn);
    };
    /*
     * Unsubscribes the interrupt.
     */
    /*
       * Unsubscribes the interrupt.
       */
    /**
     * @return {?}
     */
    Interrupt.prototype.unsubscribe = /*
       * Unsubscribes the interrupt.
       */
    /**
     * @return {?}
     */
    function () {
        this.sub.unsubscribe();
        this.sub = null;
    };
    /*
     * Keeps the subscription but resumes interrupt events.
     */
    /*
       * Keeps the subscription but resumes interrupt events.
       */
    /**
     * @return {?}
     */
    Interrupt.prototype.resume = /*
       * Keeps the subscription but resumes interrupt events.
       */
    /**
     * @return {?}
     */
    function () {
        this.source.attach();
    };
    /*
     * Keeps the subscription but pauses interrupt events.
     */
    /*
       * Keeps the subscription but pauses interrupt events.
       */
    /**
     * @return {?}
     */
    Interrupt.prototype.pause = /*
       * Keeps the subscription but pauses interrupt events.
       */
    /**
     * @return {?}
     */
    function () {
        this.source.detach();
    };
    return Interrupt;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
KeepaliveSvc = /** @class */ (function () {
    function KeepaliveSvc() {
    }
    return KeepaliveSvc;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in
 * private mode)
 * @implements Storage
 */
var /*
 * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in
 * private mode)
 * @implements Storage
 */
AlternativeStorage = /** @class */ (function () {
    function AlternativeStorage() {
        this.storageMap = {};
    }
    Object.defineProperty(AlternativeStorage.prototype, "length", {
        /*
         * Returns an integer representing the number of data items stored in the storageMap object.
         */
        get: /*
           * Returns an integer representing the number of data items stored in the storageMap object.
           */
        /**
         * @return {?}
         */
        function () {
            return Object.keys(this.storageMap).length;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Remove all keys out of the storage.
     */
    /*
       * Remove all keys out of the storage.
       */
    /**
     * @return {?}
     */
    AlternativeStorage.prototype.clear = /*
       * Remove all keys out of the storage.
       */
    /**
     * @return {?}
     */
    function () {
        this.storageMap = {};
    };
    /*
     * Return the key's value
     *
     * @param key - name of the key to retrieve the value of.
     * @return The key's value
     */
    /*
       * Return the key's value
       *
       * @param key - name of the key to retrieve the value of.
       * @return The key's value
       */
    /**
     * @param {?} key
     * @return {?}
     */
    AlternativeStorage.prototype.getItem = /*
       * Return the key's value
       *
       * @param key - name of the key to retrieve the value of.
       * @return The key's value
       */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        if (typeof this.storageMap[key] !== 'undefined') {
            return this.storageMap[key];
        }
        return null;
    };
    /*
     * Return the nth key in the storage
     *
     * @param index - the number of the key you want to get the name of.
     * @return The name of the key.
     */
    /*
       * Return the nth key in the storage
       *
       * @param index - the number of the key you want to get the name of.
       * @return The name of the key.
       */
    /**
     * @param {?} index
     * @return {?}
     */
    AlternativeStorage.prototype.key = /*
       * Return the nth key in the storage
       *
       * @param index - the number of the key you want to get the name of.
       * @return The name of the key.
       */
    /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return Object.keys(this.storageMap)[index] || null;
    };
    /*
     * Remove a key from the storage.
     *
     * @param key - the name of the key you want to remove.
     */
    /*
       * Remove a key from the storage.
       *
       * @param key - the name of the key you want to remove.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    AlternativeStorage.prototype.removeItem = /*
       * Remove a key from the storage.
       *
       * @param key - the name of the key you want to remove.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        this.storageMap[key] = undefined;
    };
    /*
     * Add a key to the storage, or update a key's value if it already exists.
     *
     * @param key - the name of the key.
     * @param value - the value you want to give to the key.
     */
    /*
       * Add a key to the storage, or update a key's value if it already exists.
       *
       * @param key - the name of the key.
       * @param value - the value you want to give to the key.
       */
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    AlternativeStorage.prototype.setItem = /*
       * Add a key to the storage, or update a key's value if it already exists.
       *
       * @param key - the name of the key.
       * @param value - the value you want to give to the key.
       */
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        this.storageMap[key] = value;
    };
    return AlternativeStorage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Represents a localStorage store.
 */
var LocalStorage = /** @class */ (function () {
    function LocalStorage() {
        this.storage = this.getStorage();
    }
    /*
     * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem
     * throw QuotaExceededError. We're going to detect this and just silently drop any calls to
     * setItem
     * to avoid the entire page breaking, without having to do a check at each usage of Storage.
     */
    /*
       * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem
       * throw QuotaExceededError. We're going to detect this and just silently drop any calls to
       * setItem
       * to avoid the entire page breaking, without having to do a check at each usage of Storage.
       */
    /**
     * @private
     * @return {?}
     */
    LocalStorage.prototype.getStorage = /*
       * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem
       * throw QuotaExceededError. We're going to detect this and just silently drop any calls to
       * setItem
       * to avoid the entire page breaking, without having to do a check at each usage of Storage.
       */
    /**
     * @private
     * @return {?}
     */
    function () {
        try {
            /** @type {?} */
            var storage = localStorage;
            storage.setItem('ng2IdleStorage', '');
            storage.removeItem('ng2IdleStorage');
            return storage;
        }
        catch (err) {
            return new AlternativeStorage();
        }
    };
    /*
     * Gets an item in the storage.
     *
     * @param value - The value to get.
     * @return The current value.
     */
    /*
       * Gets an item in the storage.
       *
       * @param value - The value to get.
       * @return The current value.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorage.prototype.getItem = /*
       * Gets an item in the storage.
       *
       * @param value - The value to get.
       * @return The current value.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.storage.getItem('ng2Idle.' + key);
    };
    /*
     * Removes an item in the storage.
     *
     * @param value - The value to remove.
     */
    /*
       * Removes an item in the storage.
       *
       * @param value - The value to remove.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorage.prototype.removeItem = /*
       * Removes an item in the storage.
       *
       * @param value - The value to remove.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        this.storage.removeItem('ng2Idle.' + key);
    };
    /*
     * Sets an item in the storage.
     *
     * @param key - The key to set the value.
     * @param value - The value to set to the key.
     */
    /*
       * Sets an item in the storage.
       *
       * @param key - The key to set the value.
       * @param value - The value to set to the key.
       */
    /**
     * @param {?} key
     * @param {?} data
     * @return {?}
     */
    LocalStorage.prototype.setItem = /*
       * Sets an item in the storage.
       *
       * @param key - The key to set the value.
       * @param value - The value to set to the key.
       */
    /**
     * @param {?} key
     * @param {?} data
     * @return {?}
     */
    function (key, data) {
        this.storage.setItem('ng2Idle.' + key, data);
    };
    /*
     * Represents the storage, commonly use for testing purposes.
     *
     * @param key - The key to set the value.
     * @param value - The value to set to the key.
     */
    /*
       * Represents the storage, commonly use for testing purposes.
       *
       * @param key - The key to set the value.
       * @param value - The value to set to the key.
       */
    /**
     * @return {?}
     */
    LocalStorage.prototype._wrapped = /*
       * Represents the storage, commonly use for testing purposes.
       *
       * @param key - The key to set the value.
       * @param value - The value to set to the key.
       */
    /**
     * @return {?}
     */
    function () {
        return this.storage;
    };
    LocalStorage.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    LocalStorage.ctorParameters = function () { return []; };
    return LocalStorage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Represents a localStorage store of expiry values.
 * @extends IdleExpiry
 */
var LocalStorageExpiry = /** @class */ (function (_super) {
    __extends(LocalStorageExpiry, _super);
    function LocalStorageExpiry(localStorage) {
        var _this = _super.call(this) || this;
        _this.localStorage = localStorage;
        _this.idleName = 'main';
        return _this;
    }
    /*
     * Gets or sets the last expiry date in localStorage.
     * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.
     * @param value - The expiry value to set; omit to only return the value.
     * @return The current expiry value.
     */
    /*
       * Gets or sets the last expiry date in localStorage.
       * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.
       * @param value - The expiry value to set; omit to only return the value.
       * @return The current expiry value.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    LocalStorageExpiry.prototype.last = /*
       * Gets or sets the last expiry date in localStorage.
       * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.
       * @param value - The expiry value to set; omit to only return the value.
       * @return The current expiry value.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value !== void 0) {
            this.setExpiry(value);
        }
        return this.getExpiry();
    };
    /**
     * @param {?=} value
     * @return {?}
     */
    LocalStorageExpiry.prototype.idling = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value !== void 0) {
            this.setIdling(value);
        }
        return this.getIdling();
    };
    /*
     * Gets the idle name.
     * @return The name of the idle.
     */
    /*
       * Gets the idle name.
       * @return The name of the idle.
       */
    /**
     * @return {?}
     */
    LocalStorageExpiry.prototype.getIdleName = /*
       * Gets the idle name.
       * @return The name of the idle.
       */
    /**
     * @return {?}
     */
    function () {
        return this.idleName;
    };
    /*
     * Sets the idle name.
     * @param The name of the idle.
     */
    /*
       * Sets the idle name.
       * @param The name of the idle.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorageExpiry.prototype.setIdleName = /*
       * Sets the idle name.
       * @param The name of the idle.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        if (key) {
            this.idleName = key;
        }
    };
    /**
     * @private
     * @return {?}
     */
    LocalStorageExpiry.prototype.getExpiry = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var expiry = this.localStorage.getItem(this.idleName + '.expiry');
        if (expiry) {
            return new Date(parseInt(expiry, 10));
        }
        else {
            return null;
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    LocalStorageExpiry.prototype.setExpiry = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());
        }
        else {
            this.localStorage.removeItem(this.idleName + '.expiry');
        }
    };
    /**
     * @private
     * @return {?}
     */
    LocalStorageExpiry.prototype.getIdling = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var idling = this.localStorage.getItem(this.idleName + '.idling');
        if (idling) {
            return idling === 'true';
        }
        else {
            return false;
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    LocalStorageExpiry.prototype.setIdling = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.localStorage.setItem(this.idleName + '.idling', value.toString());
        }
        else {
            this.localStorage.setItem(this.idleName + '.idling', 'false');
        }
    };
    LocalStorageExpiry.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    LocalStorageExpiry.ctorParameters = function () { return [
        { type: LocalStorage }
    ]; };
    return LocalStorageExpiry;
}(IdleExpiry));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var AutoResume = {
    /*
     * Auto resume functionality will be disabled.
     */
    disabled: 0,
    /*
     * Can resume automatically even if they are idle.
     */
    idle: 1,
    /*
     * Can only resume automatically if they are not yet idle.
     */
    notIdle: 2,
};
AutoResume[AutoResume.disabled] = 'disabled';
AutoResume[AutoResume.idle] = 'idle';
AutoResume[AutoResume.notIdle] = 'notIdle';
/**
 * A service for detecting and responding to user idleness.
 */
var Idle = /** @class */ (function () {
    function Idle(expiry, zone, keepaliveSvc) {
        this.expiry = expiry;
        this.zone = zone;
        this.idle = 20 * 60; // in seconds
        // in seconds
        this.timeoutVal = 30; // in seconds
        // in seconds
        this.autoResume = AutoResume.idle;
        this.interrupts = new Array();
        this.running = false;
        this.keepaliveEnabled = false;
        this.onIdleStart = new EventEmitter();
        this.onIdleEnd = new EventEmitter();
        this.onTimeoutWarning = new EventEmitter();
        this.onTimeout = new EventEmitter();
        this.onInterrupt = new EventEmitter();
        if (keepaliveSvc) {
            this.keepaliveSvc = keepaliveSvc;
            this.keepaliveEnabled = true;
        }
        this.setIdling(false);
    }
    /*
     * Sets the idle name for localStorage.
     * Important to set if multiple instances of Idle with LocalStorageExpiry
     * @param The name of the idle.
     */
    /*
       * Sets the idle name for localStorage.
       * Important to set if multiple instances of Idle with LocalStorageExpiry
       * @param The name of the idle.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    Idle.prototype.setIdleName = /*
       * Sets the idle name for localStorage.
       * Important to set if multiple instances of Idle with LocalStorageExpiry
       * @param The name of the idle.
       */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        if (this.expiry instanceof LocalStorageExpiry) {
            this.expiry.setIdleName(key);
        }
        else {
            throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');
        }
    };
    /*
     * Returns whether or not keepalive integration is enabled.
     * @return True if integration is enabled; otherwise, false.
     */
    /*
       * Returns whether or not keepalive integration is enabled.
       * @return True if integration is enabled; otherwise, false.
       */
    /**
     * @return {?}
     */
    Idle.prototype.getKeepaliveEnabled = /*
       * Returns whether or not keepalive integration is enabled.
       * @return True if integration is enabled; otherwise, false.
       */
    /**
     * @return {?}
     */
    function () {
        return this.keepaliveEnabled;
    };
    /*
     * Sets and returns whether or not keepalive integration is enabled.
     * @param True if the integration is enabled; otherwise, false.
     * @return The current value.
     */
    /*
       * Sets and returns whether or not keepalive integration is enabled.
       * @param True if the integration is enabled; otherwise, false.
       * @return The current value.
       */
    /**
     * @param {?} value
     * @return {?}
     */
    Idle.prototype.setKeepaliveEnabled = /*
       * Sets and returns whether or not keepalive integration is enabled.
       * @param True if the integration is enabled; otherwise, false.
       * @return The current value.
       */
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!this.keepaliveSvc) {
            throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');
        }
        return (this.keepaliveEnabled = value);
    };
    /*
     * Returns the current timeout value.
     * @return The timeout value in seconds.
     */
    /*
       * Returns the current timeout value.
       * @return The timeout value in seconds.
       */
    /**
     * @return {?}
     */
    Idle.prototype.getTimeout = /*
       * Returns the current timeout value.
       * @return The timeout value in seconds.
       */
    /**
     * @return {?}
     */
    function () {
        return this.timeoutVal;
    };
    /*
     * Sets the timeout value.
     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.
     * @return The current value. If disabled, the value will be 0.
     */
    /*
       * Sets the timeout value.
       * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.
       * @return The current value. If disabled, the value will be 0.
       */
    /**
     * @param {?} seconds
     * @return {?}
     */
    Idle.prototype.setTimeout = /*
       * Sets the timeout value.
       * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.
       * @return The current value. If disabled, the value will be 0.
       */
    /**
     * @param {?} seconds
     * @return {?}
     */
    function (seconds) {
        if (seconds === false) {
            this.timeoutVal = 0;
        }
        else if (typeof seconds === 'number' && seconds >= 0) {
            this.timeoutVal = seconds;
        }
        else {
            throw new Error("'seconds' can only be 'false' or a positive number.");
        }
        return this.timeoutVal;
    };
    /*
     * Returns the current idle value.
     * @return The idle value in seconds.
     */
    /*
       * Returns the current idle value.
       * @return The idle value in seconds.
       */
    /**
     * @return {?}
     */
    Idle.prototype.getIdle = /*
       * Returns the current idle value.
       * @return The idle value in seconds.
       */
    /**
     * @return {?}
     */
    function () {
        return this.idle;
    };
    /*
     * Sets the idle value.
     * @param seconds - The idle value in seconds.
     * @return The idle value in seconds.
     */
    /*
       * Sets the idle value.
       * @param seconds - The idle value in seconds.
       * @return The idle value in seconds.
       */
    /**
     * @param {?} seconds
     * @return {?}
     */
    Idle.prototype.setIdle = /*
       * Sets the idle value.
       * @param seconds - The idle value in seconds.
       * @return The idle value in seconds.
       */
    /**
     * @param {?} seconds
     * @return {?}
     */
    function (seconds) {
        if (seconds <= 0) {
            throw new Error("'seconds' must be greater zero");
        }
        return (this.idle = seconds);
    };
    /*
     * Returns the current autoresume value.
     * @return The current value.
     */
    /*
       * Returns the current autoresume value.
       * @return The current value.
       */
    /**
     * @return {?}
     */
    Idle.prototype.getAutoResume = /*
       * Returns the current autoresume value.
       * @return The current value.
       */
    /**
     * @return {?}
     */
    function () {
        return this.autoResume;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    Idle.prototype.setAutoResume = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (this.autoResume = value);
    };
    /*
     * Sets interrupts from the specified sources.
     * @param sources - Interrupt sources.
     * @return The resulting interrupts.
     */
    /*
       * Sets interrupts from the specified sources.
       * @param sources - Interrupt sources.
       * @return The resulting interrupts.
       */
    /**
     * @param {?} sources
     * @return {?}
     */
    Idle.prototype.setInterrupts = /*
       * Sets interrupts from the specified sources.
       * @param sources - Interrupt sources.
       * @return The resulting interrupts.
       */
    /**
     * @param {?} sources
     * @return {?}
     */
    function (sources) {
        var e_1, _a;
        this.clearInterrupts();
        /** @type {?} */
        var self = this;
        try {
            for (var sources_1 = __values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
                var source = sources_1_1.value;
                /** @type {?} */
                var sub = new Interrupt(source);
                sub.subscribe((/**
                 * @param {?} args
                 * @return {?}
                 */
                function (args) {
                    self.interrupt(args.force, args.innerArgs);
                }));
                this.interrupts.push(sub);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sources_1_1 && !sources_1_1.done && (_a = sources_1.return)) _a.call(sources_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this.interrupts;
    };
    /*
     * Returns the current interrupts.
     * @return The current interrupts.
     */
    /*
       * Returns the current interrupts.
       * @return The current interrupts.
       */
    /**
     * @return {?}
     */
    Idle.prototype.getInterrupts = /*
       * Returns the current interrupts.
       * @return The current interrupts.
       */
    /**
     * @return {?}
     */
    function () {
        return this.interrupts;
    };
    /*
     * Pauses, unsubscribes, and clears the current interrupt subscriptions.
     */
    /*
       * Pauses, unsubscribes, and clears the current interrupt subscriptions.
       */
    /**
     * @return {?}
     */
    Idle.prototype.clearInterrupts = /*
       * Pauses, unsubscribes, and clears the current interrupt subscriptions.
       */
    /**
     * @return {?}
     */
    function () {
        var e_2, _a;
        try {
            for (var _b = __values(this.interrupts), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sub = _c.value;
                sub.pause();
                sub.unsubscribe();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.interrupts.length = 0;
    };
    /*
     * Returns whether or not the service is running i.e. watching for idleness.
     * @return True if service is watching; otherwise, false.
     */
    /*
       * Returns whether or not the service is running i.e. watching for idleness.
       * @return True if service is watching; otherwise, false.
       */
    /**
     * @return {?}
     */
    Idle.prototype.isRunning = /*
       * Returns whether or not the service is running i.e. watching for idleness.
       * @return True if service is watching; otherwise, false.
       */
    /**
     * @return {?}
     */
    function () {
        return this.running;
    };
    /*
     * Returns whether or not the user is considered idle.
     * @return True if the user is in the idle state; otherwise, false.
     */
    /*
       * Returns whether or not the user is considered idle.
       * @return True if the user is in the idle state; otherwise, false.
       */
    /**
     * @return {?}
     */
    Idle.prototype.isIdling = /*
       * Returns whether or not the user is considered idle.
       * @return True if the user is in the idle state; otherwise, false.
       */
    /**
     * @return {?}
     */
    function () {
        return this.idling;
    };
    /*
     * Starts watching for inactivity.
     */
    /*
       * Starts watching for inactivity.
       */
    /**
     * @param {?=} skipExpiry
     * @return {?}
     */
    Idle.prototype.watch = /*
       * Starts watching for inactivity.
       */
    /**
     * @param {?=} skipExpiry
     * @return {?}
     */
    function (skipExpiry) {
        var _this = this;
        this.safeClearInterval('idleHandle');
        this.safeClearInterval('timeoutHandle');
        /** @type {?} */
        var timeout = !this.timeoutVal ? 0 : this.timeoutVal;
        if (!skipExpiry) {
            /** @type {?} */
            var value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);
            this.expiry.last(value);
        }
        if (this.idling) {
            this.toggleState();
        }
        if (!this.running) {
            this.startKeepalive();
            this.toggleInterrupts(true);
        }
        this.running = true;
        /** @type {?} */
        var watchFn = (/**
         * @return {?}
         */
        function () {
            _this.zone.run((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var diff = _this.getExpiryDiff(timeout);
                if (diff > 0) {
                    _this.safeClearInterval('idleHandle');
                    _this.setIdleIntervalOutsideOfZone(watchFn, diff);
                }
                else {
                    _this.toggleState();
                }
            }));
        });
        this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);
    };
    /*
     * Allows protractor tests to call waitForAngular without hanging
     */
    /*
       * Allows protractor tests to call waitForAngular without hanging
       */
    /**
     * @param {?} watchFn
     * @param {?} frequency
     * @return {?}
     */
    Idle.prototype.setIdleIntervalOutsideOfZone = /*
       * Allows protractor tests to call waitForAngular without hanging
       */
    /**
     * @param {?} watchFn
     * @param {?} frequency
     * @return {?}
     */
    function (watchFn, frequency) {
        var _this = this;
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            _this.idleHandle = setInterval(watchFn, frequency);
        }));
    };
    /*
     * Stops watching for inactivity.
     */
    /*
       * Stops watching for inactivity.
       */
    /**
     * @return {?}
     */
    Idle.prototype.stop = /*
       * Stops watching for inactivity.
       */
    /**
     * @return {?}
     */
    function () {
        this.stopKeepalive();
        this.toggleInterrupts(false);
        this.safeClearInterval('idleHandle');
        this.safeClearInterval('timeoutHandle');
        this.setIdling(false);
        this.running = false;
        this.expiry.last(null);
    };
    /*
     * Forces a timeout event and state.
     */
    /*
       * Forces a timeout event and state.
       */
    /**
     * @return {?}
     */
    Idle.prototype.timeout = /*
       * Forces a timeout event and state.
       */
    /**
     * @return {?}
     */
    function () {
        this.stopKeepalive();
        this.toggleInterrupts(false);
        this.safeClearInterval('idleHandle');
        this.safeClearInterval('timeoutHandle');
        this.setIdling(true);
        this.running = false;
        this.countdown = 0;
        this.onTimeout.emit(null);
    };
    /*
     * Signals that user activity has occurred.
     * @param force - Forces watch to be called, unless they are timed out.
     * @param eventArgs - Optional source event arguments.
     */
    /*
       * Signals that user activity has occurred.
       * @param force - Forces watch to be called, unless they are timed out.
       * @param eventArgs - Optional source event arguments.
       */
    /**
     * @param {?=} force
     * @param {?=} eventArgs
     * @return {?}
     */
    Idle.prototype.interrupt = /*
       * Signals that user activity has occurred.
       * @param force - Forces watch to be called, unless they are timed out.
       * @param eventArgs - Optional source event arguments.
       */
    /**
     * @param {?=} force
     * @param {?=} eventArgs
     * @return {?}
     */
    function (force, eventArgs) {
        if (!this.running) {
            return;
        }
        if (this.timeoutVal && this.expiry.isExpired()) {
            this.timeout();
            return;
        }
        this.onInterrupt.emit(eventArgs);
        if (force === true ||
            this.autoResume === AutoResume.idle ||
            (this.autoResume === AutoResume.notIdle && !this.expiry.idling())) {
            this.watch(force);
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    Idle.prototype.setIdling = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.idling = value;
        this.expiry.idling(value);
    };
    /**
     * @private
     * @return {?}
     */
    Idle.prototype.toggleState = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.setIdling(!this.idling);
        if (this.idling) {
            this.onIdleStart.emit(null);
            this.stopKeepalive();
            if (this.timeoutVal > 0) {
                this.countdown = this.timeoutVal;
                this.doCountdown();
                this.setTimoutIntervalOutsideZone((/**
                 * @return {?}
                 */
                function () {
                    _this.doCountdownInZone();
                }), 1000);
            }
        }
        else {
            this.toggleInterrupts(true);
            this.onIdleEnd.emit(null);
            this.startKeepalive();
        }
        this.safeClearInterval('idleHandle');
    };
    /**
     * @private
     * @param {?} intervalFn
     * @param {?} frequency
     * @return {?}
     */
    Idle.prototype.setTimoutIntervalOutsideZone = /**
     * @private
     * @param {?} intervalFn
     * @param {?} frequency
     * @return {?}
     */
    function (intervalFn, frequency) {
        var _this = this;
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            _this.timeoutHandle = setInterval((/**
             * @return {?}
             */
            function () {
                intervalFn();
            }), frequency);
        }));
    };
    /**
     * @private
     * @param {?} resume
     * @return {?}
     */
    Idle.prototype.toggleInterrupts = /**
     * @private
     * @param {?} resume
     * @return {?}
     */
    function (resume) {
        var e_3, _a;
        try {
            for (var _b = __values(this.interrupts), _c = _b.next(); !_c.done; _c = _b.next()) {
                var interrupt = _c.value;
                if (resume) {
                    interrupt.resume();
                }
                else {
                    interrupt.pause();
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    /**
     * @private
     * @param {?} timeout
     * @return {?}
     */
    Idle.prototype.getExpiryDiff = /**
     * @private
     * @param {?} timeout
     * @return {?}
     */
    function (timeout) {
        /** @type {?} */
        var now = this.expiry.now();
        /** @type {?} */
        var last = this.expiry.last() || now;
        return last.getTime() - now.getTime() - timeout * 1000;
    };
    /**
     * @private
     * @return {?}
     */
    Idle.prototype.doCountdownInZone = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.run((/**
         * @return {?}
         */
        function () {
            _this.doCountdown();
        }));
    };
    /**
     * @private
     * @return {?}
     */
    Idle.prototype.doCountdown = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var diff = this.getExpiryDiff(this.timeoutVal);
        if (diff > 0) {
            this.safeClearInterval('timeoutHandle');
            this.interrupt(true);
            return;
        }
        if (!this.idling) {
            return;
        }
        if (this.countdown <= 0) {
            this.timeout();
            return;
        }
        this.onTimeoutWarning.emit(this.countdown);
        this.countdown--;
    };
    /**
     * @private
     * @param {?} handleName
     * @return {?}
     */
    Idle.prototype.safeClearInterval = /**
     * @private
     * @param {?} handleName
     * @return {?}
     */
    function (handleName) {
        /** @type {?} */
        var handle = this[handleName];
        if (handle !== null && typeof handle !== 'undefined') {
            clearInterval(this[handleName]);
            this[handleName] = null;
        }
    };
    /**
     * @private
     * @return {?}
     */
    Idle.prototype.startKeepalive = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.keepaliveSvc || !this.keepaliveEnabled) {
            return;
        }
        if (this.running) {
            this.keepaliveSvc.ping();
        }
        this.keepaliveSvc.start();
    };
    /**
     * @private
     * @return {?}
     */
    Idle.prototype.stopKeepalive = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.keepaliveSvc || !this.keepaliveEnabled) {
            return;
        }
        this.keepaliveSvc.stop();
    };
    /*
     * Called by Angular when destroying the instance.
     */
    /*
       * Called by Angular when destroying the instance.
       */
    /**
     * @return {?}
     */
    Idle.prototype.ngOnDestroy = /*
       * Called by Angular when destroying the instance.
       */
    /**
     * @return {?}
     */
    function () {
        this.stop();
        this.clearInterrupts();
    };
    Idle.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Idle.ctorParameters = function () { return [
        { type: IdleExpiry },
        { type: NgZone },
        { type: KeepaliveSvc, decorators: [{ type: Optional }] }
    ]; };
    return Idle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * A class for expressing arguments to interrupt events.
 */
var  /*
 * A class for expressing arguments to interrupt events.
 */
InterruptArgs = /** @class */ (function () {
    function InterruptArgs(source, innerArgs, force) {
        if (force === void 0) { force = false; }
        this.source = source;
        this.innerArgs = innerArgs;
        this.force = force;
    }
    return InterruptArgs;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * A base for classes that act as a source for interrupts.
 */
/**
 * @abstract
 */
var  /*
 * A base for classes that act as a source for interrupts.
 */
/**
 * @abstract
 */
InterruptSource = /** @class */ (function () {
    function InterruptSource(attachFn, detachFn) {
        this.attachFn = attachFn;
        this.detachFn = detachFn;
        this.isAttached = false;
        this.onInterrupt = new EventEmitter();
    }
    /*
     * Attaches to the specified events on the specified source.
     */
    /*
       * Attaches to the specified events on the specified source.
       */
    /**
     * @return {?}
     */
    InterruptSource.prototype.attach = /*
       * Attaches to the specified events on the specified source.
       */
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone
        // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode
        // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)
        if (Zone.current.get('isAngularZone') === true) {
            Zone.current.parent.run((/**
             * @return {?}
             */
            function () { return _this.attach(); }));
            return;
        }
        if (!this.isAttached && this.attachFn) {
            this.attachFn(this);
        }
        this.isAttached = true;
    };
    /*
     * Detaches from the specified events on the specified source.
     */
    /*
       * Detaches from the specified events on the specified source.
       */
    /**
     * @return {?}
     */
    InterruptSource.prototype.detach = /*
       * Detaches from the specified events on the specified source.
       */
    /**
     * @return {?}
     */
    function () {
        if (this.isAttached && this.detachFn) {
            this.detachFn(this);
        }
        this.isAttached = false;
    };
    return InterruptSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var defaultThrottleDelay = 500;
/*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
var  /*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
EventTargetInterruptSource = /** @class */ (function (_super) {
    __extends(EventTargetInterruptSource, _super);
    function EventTargetInterruptSource(target, events, options) {
        var _this = _super.call(this, null, null) || this;
        _this.target = target;
        _this.events = events;
        _this.eventSubscription = new Subscription();
        if (typeof options === 'number') {
            options = { throttleDelay: options, passive: false };
        }
        options = options || {
            throttleDelay: defaultThrottleDelay,
            passive: false
        };
        if (options.throttleDelay === undefined || options.throttleDelay === null) {
            options.throttleDelay = defaultThrottleDelay;
        }
        _this.throttleDelay = options.throttleDelay;
        _this.passive = !!options.passive;
        /** @type {?} */
        var opts = _this.passive ? { passive: true } : null;
        /** @type {?} */
        var fromEvents = events
            .split(' ')
            .map((/**
         * @param {?} eventName
         * @return {?}
         */
        function (eventName) { return fromEvent(target, eventName, opts); }));
        _this.eventSrc = merge.apply(void 0, __spread(fromEvents));
        _this.eventSrc = _this.eventSrc.pipe(filter((/**
         * @param {?} innerArgs
         * @return {?}
         */
        function (innerArgs) { return !_this.filterEvent(innerArgs); })));
        if (_this.throttleDelay > 0) {
            _this.eventSrc = _this.eventSrc.pipe(throttleTime(_this.throttleDelay));
        }
        /** @type {?} */
        var handler = (/**
         * @param {?} innerArgs
         * @return {?}
         */
        function (innerArgs) {
            return _this.onInterrupt.emit(new InterruptArgs(_this, innerArgs));
        });
        _this.attachFn = (/**
         * @return {?}
         */
        function () {
            return (_this.eventSubscription = _this.eventSrc.subscribe(handler));
        });
        _this.detachFn = (/**
         * @return {?}
         */
        function () { return _this.eventSubscription.unsubscribe(); });
        return _this;
    }
    /*
     * Checks to see if the event should be filtered. Always returns false unless overriden.
     * @param event - The original event object.
     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
     */
    /*
       * Checks to see if the event should be filtered. Always returns false unless overriden.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    EventTargetInterruptSource.prototype.filterEvent = /*
       * Checks to see if the event should be filtered. Always returns false unless overriden.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return false;
    };
    Object.defineProperty(EventTargetInterruptSource.prototype, "options", {
        /**
         * Returns the current options being used.
         * @return The current option values.
         */
        get: /**
         * Returns the current options being used.
         * @return {?} The current option values.
         */
        function () {
            return { throttleDelay: this.throttleDelay, passive: this.passive };
        },
        enumerable: true,
        configurable: true
    });
    return EventTargetInterruptSource;
}(InterruptSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * An interrupt source that uses events on the document element (html tag).
 */
var  /*
 * An interrupt source that uses events on the document element (html tag).
 */
DocumentInterruptSource = /** @class */ (function (_super) {
    __extends(DocumentInterruptSource, _super);
    function DocumentInterruptSource(events, options) {
        return _super.call(this, document.documentElement, events, options) || this;
    }
    /*
     * Checks to see if the event should be filtered.
     * @param event - The original event object.
     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
     */
    /*
       * Checks to see if the event should be filtered.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @param {?} event
     * @return {?}
     */
    DocumentInterruptSource.prototype.filterEvent = /*
       * Checks to see if the event should be filtered.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // some browser bad input hacks
        if (event.type === 'mousemove' &&
            // fix for Chrome destop notifications
            ((event.originalEvent &&
                event.originalEvent.movementX === 0 &&
                event.originalEvent.movementY === 0) ||
                // fix for webkit fake mousemove
                ((event.movementX !== void 0 && !event.movementX) || !event.movementY))) {
            return true;
        }
        return false;
    };
    return DocumentInterruptSource;
}(EventTargetInterruptSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * An interrupt source on the Window object.
 */
var  /*
 * An interrupt source on the Window object.
 */
WindowInterruptSource = /** @class */ (function (_super) {
    __extends(WindowInterruptSource, _super);
    function WindowInterruptSource(events, options) {
        return _super.call(this, window, events, options) || this;
    }
    return WindowInterruptSource;
}(EventTargetInterruptSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * An interrupt source on the storage event of Window.
 */
var  /*
 * An interrupt source on the storage event of Window.
 */
StorageInterruptSource = /** @class */ (function (_super) {
    __extends(StorageInterruptSource, _super);
    function StorageInterruptSource(throttleDelay) {
        if (throttleDelay === void 0) { throttleDelay = 500; }
        return _super.call(this, 'storage', throttleDelay) || this;
    }
    /*
     * Checks to see if the event should be filtered.
     * @param event - The original event object.
     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
     */
    /*
       * Checks to see if the event should be filtered.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @param {?} event
     * @return {?}
     */
    StorageInterruptSource.prototype.filterEvent = /*
       * Checks to see if the event should be filtered.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key &&
            event.key.indexOf('ng2Idle.') >= 0 &&
            event.key.indexOf('.expiry') >= 0) {
            return false;
        }
        return true;
    };
    return StorageInterruptSource;
}(WindowInterruptSource));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Represents a simple in-memory store of expiry values.
 * @extends IdleExpiry
 */
var  /*
 * Represents a simple in-memory store of expiry values.
 * @extends IdleExpiry
 */
SimpleExpiry = /** @class */ (function (_super) {
    __extends(SimpleExpiry, _super);
    function SimpleExpiry() {
        var _this = _super.call(this) || this;
        _this.lastValue = null;
        return _this;
    }
    /*
     * Gets or sets the last expiry date.
     * @param value - The expiry value to set; omit to only return the value.
     * @return The current expiry value.
     */
    /*
       * Gets or sets the last expiry date.
       * @param value - The expiry value to set; omit to only return the value.
       * @return The current expiry value.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    SimpleExpiry.prototype.last = /*
       * Gets or sets the last expiry date.
       * @param value - The expiry value to set; omit to only return the value.
       * @return The current expiry value.
       */
    /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value !== void 0) {
            this.lastValue = value;
        }
        return this.lastValue;
    };
    return SimpleExpiry;
}(IdleExpiry));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgIdleModule = /** @class */ (function () {
    function NgIdleModule() {
    }
    /**
     * @return {?}
     */
    NgIdleModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: NgIdleModule,
            providers: [
                LocalStorageExpiry,
                { provide: IdleExpiry, useExisting: LocalStorageExpiry },
                Idle
            ]
        };
    };
    NgIdleModule.decorators = [
        { type: NgModule, args: [{
                    providers: [LocalStorage]
                },] }
    ];
    return NgIdleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?=} options
 * @return {?}
 */
function createDefaultInterruptSources(options) {
    return [
        new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options),
        new StorageInterruptSource()
    ];
}
/** @type {?} */
var DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources };
//# sourceMappingURL=ng-idle-core.js.map

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Subscription, fromEvent, merge } from 'rxjs';
import { filter, throttleTime } from 'rxjs/operators';
import { InterruptArgs } from './interruptargs';
import { InterruptSource } from './interruptsource';
/**
 * Options for EventTargetInterruptSource
 * @record
 */
export function EventTargetInterruptOptions() { }
if (false) {
    /**
     * The number of milliseconds to throttle the events coming from the target.
     * @type {?|undefined}
     */
    EventTargetInterruptOptions.prototype.throttleDelay;
    /**
     * Whether or not to use passive event listeners.
     * Note: you need to detect if the browser supports passive listeners, and only set this to true if it does.
     * @type {?|undefined}
     */
    EventTargetInterruptOptions.prototype.passive;
}
/** @type {?} */
const defaultThrottleDelay = 500;
/*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
export class EventTargetInterruptSource extends InterruptSource {
    /**
     * @param {?} target
     * @param {?} events
     * @param {?=} options
     */
    constructor(target, events, options) {
        super(null, null);
        this.target = target;
        this.events = events;
        this.eventSubscription = new Subscription();
        if (typeof options === 'number') {
            options = { throttleDelay: options, passive: false };
        }
        options = options || {
            throttleDelay: defaultThrottleDelay,
            passive: false
        };
        if (options.throttleDelay === undefined || options.throttleDelay === null) {
            options.throttleDelay = defaultThrottleDelay;
        }
        this.throttleDelay = options.throttleDelay;
        this.passive = !!options.passive;
        /** @type {?} */
        const opts = this.passive ? { passive: true } : null;
        /** @type {?} */
        const fromEvents = events
            .split(' ')
            .map((/**
         * @param {?} eventName
         * @return {?}
         */
        eventName => fromEvent(target, eventName, opts)));
        this.eventSrc = merge(...fromEvents);
        this.eventSrc = this.eventSrc.pipe(filter((/**
         * @param {?} innerArgs
         * @return {?}
         */
        innerArgs => !this.filterEvent(innerArgs))));
        if (this.throttleDelay > 0) {
            this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));
        }
        /** @type {?} */
        const handler = (/**
         * @param {?} innerArgs
         * @return {?}
         */
        (innerArgs) => this.onInterrupt.emit(new InterruptArgs(this, innerArgs)));
        this.attachFn = (/**
         * @return {?}
         */
        () => (this.eventSubscription = this.eventSrc.subscribe(handler)));
        this.detachFn = (/**
         * @return {?}
         */
        () => this.eventSubscription.unsubscribe());
    }
    /*
       * Checks to see if the event should be filtered. Always returns false unless overriden.
       * @param event - The original event object.
       * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
       */
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    filterEvent(event) {
        return false;
    }
    /**
     * Returns the current options being used.
     * @return {?} The current option values.
     */
    get options() {
        return { throttleDelay: this.throttleDelay, passive: this.passive };
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    EventTargetInterruptSource.prototype.eventSrc;
    /**
     * @type {?}
     * @private
     */
    EventTargetInterruptSource.prototype.eventSubscription;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.throttleDelay;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.passive;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.target;
    /**
     * @type {?}
     * @protected
     */
    EventTargetInterruptSource.prototype.events;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnR0YXJnZXRpbnRlcnJ1cHRzb3VyY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmctaWRsZS9jb3JlLyIsInNvdXJjZXMiOlsibGliL2V2ZW50dGFyZ2V0aW50ZXJydXB0c291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQWMsWUFBWSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEUsT0FBTyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7OztBQUtwRCxpREFXQzs7Ozs7O0lBUEMsb0RBQXVCOzs7Ozs7SUFNdkIsOENBQWtCOzs7TUFHZCxvQkFBb0IsR0FBRyxHQUFHOzs7O0FBS2hDLE1BQU0sT0FBTywwQkFBMkIsU0FBUSxlQUFlOzs7Ozs7SUFNN0QsWUFDWSxNQUFXLEVBQ1gsTUFBYyxFQUN4QixPQUE4QztRQUU5QyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBSlIsV0FBTSxHQUFOLE1BQU0sQ0FBSztRQUNYLFdBQU0sR0FBTixNQUFNLENBQVE7UUFObEIsc0JBQWlCLEdBQWlCLElBQUksWUFBWSxFQUFFLENBQUM7UUFXM0QsSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7WUFDL0IsT0FBTyxHQUFHLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7U0FDdEQ7UUFFRCxPQUFPLEdBQUcsT0FBTyxJQUFJO1lBQ25CLGFBQWEsRUFBRSxvQkFBb0I7WUFDbkMsT0FBTyxFQUFFLEtBQUs7U0FDZixDQUFDO1FBRUYsSUFBSSxPQUFPLENBQUMsYUFBYSxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsYUFBYSxLQUFLLElBQUksRUFBRTtZQUN6RSxPQUFPLENBQUMsYUFBYSxHQUFHLG9CQUFvQixDQUFDO1NBQzlDO1FBRUQsSUFBSSxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDO1FBQzNDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7O2NBRTNCLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSTs7Y0FDOUMsVUFBVSxHQUFHLE1BQU07YUFDdEIsS0FBSyxDQUFDLEdBQUcsQ0FBQzthQUNWLEdBQUc7Ozs7UUFBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBTSxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxFQUFDO1FBQzVELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FDaEMsTUFBTTs7OztRQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFDLENBQ2xELENBQUM7UUFDRixJQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1NBQ3RFOztjQUVLLE9BQU87Ozs7UUFBRyxDQUFDLFNBQWMsRUFBRSxFQUFFLENBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFBO1FBRTNELElBQUksQ0FBQyxRQUFROzs7UUFBRyxHQUFHLEVBQUUsQ0FDbkIsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQSxDQUFDO1FBRTlELElBQUksQ0FBQyxRQUFROzs7UUFBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUEsQ0FBQztJQUM3RCxDQUFDOzs7Ozs7Ozs7OztJQU9TLFdBQVcsQ0FBQyxLQUFVO1FBQzlCLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs7Ozs7SUFNRCxJQUFJLE9BQU87UUFDVCxPQUFPLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN0RSxDQUFDO0NBQ0Y7Ozs7OztJQWpFQyw4Q0FBa0M7Ozs7O0lBQ2xDLHVEQUE2RDs7Ozs7SUFDN0QsbURBQWdDOzs7OztJQUNoQyw2Q0FBMkI7Ozs7O0lBR3pCLDRDQUFxQjs7Ozs7SUFDckIsNENBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBmcm9tRXZlbnQsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRocm90dGxlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgSW50ZXJydXB0QXJncyB9IGZyb20gJy4vaW50ZXJydXB0YXJncyc7XG5pbXBvcnQgeyBJbnRlcnJ1cHRTb3VyY2UgfSBmcm9tICcuL2ludGVycnVwdHNvdXJjZSc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgRXZlbnRUYXJnZXRJbnRlcnJ1cHRTb3VyY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFdmVudFRhcmdldEludGVycnVwdE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgdGhlIGV2ZW50cyBjb21pbmcgZnJvbSB0aGUgdGFyZ2V0LlxuICAgKi9cbiAgdGhyb3R0bGVEZWxheT86IG51bWJlcjtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gdXNlIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLlxuICAgKiBOb3RlOiB5b3UgbmVlZCB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBsaXN0ZW5lcnMsIGFuZCBvbmx5IHNldCB0aGlzIHRvIHRydWUgaWYgaXQgZG9lcy5cbiAgICovXG4gIHBhc3NpdmU/OiBib29sZWFuO1xufVxuXG5jb25zdCBkZWZhdWx0VGhyb3R0bGVEZWxheSA9IDUwMDtcblxuLypcbiAqIEFuIGludGVycnVwdCBzb3VyY2Ugb24gYW4gRXZlbnRUYXJnZXQgb2JqZWN0LCBzdWNoIGFzIGEgV2luZG93IG9yIEhUTUxFbGVtZW50LlxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRUYXJnZXRJbnRlcnJ1cHRTb3VyY2UgZXh0ZW5kcyBJbnRlcnJ1cHRTb3VyY2Uge1xuICBwcml2YXRlIGV2ZW50U3JjOiBPYnNlcnZhYmxlPGFueT47XG4gIHByaXZhdGUgZXZlbnRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgcHJvdGVjdGVkIHRocm90dGxlRGVsYXk6IG51bWJlcjtcbiAgcHJvdGVjdGVkIHBhc3NpdmU6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHRhcmdldDogYW55LFxuICAgIHByb3RlY3RlZCBldmVudHM6IHN0cmluZyxcbiAgICBvcHRpb25zPzogbnVtYmVyIHwgRXZlbnRUYXJnZXRJbnRlcnJ1cHRPcHRpb25zXG4gICkge1xuICAgIHN1cGVyKG51bGwsIG51bGwpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucyA9IHsgdGhyb3R0bGVEZWxheTogb3B0aW9ucywgcGFzc2l2ZTogZmFsc2UgfTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICB0aHJvdHRsZURlbGF5OiBkZWZhdWx0VGhyb3R0bGVEZWxheSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnRocm90dGxlRGVsYXkgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnRocm90dGxlRGVsYXkgPT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMudGhyb3R0bGVEZWxheSA9IGRlZmF1bHRUaHJvdHRsZURlbGF5O1xuICAgIH1cblxuICAgIHRoaXMudGhyb3R0bGVEZWxheSA9IG9wdGlvbnMudGhyb3R0bGVEZWxheTtcbiAgICB0aGlzLnBhc3NpdmUgPSAhIW9wdGlvbnMucGFzc2l2ZTtcblxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLnBhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IG51bGw7XG4gICAgY29uc3QgZnJvbUV2ZW50cyA9IGV2ZW50c1xuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoZXZlbnROYW1lID0+IGZyb21FdmVudDxhbnk+KHRhcmdldCwgZXZlbnROYW1lLCBvcHRzKSk7XG4gICAgdGhpcy5ldmVudFNyYyA9IG1lcmdlKC4uLmZyb21FdmVudHMpO1xuICAgIHRoaXMuZXZlbnRTcmMgPSB0aGlzLmV2ZW50U3JjLnBpcGUoXG4gICAgICBmaWx0ZXIoaW5uZXJBcmdzID0+ICF0aGlzLmZpbHRlckV2ZW50KGlubmVyQXJncykpXG4gICAgKTtcbiAgICBpZiAodGhpcy50aHJvdHRsZURlbGF5ID4gMCkge1xuICAgICAgdGhpcy5ldmVudFNyYyA9IHRoaXMuZXZlbnRTcmMucGlwZSh0aHJvdHRsZVRpbWUodGhpcy50aHJvdHRsZURlbGF5KSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlciA9IChpbm5lckFyZ3M6IGFueSkgPT5cbiAgICAgIHRoaXMub25JbnRlcnJ1cHQuZW1pdChuZXcgSW50ZXJydXB0QXJncyh0aGlzLCBpbm5lckFyZ3MpKTtcblxuICAgIHRoaXMuYXR0YWNoRm4gPSAoKSA9PlxuICAgICAgKHRoaXMuZXZlbnRTdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50U3JjLnN1YnNjcmliZShoYW5kbGVyKSk7XG5cbiAgICB0aGlzLmRldGFjaEZuID0gKCkgPT4gdGhpcy5ldmVudFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLypcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZXZlbnQgc2hvdWxkIGJlIGZpbHRlcmVkLiBBbHdheXMgcmV0dXJucyBmYWxzZSB1bmxlc3Mgb3ZlcnJpZGVuLlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGV2ZW50IHNob3VsZCBiZSBmaWx0ZXJlZCAoZG9uJ3QgY2F1c2UgYW4gaW50ZXJydXB0KTsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHByb3RlY3RlZCBmaWx0ZXJFdmVudChldmVudDogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb3B0aW9ucyBiZWluZyB1c2VkLlxuICAgKiBAcmV0dXJuIFRoZSBjdXJyZW50IG9wdGlvbiB2YWx1ZXMuXG4gICAqL1xuICBnZXQgb3B0aW9ucygpOiBFdmVudFRhcmdldEludGVycnVwdE9wdGlvbnMge1xuICAgIHJldHVybiB7IHRocm90dGxlRGVsYXk6IHRoaXMudGhyb3R0bGVEZWxheSwgcGFzc2l2ZTogdGhpcy5wYXNzaXZlIH07XG4gIH1cbn1cbiJdfQ==
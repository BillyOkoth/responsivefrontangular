{"version":3,"sources":["../source/parse_.js"],"names":["VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","MAX_LENGTH_COUNTRY_CODE","matchesEntirely","ParseError","Metadata","isViablePhoneNumber","extractExtension","parseIncompletePhoneNumber","getCountryCallingCode","getNumberType","checkNumberLengthForType","is_possible_number","stripIDDPrefix","parseRFC3966","PhoneNumber","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","AFTER_PHONE_NUMBER_END_PATTERN","parse","text","options","metadata","defaultCountry","hasCountry","v2","Error","parse_input","formattedPhoneNumber","number","ext","parsePhoneNumber","country","nationalNumber","countryCallingCode","carrierCode","selectedCountry","length","phoneNumber","valid","nationalNumberPattern","extended","result","possible","possibleLengths","undefined","phone","extract_formatted_phone_number","starts_at","search","slice","replace","strip_national_prefix_and_carrier_code","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","captured_groups_count","nationalPrefixTransformRule","national_prefix","find_country_code","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","_find_country_code","leadingDigits","indexOf","with_extension_stripped","national_number","extractCountryCallingCode","chooseCountryByCountryCallingCode","parseNationalNumber","exactCountry","potentialNationalNumber","potentialCarrierCode","numberWithoutIDD","i"],"mappings":"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","file":"parse_.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_COUNTRY_CODE\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './isViablePhoneNumber'\r\nimport { extractExtension } from './extension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport getNumberType, { checkNumberLengthForType } from './getNumberType_'\r\nimport { is_possible_number } from './isPossibleNumber_'\r\nimport { stripIDDPrefix } from './IDD'\r\nimport { parseRFC3966 } from './RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options = {}, metadata)\r\n{\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parse_input(text, options.v2)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber)\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst\r\n\t{\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t}\r\n\t= parsePhoneNumber\r\n\t(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.selectedCountry()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2)\r\n\t{\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = country && matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false\r\n\r\n\tif (!options.extended)\r\n\t{\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),\r\n\t\tphone : nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number.\r\n * @param  {string} text - Input.\r\n * @return {string}.\r\n */\r\nexport function extract_formatted_phone_number(text, v2)\r\n{\r\n\tif (!text)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\tif (v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided.\r\n// \"Carrier codes\" are only used  in Colombia and Brazil,\r\n// and only when dialing within those countries from a mobile phone to a fixed line number.\r\nexport function strip_national_prefix_and_carrier_code(number, metadata)\r\n{\r\n\tif (!number || !metadata.nationalPrefixForParsing())\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// In many countries the national prefix\r\n\t// is not just a constant digit (like `0` in UK)\r\n\t// but can be different depending on the phone number\r\n\t// (and can be also absent for some phone numbers).\r\n\t//\r\n\t// So `national_prefix_for_parsing` is used when parsing\r\n\t// a national-prefixed (local) phone number\r\n\t// into a national significant phone number\r\n\t// extracting that possible national prefix out of it.\r\n\t//\r\n\t// Example `national_prefix_for_parsing` for Australia (AU) is `0|(183[12])`.\r\n\t// Which means that in Australia the national prefix can be: `0`, `1831`, `1832`.\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\tlet national_significant_number\r\n\r\n\t// In more complex cases just `national_prefix_for_parsing` regexp\r\n\t// is not enough to extract the national number and then strip it\r\n\t// like `number.slice(national_prefix.length)` because when parsing\r\n\t// national numbers it's not always clear whether the first digits\r\n\t// are a national prefix or part of the national significant number.\r\n\t// For such cases `national_prefix_transform_rule` regexp is present\r\n\t// which contains \"capturing groups\" that are later used in such\r\n\t// `national_prefix_transform_rule` to transform the national number\r\n\t// being parsed into the national significant number.\r\n\t//\r\n\t// Example.\r\n\t// Country: U.S. Virgin Islands (VI).\r\n\t// Country calling code: +1.\r\n\t// Leading digits: 340.\r\n\t// Phone number format: +1 (340) xxx-xxxx.\r\n\t// National prefix: 1.\r\n\t// National prefix for parsing: 1|([2-9]\\d{6})$.\r\n\t// National prefix transform rule: 340$1.\r\n\t//\r\n\t// So for input \"13401234567\" \"national prefix for parsing\" regexp\r\n\t// will return \"1\" and the national significant number will be\r\n\t// \"13401234567\".slice(\"1\".length) === \"(340) 123-4567\".\r\n\t//\r\n\t// And for input \"3401234567\" \"national prefix for parsing\" regexp\r\n\t// the \"captured group\" will be \"3401234567\" and the national significant\r\n\t// number will be \"3401234567\".replace(\"340123\", \"340340123\") === \"(340) 3401234567\".\r\n\t//\r\n\t// `national_prefix_matcher[captured_groups_count]` means that\r\n\t// the corresponding \"captured group\" is not empty.\r\n\t// It can be empty if the regexp either doesn't have any \"capturing groups\"\r\n\t// or if the \"capturing groups\" are defined as optional.\r\n\t// Example: \"0?(?:...)?\" for Argentina.\r\n\t//\r\n\tconst captured_groups_count = national_prefix_matcher.length - 1\r\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\r\n\t}\r\n\t// If it's a simple-enough case then just strip the national prefix from the number.\r\n\telse\r\n\t{\r\n\t\t// National prefix is the whole substring matched by\r\n\t\t// the `national_prefix_for_parsing` regexp.\r\n\t\tconst national_prefix = national_prefix_matcher[0]\r\n\t\tnational_significant_number = number.slice(national_prefix.length)\r\n\t}\r\n\r\n\tlet carrierCode\r\n\tif (captured_groups_count > 0)\r\n\t{\r\n\t\tcarrierCode = national_prefix_matcher[1]\r\n\t}\r\n\r\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\r\n\t//\r\n\t// // Verify the parsed national (significant) number for this country\r\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\r\n\t// //\r\n\t// // If the original number (before stripping national prefix) was viable,\r\n\t// // and the resultant number is not, then prefer the original phone number.\r\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// // a national prefix and a leading digit of a valid national phone number,\r\n\t// // like `8` is the national prefix for Russia and both\r\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t// if (matchesEntirely(number, national_number_rule) &&\r\n\t// \t\t!matchesEntirely(national_significant_number, national_number_rule))\r\n\t// {\r\n\t// \treturn number\r\n\t// }\r\n\r\n\t// Return the parsed national (significant) number\r\n   return {\r\n   \tnumber: national_significant_number,\r\n   \tcarrierCode\r\n   }\r\n}\r\n\r\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_calling_code` is always valid\r\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\r\n{\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tfor (const country of possible_countries)\r\n\t{\r\n\t\tmetadata.country(country)\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits())\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: national_phone_number, country }, undefined, metadata.metadata))\r\n\t\t{\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parse_input(text, v2)\r\n{\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0)\r\n\t{\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\r\n\tlet number = extract_formatted_phone_number(text, v2)\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = extractExtension(number)\r\n\tif (with_extension_stripped.ext)\r\n\t{\r\n\t\treturn with_extension_stripped\r\n\t}\r\n\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, national_number, ext)\r\n{\r\n\tconst result =\r\n\t{\r\n\t\tcountry,\r\n\t\tphone : national_number\r\n\t}\r\n\r\n\tif (ext)\r\n\t{\r\n\t\tresult.ext = ext\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber\r\n * @param {string} [defaultCountry]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(formattedPhoneNumber, defaultCountry, metadata)\r\n{\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tformattedPhoneNumber,\r\n\t\tdefaultCountry,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\tlet country\r\n\r\n\tif (countryCallingCode)\r\n\t{\r\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && defaultCountry)\r\n\t{\r\n\t\tmetadata.country(defaultCountry)\r\n\t\tcountry = defaultCountry\r\n\t\tcountryCallingCode = getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst { nationalNumber, carrierCode } = parseNationalNumber(number, metadata)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = find_country_code(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry)\r\n\t{\r\n\t\tcountry = exactCountry\r\n\t\tmetadata.country(country)\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\nfunction parseNationalNumber(number, metadata)\r\n{\r\n\tlet nationalNumber = parseIncompletePhoneNumber(number)\r\n\tlet carrierCode\r\n\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tnumber: potentialNationalNumber,\r\n\t\tcarrierCode: potentialCarrierCode\r\n\t} = strip_national_prefix_and_carrier_code(nationalNumber, metadata)\r\n\r\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\r\n\tif (metadata.possibleLengths())\r\n\t{\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tswitch (checkNumberLengthForType(potentialNationalNumber, undefined, metadata))\r\n\t\t{\r\n\t\t\tcase 'TOO_SHORT':\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tnationalNumber = potentialNationalNumber\r\n\t\t\t\tcarrierCode = potentialCarrierCode\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t// like `8` is the national prefix for Russia and both\r\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\tif (matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matchesEntirely(potentialNationalNumber, metadata.nationalNumberPattern()))\r\n\t\t{\r\n\t\t\t// Keep the number without stripping national prefix.\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnationalNumber = potentialNationalNumber\r\n\t\t\tcarrierCode = potentialCarrierCode\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}\r\n\r\n// Determines the country for a given (possibly incomplete) phone number.\r\n// export function get_country_from_phone_number(number, metadata)\r\n// {\r\n// \treturn parsePhoneNumber(number, null, metadata).country\r\n// }\r\n\r\n// Parses a formatted phone number\r\n// and returns `{ countryCallingCode, number }`\r\n// where `number` is just the \"number\" part\r\n// which is left after extracting `countryCallingCode`\r\n// and is not necessarily a \"national (significant) number\"\r\n// and might as well contain national prefix.\r\n//\r\nexport function extractCountryCallingCode(number, country, metadata)\r\n{\r\n\tnumber = parseIncompletePhoneNumber(number)\r\n\r\n\tif (!number)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If this is not an international phone number,\r\n\t// then don't extract country phone code.\r\n\tif (number[0] !== '+')\r\n\t{\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIDDPrefix(number, country, metadata)\r\n\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\treturn { number }\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0')\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length)\r\n\t{\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\r\n\t\tif (metadata.countryCallingCodes()[countryCallingCode])\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n"]}
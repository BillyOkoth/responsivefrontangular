import { ApplicationRef, ComponentFactoryResolver, Injectable, Injector, Input, Component, ElementRef, ViewEncapsulation, HostListener, ViewChild, HostBinding, Renderer2, Directive, Output, EventEmitter, ViewContainerRef, NgModule, ChangeDetectionStrategy, ChangeDetectorRef, NgZone, TemplateRef, ContentChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { trigger, style, animate, transition } from '@angular/animations';
import { DomSanitizer } from '@angular/platform-browser';
import { rgb } from 'd3-color';
import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { range, min, max } from 'd3-array';
import { scaleBand, scaleLinear, scaleOrdinal, scaleQuantile, scaleTime, scalePoint } from 'd3-scale';
import { brushX } from 'd3-brush';
import { select, event } from 'd3-selection';
import { curveLinear, area, line, curveCardinalClosed, lineRadial, arc, pie } from 'd3-shape';
import { forceCollide, forceLink, forceManyBody, forceSimulation, forceX, forceY } from 'd3-force';
import { interpolate } from 'd3-interpolate';
import { format } from 'd3-format';
import { treemap, stratify } from 'd3-hierarchy';
import { timeFormat } from 'd3-time-format';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["caretElm"];
function TooltipContentComponent_span_4_ng_template_1_Template(rf, ctx) { }
var _c1 = function (a0) { return { model: a0 }; };
function TooltipContentComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, TooltipContentComponent_span_4_ng_template_1_Template, 0, 0, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1.context));
} }
function TooltipContentComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r2.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function ChartComponent_ngx_charts_scale_legend_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelement(0, "ngx-charts-scale-legend", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === "below")("valueRange", ctx_r0.legendOptions.domain)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth);
} }
function ChartComponent_ngx_charts_legend_4_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "ngx-charts-legend", 5);
    ɵngcc0.ɵɵlistener("labelClick", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.legendLabelClick.emit($event); })("labelActivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelActivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.legendLabelActivate.emit($event); })("labelDeactivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelDeactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.legendLabelDeactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r1.legendOptions && ctx_r1.legendOptions.position === "below")("data", ctx_r1.legendOptions.domain)("title", ctx_r1.legendOptions.title)("colors", ctx_r1.legendOptions.colors)("height", ctx_r1.view[1])("width", ctx_r1.legendWidth)("activeEntries", ctx_r1.activeEntries);
} }
var _c2 = ["*"];
function LegendComponent_header_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 4);
    ɵngcc0.ɵɵelementStart(1, "span", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function LegendComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 6);
    ɵngcc0.ɵɵelementStart(1, "ngx-charts-legend-entry", 7);
    ɵngcc0.ɵɵlistener("select", function LegendComponent_li_4_Template_ngx_charts_legend_entry_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.labelClick.emit($event); })("activate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate($event); })("deactivate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var entry_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", entry_r2.label)("formattedLabel", entry_r2.formattedLabel)("color", entry_r2.color)("isActive", ctx_r1.isActive(entry_r2));
} }
function AdvancedLegendComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", ctx_r0.roundedTotal)("valueFormatting", ctx_r0.valueFormatting);
} }
function AdvancedLegendComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.valueFormatting ? ctx_r1.valueFormatting(ctx_r1.roundedTotal) : ctx_r1.defaultValueFormatting(ctx_r1.roundedTotal), " ");
} }
function AdvancedLegendComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 16);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3._value)("valueFormatting", ctx_r4.valueFormatting);
} }
function AdvancedLegendComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.valueFormatting ? ctx_r5.valueFormatting(legendItem_r3.value) : ctx_r5.defaultValueFormatting(legendItem_r3.value), " ");
} }
function AdvancedLegendComponent_div_7_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 18);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3.percentage)("countSuffix", "%");
} }
function AdvancedLegendComponent_div_7_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", legendItem_r3.percentage.toLocaleString(), "%");
} }
function AdvancedLegendComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("mouseenter", function AdvancedLegendComponent_div_7_Template_div_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.activate.emit(legendItem_r3.data); })("mouseleave", function AdvancedLegendComponent_div_7_Template_div_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.deactivate.emit(legendItem_r3.data); })("click", function AdvancedLegendComponent_div_7_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.select.emit(legendItem_r3.data); });
    ɵngcc0.ɵɵelement(1, "div", 10);
    ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_7_div_2_Template, 1, 2, "div", 11);
    ɵngcc0.ɵɵtemplate(3, AdvancedLegendComponent_div_7_div_3_Template, 2, 1, "div", 12);
    ɵngcc0.ɵɵelementStart(4, "div", 13);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, AdvancedLegendComponent_div_7_div_6_Template, 1, 2, "div", 14);
    ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_div_7_Template, 2, 1, "div", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("border-left-color", legendItem_r3.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(legendItem_r3.displayLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
} }
var _c3 = ["ngx-charts-axis-label", ""];
var _c4 = ["ticksel"];
var _c5 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.tickTransform(tick_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("text-anchor", ctx_r1.textAnchor)("transform", ctx_r1.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r3)), " ");
} }
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r5.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("y1", 0 - ctx_r5.gridLineHeight);
} }
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r2.tickTransform(tick_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showGridLines);
} }
var _c6 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("rotateTicks", ctx_r0.rotateTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.xScale)("orient", ctx_r0.xOrient)("showGridLines", ctx_r0.showGridLines)("gridLineHeight", ctx_r0.dims.height)("width", ctx_r0.dims.width)("tickValues", ctx_r0.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", "bottom")("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c7 = ["ngx-charts-y-axis-ticks", ""];
function YAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 5);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transform(tick_r5));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("dy", ctx_r1.dy)("x", ctx_r1.x1)("y", ctx_r1.y1)("text-anchor", ctx_r1.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r5)), " ");
} }
function YAxisTicksComponent__svg_path_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("d", ctx_r2.referenceAreaPath)("transform", ctx_r2.gridLineTransform());
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", ctx_r8.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", 0 - ctx_r9.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r7.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "left");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "right");
} }
function YAxisTicksComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1_Template, 3, 3, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r6 = ctx.$implicit;
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r3.transform(tick_r6));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showGridLines);
} }
function YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 11);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    var ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r12.tickTrim(ctx_r12.tickFormat(refLine_r10.value)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dy", ctx_r12.dy)("y", 0 - 6)("x", ctx_r12.gridLineWidth)("text-anchor", ctx_r12.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", refLine_r10.name, " ");
} }
function YAxisTicksComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 10);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template, 5, 6, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r11.transform(refLine_r10.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("x2", ctx_r11.gridLineWidth)("transform", ctx_r11.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r11.showRefLabels);
} }
function YAxisTicksComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_5__svg_g_1_Template, 3, 4, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showRefLines);
} }
var _c8 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function YAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickValues", ctx_r0.ticks)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.yScale)("orient", ctx_r0.yOrient)("showGridLines", ctx_r0.showGridLines)("gridLineWidth", ctx_r0.dims.width)("referenceLines", ctx_r0.referenceLines)("showRefLines", ctx_r0.showRefLines)("showRefLabels", ctx_r0.showRefLabels)("height", ctx_r0.dims.height);
} }
function YAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c9 = ["ngx-charts-circle-series", ""];
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 4);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
} }
var _c10 = function (a0) { return { name: a0 }; };
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "defs");
    ɵngcc0.ɵɵelement(2, "g", 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2);
    ɵngcc0.ɵɵelementStart(4, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CircleSeriesComponent__svg_g_0_Template__svg_g_select_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(ctx_r2.circle.data); })("activate", function CircleSeriesComponent__svg_g_0_Template__svg_g_activate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(); })("deactivate", function CircleSeriesComponent__svg_g_0_Template__svg_g_deactivate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.circle.gradientStops);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.barVisible && ctx_r0.type === "standard");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", ctx_r0.isActive(ɵngcc0.ɵɵpureFunction1(18, _c10, ctx_r0.circle.seriesName)));
    ɵngcc0.ɵɵproperty("cx", ctx_r0.circle.cx)("cy", ctx_r0.circle.cy)("r", ctx_r0.circle.radius)("fill", ctx_r0.circle.color)("pointerEvents", ctx_r0.circle.value === 0 ? "none" : "all")("data", ctx_r0.circle.value)("classNames", ctx_r0.circle.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(ctx_r0.circle))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ctx_r0.circle.data);
} }
var _c11 = ["ngx-charts-circle", ""];
var _c12 = ["ngx-charts-grid-panel", ""];
var _c13 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 1);
} if (rf & 2) {
    var gridPanel_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("grid-panel", true)("odd", gridPanel_r1.class === "odd")("even", gridPanel_r1.class === "even");
    ɵngcc0.ɵɵproperty("height", gridPanel_r1.height)("width", gridPanel_r1.width)("x", gridPanel_r1.x)("y", gridPanel_r1.y);
} }
var _c14 = ["ngx-charts-svg-linear-gradient", ""];
function SvgLinearGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c15 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c16 = ["ngx-charts-timeline", ""];
var _c17 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c18 = ["tooltipAnchor"];
var _c19 = ["ngx-charts-tooltip-area", ""];
function TooltipArea__xhtml_ng_template_2__xhtml_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelement(1, "span", 7);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tooltipItem_r5 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", tooltipItem_r5.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.getToolTipText(tooltipItem_r5), " ");
} }
function TooltipArea__xhtml_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, TooltipArea__xhtml_ng_template_2__xhtml_div_1_Template, 3, 3, "div", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var model_r3 = ctx.model;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", model_r3);
} }
var _c20 = ["ngx-charts-count-up", ""];
var _c21 = ["tooltipTemplate"];
var _c22 = ["seriesTooltipTemplate"];
function AreaChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("baseValue", ctx_r2.baseValue)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("baseValue", ctx_r19.baseValue)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
var _c23 = function (a0, a1) { return [a0, a1]; };
function AreaChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
function AreaChartNormalizedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("activeEntries", ctx_r2.activeEntries)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartNormalizedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("showPercentage", true)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartNormalizedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartNormalizedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
function AreaChartStackedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartStackedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartStackedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("activeEntries", ctx_r2.activeEntries)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartStackedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 12);
    ɵngcc0.ɵɵlistener("select", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartStackedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartStackedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartStackedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results)("ngForTrackBy", ctx_r3.trackBy);
} }
function AreaChartStackedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartStackedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 13);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartStackedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartStackedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c24 = ["ngx-charts-area-series", ""];
var _c25 = ["ngx-charts-bar", ""];
function BarComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("orientation", ctx_r0.orientation)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function BarHorizontalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.valueScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontal2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_dataLabelWidthChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.valueScale)("activeEntries", ctx_r2.activeEntries)("yScale", ctx_r2.innerScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_dataLabelWidthChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("series", group_r7.series)("activeEntries", ctx_r2.activeEntries)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.groupScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVertical2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarVertical2DComponent__svg_g_5_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVertical2DComponent__svg_g_5_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVertical2DComponent__svg_g_5_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_5_Template__svg_g_dataLabelHeightChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("activeEntries", ctx_r2.activeEntries)("xScale", ctx_r2.innerScale)("yScale", ctx_r2.valueScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
} }
function BarVerticalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_dataLabelHeightChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
var _c26 = ["ngx-charts-series-vertical", ""];
function SeriesVerticalComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesVerticalComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onClick($event); })("activate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx_r0.animations)("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "vertical")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("ariaLabel", bar_r2.ariaLabel)("isActive", ctx_r0.isActive(bar_r2.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero)("animations", ctx_r0.animations);
} }
function SeriesVerticalComponent__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = ctx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelHeightChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "vertical");
} }
function SeriesVerticalComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c27 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesHorizontal__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.click($event); })("activate", function SeriesHorizontal__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesHorizontal__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "horizontal")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("isActive", ctx_r0.isActive(bar_r2.data))("ariaLabel", bar_r2.ariaLabel)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero);
} }
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = ctx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelWidthChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "horizontal");
} }
function SeriesHorizontal__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c28 = ["ngx-charts-bar-label", ""];
function BubbleChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r0.showGridLines)("dims", ctx_r0.dims)("xScale", ctx_r0.xScale)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BubbleChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r1.showGridLines)("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BubbleChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BubbleChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var series_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, series_r7); })("activate", function BubbleChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event); })("deactivate", function BubbleChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("rScale", ctx_r2.rScale)("xScaleType", ctx_r2.xScaleType)("yScaleType", ctx_r2.yScaleType)("xAxisLabel", ctx_r2.xAxisLabel)("yAxisLabel", ctx_r2.yAxisLabel)("colors", ctx_r2.colors)("data", series_r7)("activeEntries", ctx_r2.activeEntries)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate);
} }
var _c29 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g");
    ɵngcc0.ɵɵelementStart(2, "g", 1);
    ɵngcc0.ɵɵlistener("select", function BubbleSeriesComponent__svg_g_0_Template__svg_g_select_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(circle_r1.data); })("activate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(circle_r1); })("deactivate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(circle_r1); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("transform", circle_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("opacity", circle_r1.opacity);
    ɵngcc0.ɵɵclassProp("active", circle_r1.isActive);
    ɵngcc0.ɵɵproperty("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r1.radius)("fill", circle_r1.color)("pointerEvents", "all")("data", circle_r1.value)("classNames", circle_r1.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(circle_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", circle_r1.data);
} }
var _c30 = ["linkTemplate"];
var _c31 = ["nodeTemplate"];
function ForceDirectedGraphComponent__svg_g_3_1__svg_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
} }
function ForceDirectedGraphComponent__svg_g_3_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵtemplate(0, ForceDirectedGraphComponent__svg_g_3_1__svg_ng_template_0_Template, 0, 0, "ng-template", 8);
} }
function ForceDirectedGraphComponent__svg_g_3__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var link_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵattribute("x1", link_r2.source.x)("y1", link_r2.source.y)("x2", link_r2.target.x)("y2", link_r2.target.y);
} }
function ForceDirectedGraphComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, ForceDirectedGraphComponent__svg_g_3_1_Template, 1, 0, undefined, 6);
    ɵngcc0.ɵɵtemplate(2, ForceDirectedGraphComponent__svg_g_3__svg_line_2_Template, 1, 4, "line", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.linkTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.linkTemplate);
} }
function ForceDirectedGraphComponent__svg_g_5_1__svg_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
} }
function ForceDirectedGraphComponent__svg_g_5_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵtemplate(0, ForceDirectedGraphComponent__svg_g_5_1__svg_ng_template_0_Template, 0, 0, "ng-template", 8);
} }
function ForceDirectedGraphComponent__svg_g_5__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 12);
} }
function ForceDirectedGraphComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mousedown", function ForceDirectedGraphComponent__svg_g_5_Template__svg_g_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); var node_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDragStart(node_r7, $event); })("click", function ForceDirectedGraphComponent__svg_g_5_Template__svg_g_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); var node_r7 = ctx.$implicit; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onClick({ name: node_r7.value }); });
    ɵngcc0.ɵɵtemplate(1, ForceDirectedGraphComponent__svg_g_5_1_Template, 1, 0, undefined, 6);
    ɵngcc0.ɵɵtemplate(2, ForceDirectedGraphComponent__svg_g_5__svg_circle_2_Template, 1, 0, "circle", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var node_r7 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : ctx_r1.escape(node_r7.value))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", node_r7);
    ɵngcc0.ɵɵattribute("transform", "translate(" + node_r7.x + "," + node_r7.y + ")")("fill", ctx_r1.colors.getColor(ctx_r1.groupResultsBy(node_r7)))("stroke", ctx_r1.colors.getColor(ctx_r1.groupResultsBy(node_r7)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.nodeTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.nodeTemplate);
} }
var _c32 = ["ngx-charts-heat-map-cell", ""];
function HeatMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c33 = ["ngx-charts-heat-map-cell-series", ""];
var _c34 = function (a0, a1, a2) { return { series: a0, name: a1, value: a2 }; };
function HeatCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(c_r1.cell); })("activate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_activate_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit(c_r1.cell); })("deactivate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_deactivate_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit(c_r1.cell); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("data", c_r1.data)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ɵngcc0.ɵɵpureFunction3(14, _c34, c_r1.series, c_r1.label, c_r1.data));
} }
function HeatMapComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function HeatMapComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function HeatMapComponent__svg_rect_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect");
} if (rf & 2) {
    var rect_r7 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("x", rect_r7.x)("y", rect_r7.y)("rx", rect_r7.rx)("width", rect_r7.width)("height", rect_r7.height)("fill", rect_r7.fill);
} }
var _c35 = ["ngx-charts-line", ""];
function LineChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function LineChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels);
} }
function LineChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("curve", ctx_r2.curve)("rangeFillOpacity", ctx_r2.rangeFillOpacity)("hasRange", ctx_r2.hasRange)("animations", ctx_r2.animations);
} }
function LineChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event); })("activate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("activeEntries", ctx_r10.activeEntries)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function LineChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function LineChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, LineChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function LineChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("curve", ctx_r19.curve)("hasRange", ctx_r19.hasRange)("animations", ctx_r19.animations);
} }
function LineChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function LineChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, LineChartComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("scaleType", ctx_r4.scaleType)("legend", ctx_r4.legend);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c36 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function LineSeriesComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 5);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r1.isActive(ctx_r1.data))("inactive", ctx_r1.isInactive(ctx_r1.data));
    ɵngcc0.ɵɵproperty("data", ctx_r1.data)("path", ctx_r1.outerPath)("fill", ctx_r1.hasGradient ? ctx_r1.gradientUrl : ctx_r1.colors.getColor(ctx_r1.data.name))("opacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations);
} }
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 8);
} if (rf & 2) {
    var r_r6 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("r", r_r6);
} }
function PolarChartComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.radiusTicks);
} }
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 10);
} if (rf & 2) {
    var tick_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("data", tick_r8)("radius", ctx_r7.outerRadius)("label", tick_r8.label)("max", ctx_r7.outerRadius)("value", ctx_r7.showGridLines ? 1 : ctx_r7.outerRadius)("explodeSlices", true)("animations", ctx_r7.animations)("labelTrim", ctx_r7.labelTrim)("labelTrimSize", ctx_r7.labelTrimSize);
} }
function PolarChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.thetaTicks);
} }
function PolarChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 11);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r2.yAxisScale)("dims", ctx_r2.yAxisDims)("showGridLines", ctx_r2.showGridLines)("showLabel", ctx_r2.showYAxisLabel)("labelText", ctx_r2.yAxisLabel)("trimTicks", ctx_r2.trimYAxisTicks)("maxTickLength", ctx_r2.maxYAxisTickLength)("tickFormatting", ctx_r2.yAxisTickFormatting);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.transformYAxis);
} }
function PolarChartComponent__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 12);
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r3.xAxisLabel)("offset", ctx_r3.labelOffset)("orient", "bottom")("height", ctx_r3.dims.height)("width", ctx_r3.dims.width);
} }
function PolarChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function PolarChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onClick($event); })("activate", function PolarChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onActivate($event); })("deactivate", function PolarChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("gradient", ctx_r4.gradient)("xScale", ctx_r4.xScale)("yScale", ctx_r4.yScale)("colors", ctx_r4.colors)("data", series_r11)("activeEntries", ctx_r4.activeEntries)("scaleType", ctx_r4.scaleType)("curve", ctx_r4.curve)("rangeFillOpacity", ctx_r4.rangeFillOpacity)("animations", ctx_r4.animations)("tooltipDisabled", ctx_r4.tooltipDisabled)("tooltipTemplate", ctx_r4.tooltipTemplate);
} }
var _c37 = ["ngx-charts-polar-series", ""];
function PolarSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r0.seriesColor)("name", ctx_r0.gradientId)("startOpacity", 0.25)("endOpacity", 1)("stops", ctx_r0.gradientStops);
} }
function PolarSeriesComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("select", function PolarSeriesComponent__svg_g_4_Template__svg_g_select_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.select.emit(circle_r2.data); })("activate", function PolarSeriesComponent__svg_g_4_Template__svg_g_activate_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit({ name: circle_r2.data.series }); })("deactivate", function PolarSeriesComponent__svg_g_4_Template__svg_g_deactivate_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit({ name: circle_r2.data.series }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("opacity", ctx_r1.inactive ? 0.2 : 1);
    ɵngcc0.ɵɵproperty("cx", circle_r2.cx)("cy", circle_r2.cy)("r", ctx_r1.circleRadius)("fill", circle_r2.color)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : ctx_r1.tooltipText(circle_r2))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", circle_r2.data);
} }
var _c38 = ["ngx-charts-pie-label", ""];
var _c39 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", ctx_r0.fill)("name", ctx_r0.radialGradientId)("startOpacity", ctx_r0.startOpacity);
} }
function PieGridComponent__svg_g_2__svg_text_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 10);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", series_r1.percent)("countSuffix", "%");
} }
function PieGridComponent__svg_g_2__svg_text_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.percent.toLocaleString(), " ");
} }
function PieGridComponent__svg_g_2__svg_text_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 12);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", series_r1.total)("countPrefix", ctx_r4.label + ": ");
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
} }
function PieGridComponent__svg_g_2__svg_text_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate2(" ", ctx_r5.label, ": ", series_r1.total.toLocaleString(), " ");
} }
var _c40 = function (a0) { return { data: a0 }; };
function PieGridComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "g", 4);
    ɵngcc0.ɵɵlistener("select", function PieGridComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onClick($event); })("activate", function PieGridComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onActivate($event); })("deactivate", function PieGridComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2__svg_text_2_Template, 1, 2, "text", 5);
    ɵngcc0.ɵɵtemplate(3, PieGridComponent__svg_g_2__svg_text_3_Template, 2, 1, "text", 6);
    ɵngcc0.ɵɵelementStart(4, "text", 7);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, PieGridComponent__svg_g_2__svg_text_6_Template, 1, 3, "text", 8);
    ɵngcc0.ɵɵtemplate(7, PieGridComponent__svg_g_2__svg_text_7_Template, 2, 3, "text", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", series_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("colors", series_r1.colors)("data", series_r1.data)("innerRadius", series_r1.innerRadius)("outerRadius", series_r1.outerRadius)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(ɵngcc0.ɵɵpureFunction1(17, _c40, series_r1)))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", series_r1.data[0].data);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.label, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
} }
var _c41 = ["ngx-charts-pie-grid-series", ""];
function PieGridSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieGridSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); })("activate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit($event); })("deactivate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("data", arc_r1.data)("gradient", false)("pointerEvents", arc_r1.pointerEvents)("animate", arc_r1.animate);
    ɵngcc0.ɵɵattribute("class", arc_r1.class);
} }
var _c42 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var arc_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", arc_r1)("radius", ctx_r2.outerRadius)("color", ctx_r2.color(arc_r1))("label", ctx_r2.labelText(arc_r1))("labelTrim", ctx_r2.trimLabels)("labelTrimSize", ctx_r2.maxLabelLength)("max", ctx_r2.max)("value", arc_r1.value)("explodeSlices", ctx_r2.explodeSlices)("animations", ctx_r2.animations);
} }
function PieSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    ɵngcc0.ɵɵelementStart(2, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieSeriesComponent__svg_g_0_Template__svg_g_select_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function PieSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.activate.emit($event); })("deactivate", function PieSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.deactivate.emit($event); })("dblclick", function PieSeriesComponent__svg_g_0_Template__svg_g_dblclick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.dblclick.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.labelVisible(arc_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("gradient", ctx_r0.gradient)("data", arc_r1.data)("max", ctx_r0.max)("explodeSlices", ctx_r0.explodeSlices)("isActive", ctx_r0.isActive(arc_r1.data))("animate", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.getTooltipTitle(arc_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", arc_r1.data);
} }
var _c43 = ["textEl"];
var _c44 = ["ngx-charts-card", ""];
function CardComponent__svg_path_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("fill", ctx_r0.bandColor)("transform", ctx_r0.transformBand)("d", ctx_r0.bandPath);
} }
var _c45 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 2);
} if (rf & 2) {
    var c_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r0.emptyColor);
    ɵngcc0.ɵɵattribute("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height);
} }
function CardSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CardSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("color", c_r3.color)("bandColor", c_r3.bandColor)("textColor", c_r3.textColor)("data", c_r3.data)("label", c_r3.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
} }
var _c46 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("countTo", ctx_r2.value)("valueFormatting", ctx_r2.valueFormatting);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.formattedValue, " ");
} }
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "foreignObject", 4);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵelement(2, "span", 5);
    ɵngcc0.ɵɵelement(3, "br");
    ɵngcc0.ɵɵtemplate(4, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template, 1, 2, "span", 6);
    ɵngcc0.ɵɵtemplate(5, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("pointer-events", "none");
    ɵngcc0.ɵɵattribute("x", ctx_r1.x)("y", ctx_r1.y)("width", ctx_r1.width)("height", ctx_r1.height);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("color", ctx_r1.getTextColor())("height", ctx_r1.height + "px")("width", ctx_r1.width + "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.animations);
} }
var _c47 = ["ngx-charts-tree-map-cell-series", ""];
function TreeMapCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function TreeMapCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", c_r1.data)("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("label", c_r1.label)("value", c_r1.value)("valueType", c_r1.valueType)("valueFormatting", ctx_r0.valueFormatting)("labelFormatting", ctx_r0.labelFormatting)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", c_r1.data);
} }
var _c48 = ["valueTextEl"];
var _c49 = ["unitsTextEl"];
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 10);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.transformLine)("stroke", ctx_r0.colors.getColor(ctx_r0.units));
} }
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 11);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
} }
var _c50 = function () { return {}; };
function GaugeComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 5);
    ɵngcc0.ɵɵlistener("select", function GaugeComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function GaugeComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onActivate($event); })("deactivate", function GaugeComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r3 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.rotation);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("backgroundArc", arc_r3.backgroundArc)("valueArc", arc_r3.valueArc)("cornerRadius", ctx_r0.cornerRadius)("colors", ctx_r0.colors)("isActive", ctx_r0.isActive(arc_r3.valueArc.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipTemplate", ctx_r0.tooltipTemplate)("valueFormatting", ctx_r0.valueFormatting)("animations", ctx_r0.animations);
} }
function GaugeComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 6);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("bigSegments", ctx_r1.bigSegments)("smallSegments", ctx_r1.smallSegments)("min", ctx_r1.min)("max", ctx_r1.max)("radius", ctx_r1.outerRadius)("angleSpan", ctx_r1.angleSpan)("valueScale", ctx_r1.valueScale)("startAngle", ctx_r1.startAngle)("tickFormatting", ctx_r1.axisTickFormatting);
} }
function GaugeComponent__svg_text_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 7, 8);
    ɵngcc0.ɵɵelementStart(2, "tspan", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "tspan", 10);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.textTransform);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.displayValue);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.units);
} }
var _c51 = ["ngx-charts-gauge-arc", ""];
var _c52 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r3.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r4.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r4.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r4.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r5.line);
} }
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

// The export is needed here to generate a valid polyfills.metadata.json file
function ngxChartsPolyfills() {
    // IE11 fix
    // Ref: https://github.com/swimlane/ngx-charts/issues/386
    if (typeof (SVGElement) !== 'undefined' && typeof SVGElement.prototype.contains === 'undefined') {
        SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
    }
}
ngxChartsPolyfills();

var PlacementTypes;
(function (PlacementTypes) {
    PlacementTypes[PlacementTypes["top"] = 'top'] = "top";
    PlacementTypes[PlacementTypes["bottom"] = 'bottom'] = "bottom";
    PlacementTypes[PlacementTypes["left"] = 'left'] = "left";
    PlacementTypes[PlacementTypes["right"] = 'right'] = "right";
})(PlacementTypes || (PlacementTypes = {}));

var caretOffset = 7;
function verticalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'top') {
        return elDimensions.top - caretOffset;
    }
    if (alignment === 'bottom') {
        return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
    }
    return undefined;
}
function horizontalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'left') {
        return elDimensions.left - caretOffset;
    }
    if (alignment === 'right') {
        return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
    }
    return undefined;
}
/**
 * Position helper for the popover directive.
 *
 * @export
 * @class PositionHelper
 */
var PositionHelper = /** @class */ (function () {
    function PositionHelper() {
    }
    /**
     * Calculate vertical alignment position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateVerticalAlignment = function (elDimensions, popoverDimensions, alignment) {
        var result = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.height > window.innerHeight) {
            result = window.innerHeight - popoverDimensions.height;
        }
        return result;
    };
    /**
     * Calculate vertical caret position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateVerticalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
        var result;
        if (alignment === 'top') {
            result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
        }
        if (alignment === 'bottom') {
            result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.height / 2 - caretDimensions.height / 2;
        }
        var popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.height > window.innerHeight) {
            result += (popoverPosition + popoverDimensions.height - window.innerHeight);
        }
        return result;
    };
    /**
     * Calculate horz alignment position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateHorizontalAlignment = function (elDimensions, popoverDimensions, alignment) {
        var result = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.width > window.innerWidth) {
            result = window.innerWidth - popoverDimensions.width;
        }
        return result;
    };
    /**
     * Calculate horz caret position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateHorizontalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
        var result;
        if (alignment === 'left') {
            result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
        }
        if (alignment === 'right') {
            result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.width / 2 - caretDimensions.width / 2;
        }
        var popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.width > window.innerWidth) {
            result += (popoverPosition + popoverDimensions.width - window.innerWidth);
        }
        return result;
    };
    /**
     * Checks if the element's position should be flipped
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} placement
     * @param {any} spacing
     * @returns {boolean}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.shouldFlip = function (elDimensions, popoverDimensions, placement, spacing) {
        var flip = false;
        if (placement === 'right') {
            if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
                flip = true;
            }
        }
        if (placement === 'left') {
            if (elDimensions.left - popoverDimensions.width - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'top') {
            if (elDimensions.top - popoverDimensions.height - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'bottom') {
            if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
                flip = true;
            }
        }
        return flip;
    };
    /**
     * Position caret
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.positionCaret = function (placement, elmDim, hostDim, caretDimensions, alignment) {
        var top = 0;
        var left = 0;
        if (placement === PlacementTypes.right) {
            left = -7;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.left) {
            left = elmDim.width;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.top) {
            top = elmDim.height;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.bottom) {
            top = -7;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        return { top: top, left: left };
    };
    /**
     * Position content
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} spacing
     * @param {any} alignment
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.positionContent = function (placement, elmDim, hostDim, spacing, alignment) {
        var top = 0;
        var left = 0;
        if (placement === PlacementTypes.right) {
            left = hostDim.left + hostDim.width + spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.left) {
            left = hostDim.left - elmDim.width - spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.top) {
            top = hostDim.top - elmDim.height - spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.bottom) {
            top = hostDim.top + hostDim.height + spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        return { top: top, left: left };
    };
    /**
     * Determine placement based on flip
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} spacing
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.determinePlacement = function (placement, elmDim, hostDim, spacing) {
        var shouldFlip = PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
        if (shouldFlip) {
            if (placement === PlacementTypes.right) {
                return PlacementTypes.left;
            }
            else if (placement === PlacementTypes.left) {
                return PlacementTypes.right;
            }
            else if (placement === PlacementTypes.top) {
                return PlacementTypes.bottom;
            }
            else if (placement === PlacementTypes.bottom) {
                return PlacementTypes.top;
            }
        }
        return placement;
    };
    return PositionHelper;
}());

var StyleTypes;
(function (StyleTypes) {
    StyleTypes[StyleTypes["popover"] = 'popover'] = "popover";
    StyleTypes[StyleTypes["tooltip"] = 'tooltip'] = "tooltip";
})(StyleTypes || (StyleTypes = {}));

var AlignmentTypes;
(function (AlignmentTypes) {
    AlignmentTypes[AlignmentTypes["left"] = 'left'] = "left";
    AlignmentTypes[AlignmentTypes["center"] = 'center'] = "center";
    AlignmentTypes[AlignmentTypes["right"] = 'right'] = "right";
})(AlignmentTypes || (AlignmentTypes = {}));

var ShowTypes;
(function (ShowTypes) {
    ShowTypes[ShowTypes["all"] = 'all'] = "all";
    ShowTypes[ShowTypes["focus"] = 'focus'] = "focus";
    ShowTypes[ShowTypes["mouseover"] = 'mouseover'] = "mouseover";
})(ShowTypes || (ShowTypes = {}));

/**
 * Injection service is a helper to append components
 * dynamically to a known location in the DOM, most
 * noteably for dialogs/tooltips appending to body.
 *
 * @export
 * @class InjectionService
 */
var InjectionService = /** @class */ (function () {
    function InjectionService(applicationRef, componentFactoryResolver, injector) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    InjectionService_1 = InjectionService;
    /**
     * Sets a default global root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param container
     */
    InjectionService.setGlobalRootViewContainer = function (container) {
        InjectionService_1.globalRootViewContainer = container;
    };
    /**
     * Gets the root view container to inject the component to.
     *
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getRootViewContainer = function () {
        var rootComponents = this.applicationRef.components;
        // fix cannot read length of undefined
        if (rootComponents) {
            if (rootComponents.length)
                return rootComponents[0];
        }
        if (this._container)
            return this._container;
        if (InjectionService_1.globalRootViewContainer)
            return InjectionService_1.globalRootViewContainer;
        throw new Error('View Container not found! ngUpgrade needs to manually set this via setRootViewContainer.');
    };
    /**
     * Overrides the default root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param {any} container
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.setRootViewContainer = function (container) {
        this._container = container;
    };
    /**
     * Gets the html element for a component ref.
     *
     * @param {ComponentRef<any>} componentRef
     * @returns {HTMLElement}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getComponentRootNode = function (componentRef) {
        // the top most component root node has no `hostView`
        if (!componentRef.hostView)
            return componentRef.element.nativeElement;
        return componentRef.hostView.rootNodes[0];
    };
    /**
     * Gets the root component container html element.
     *
     * @returns {HTMLElement}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getRootViewContainerNode = function () {
        return this.getComponentRootNode(this.getRootViewContainer());
    };
    /**
     * Projects the bindings onto the component
     *
     * @param {ComponentRef<any>} component
     * @param {*} options
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.projectComponentBindings = function (component, bindings) {
        if (bindings) {
            if (bindings.inputs !== undefined) {
                var bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
                for (var _i = 0, bindingKeys_1 = bindingKeys; _i < bindingKeys_1.length; _i++) {
                    var bindingName = bindingKeys_1[_i];
                    component.instance[bindingName] = bindings.inputs[bindingName];
                }
            }
            if (bindings.outputs !== undefined) {
                var eventKeys = Object.getOwnPropertyNames(bindings.outputs);
                for (var _a = 0, eventKeys_1 = eventKeys; _a < eventKeys_1.length; _a++) {
                    var eventName = eventKeys_1[_a];
                    component.instance[eventName] = bindings.outputs[eventName];
                }
            }
        }
        return component;
    };
    /**
     * Appends a component to a adjacent location
     *
     * @template T
     * @param {Type<T>} componentClass
     * @param {*} [options={}]
     * @param {Element} [location=this.getRootViewContainerNode()]
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.appendComponent = function (componentClass, bindings, location) {
        if (bindings === void 0) { bindings = {}; }
        if (location === void 0) { location = this.getRootViewContainerNode(); }
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(componentClass);
        var componentRef = componentFactory.create(this.injector);
        var appRef = this.applicationRef;
        var componentRootNode = this.getComponentRootNode(componentRef);
        // project the options passed to the component instance
        this.projectComponentBindings(componentRef, bindings);
        appRef.attachView(componentRef.hostView);
        componentRef.onDestroy(function () {
            appRef.detachView(componentRef.hostView);
        });
        // use the renderer to append the element for univseral support
        var renderer = componentRef.instance.renderer;
        renderer.appendChild(location, componentRootNode);
        return componentRef;
    };
    var InjectionService_1, _a, _b, _c;
    InjectionService.globalRootViewContainer = null;
    InjectionService = InjectionService_1 = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object, typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object, typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object])
    ], InjectionService);
InjectionService.ɵfac = function InjectionService_Factory(t) { return new (t || InjectionService)(ɵngcc0.ɵɵinject(typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object), ɵngcc0.ɵɵinject(typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object), ɵngcc0.ɵɵinject(typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object)); };
InjectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: InjectionService, factory: function (t) { return InjectionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InjectionService, [{
        type: Injectable
    }], function () { return [{ type: typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object }, { type: typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object }]; }, null); })();
    return InjectionService;
}());

var InjectionRegistery = /** @class */ (function () {
    function InjectionRegistery(injectionService) {
        this.injectionService = injectionService;
        this.defaults = {};
        this.components = new Map();
    }
    InjectionRegistery.prototype.getByType = function (type) {
        if (type === void 0) { type = this.type; }
        return this.components.get(type);
    };
    InjectionRegistery.prototype.create = function (bindings) {
        return this.createByType(this.type, bindings);
    };
    InjectionRegistery.prototype.createByType = function (type, bindings) {
        bindings = this.assignDefaults(bindings);
        var component = this.injectComponent(type, bindings);
        this.register(type, component);
        return component;
    };
    InjectionRegistery.prototype.destroy = function (instance) {
        var compsByType = this.components.get(instance.componentType);
        if (compsByType) {
            var idx = compsByType.indexOf(instance);
            if (idx > -1) {
                var component = compsByType[idx];
                component.destroy();
                compsByType.splice(idx, 1);
            }
        }
    };
    InjectionRegistery.prototype.destroyAll = function () {
        this.destroyByType(this.type);
    };
    InjectionRegistery.prototype.destroyByType = function (type) {
        var comps = this.components.get(type);
        if (comps) {
            for (var _i = 0, comps_1 = comps; _i < comps_1.length; _i++) {
                var comp = comps_1[_i];
                this.destroy(comp);
            }
        }
    };
    InjectionRegistery.prototype.assignDefaults = function (bindings) {
        var _a = this.defaults, inputs = _a.inputs, outputs = _a.outputs;
        if (!bindings.inputs && !bindings.outputs) {
            bindings = { inputs: bindings };
        }
        if (inputs) {
            bindings.inputs = Object.assign(inputs, bindings.inputs);
        }
        if (outputs) {
            bindings.outputs = Object.assign(outputs, bindings.outputs);
        }
        return bindings;
    };
    InjectionRegistery.prototype.injectComponent = function (type, bindings) {
        return this.injectionService.appendComponent(type, bindings);
    };
    InjectionRegistery.prototype.register = function (type, component) {
        if (!this.components.has(type)) {
            this.components.set(type, []);
        }
        var types = this.components.get(type);
        types.push(component);
    };
    return InjectionRegistery;
}());

/**
 * Throttle a function
 *
 * @export
 * @param {*}      func
 * @param {number} wait
 * @param {*}      [options]
 * @returns
 */
function throttle(func, wait, options) {
    options = options || {};
    var context;
    var args;
    var result;
    var timeout = null;
    var previous = 0;
    function later() {
        previous = options.leading === false ? 0 : +new Date();
        timeout = null;
        result = func.apply(context, args);
    }
    return function () {
        var now = +new Date();
        if (!previous && options.leading === false) {
            previous = now;
        }
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
}
/**
 * Throttle decorator
 *
 *  class MyClass {
 *    throttleable(10)
 *    myFn() { ... }
 *  }
 *
 * @export
 * @param {number} duration
 * @param {*} [options]
 * @returns
 */
function throttleable(duration, options) {
    return function innerDecorator(target, key, descriptor) {
        return {
            configurable: true,
            enumerable: descriptor.enumerable,
            get: function getter() {
                Object.defineProperty(this, key, {
                    configurable: true,
                    enumerable: descriptor.enumerable,
                    value: throttle(descriptor.value, duration, options)
                });
                return this[key];
            }
        };
    };
}

var TooltipContentComponent = /** @class */ (function () {
    function TooltipContentComponent(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    Object.defineProperty(TooltipContentComponent.prototype, "cssClasses", {
        get: function () {
            var clz = 'ngx-charts-tooltip-content';
            clz += " position-" + this.placement;
            clz += " type-" + this.type;
            clz += " " + this.cssClass;
            return clz;
        },
        enumerable: true,
        configurable: true
    });
    TooltipContentComponent.prototype.ngAfterViewInit = function () {
        setTimeout(this.position.bind(this));
    };
    TooltipContentComponent.prototype.position = function () {
        var _this = this;
        var nativeElm = this.element.nativeElement;
        var hostDim = this.host.nativeElement.getBoundingClientRect();
        if (!hostDim.height && !hostDim.width)
            return;
        var elmDim = nativeElm.getBoundingClientRect();
        this.checkFlip(hostDim, elmDim);
        this.positionContent(nativeElm, hostDim, elmDim);
        if (this.showCaret) {
            this.positionCaret(hostDim, elmDim);
        }
        setTimeout(function () { return _this.renderer.addClass(nativeElm, 'animate'); }, 1);
    };
    TooltipContentComponent.prototype.positionContent = function (nativeElm, hostDim, elmDim) {
        var _a = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment), top = _a.top, left = _a.left;
        this.renderer.setStyle(nativeElm, 'top', top + "px");
        this.renderer.setStyle(nativeElm, 'left', left + "px");
    };
    TooltipContentComponent.prototype.positionCaret = function (hostDim, elmDim) {
        var caretElm = this.caretElm.nativeElement;
        var caretDimensions = caretElm.getBoundingClientRect();
        var _a = PositionHelper.positionCaret(this.placement, elmDim, hostDim, caretDimensions, this.alignment), top = _a.top, left = _a.left;
        this.renderer.setStyle(caretElm, 'top', top + "px");
        this.renderer.setStyle(caretElm, 'left', left + "px");
    };
    TooltipContentComponent.prototype.checkFlip = function (hostDim, elmDim) {
        this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
    };
    TooltipContentComponent.prototype.onWindowResize = function () {
        this.position();
    };
    var _a, _b, _c, _d, _e;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "host", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipContentComponent.prototype, "showCaret", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof StyleTypes !== "undefined" && StyleTypes) === "function" ? _a : Object)
    ], TooltipContentComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof PlacementTypes !== "undefined" && PlacementTypes) === "function" ? _b : Object)
    ], TooltipContentComponent.prototype, "placement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_c = typeof AlignmentTypes !== "undefined" && AlignmentTypes) === "function" ? _c : Object)
    ], TooltipContentComponent.prototype, "alignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipContentComponent.prototype, "spacing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "cssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "template", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "context", void 0);
    __decorate([
        ViewChild('caretElm', { static: false }),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "caretElm", void 0);
    __decorate([
        HostBinding('class'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TooltipContentComponent.prototype, "cssClasses", null);
    __decorate([
        HostListener('window:resize'),
        throttleable(100),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipContentComponent.prototype, "onWindowResize", null);
    TooltipContentComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object, typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object])
    ], TooltipContentComponent);
TooltipContentComponent.ɵfac = function TooltipContentComponent_Factory(t) { return new (t || TooltipContentComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object)); };
TooltipContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipContentComponent, selectors: [["ngx-tooltip-content"]], viewQuery: function TooltipContentComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.caretElm = _t.first);
    } }, hostVars: 2, hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function TooltipContentComponent_resize_HostBindingHandler() { return ctx.onWindowResize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
    } }, inputs: { placement: "placement", host: "host", showCaret: "showCaret", type: "type", alignment: "alignment", spacing: "spacing", cssClass: "cssClass", title: "title", template: "template", context: "context" }, decls: 6, vars: 6, consts: [[3, "hidden"], ["caretElm", ""], [1, "tooltip-content"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]], template: function TooltipContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelement(1, "span", 0, 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵtemplate(4, TooltipContentComponent_span_4_Template, 2, 4, "span", 3);
        ɵngcc0.ɵɵtemplate(5, TooltipContentComponent_span_5_Template, 1, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("tooltip-caret position-", ctx.placement, "");
        ɵngcc0.ɵɵproperty("hidden", !ctx.showCaret);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px 5px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate3d(0,0,0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}"], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipContentComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tooltip-content',
                template: "\n    <div>\n      <span #caretElm [hidden]=\"!showCaret\" class=\"tooltip-caret position-{{ this.placement }}\"> </span>\n      <div class=\"tooltip-content\">\n        <span *ngIf=\"!title\">\n          <ng-template [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ model: context }\"> </ng-template>\n        </span>\n        <span *ngIf=\"title\" [innerHTML]=\"title\"> </span>\n      </div>\n    </div>\n  ",
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px 5px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate3d(0,0,0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}"]
            }]
    }], function () { return [{ type: typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object }, { type: typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], placement: [{
            type: Input
        }], onWindowResize: [{
            type: HostListener,
            args: ['window:resize']
        }], host: [{
            type: Input
        }], showCaret: [{
            type: Input
        }], type: [{
            type: Input
        }], alignment: [{
            type: Input
        }], spacing: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], title: [{
            type: Input
        }], template: [{
            type: Input
        }], context: [{
            type: Input
        }], caretElm: [{
            type: ViewChild,
            args: ['caretElm', { static: false }]
        }] }); })();
    return TooltipContentComponent;
}());

var TooltipService = /** @class */ (function (_super) {
    __extends(TooltipService, _super);
    function TooltipService(injectionService) {
        var _this = _super.call(this, injectionService) || this;
        _this.injectionService = injectionService;
        _this.type = TooltipContentComponent;
        return _this;
    }
    var _a;
    TooltipService = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object])
    ], TooltipService);
TooltipService.ɵfac = function TooltipService_Factory(t) { return new (t || TooltipService)(ɵngcc0.ɵɵinject(typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object)); };
TooltipService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipService, factory: function (t) { return TooltipService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipService, [{
        type: Injectable
    }], function () { return [{ type: typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object }]; }, null); })();
    return TooltipService;
}(InjectionRegistery));

var TooltipDirective = /** @class */ (function () {
    function TooltipDirective(tooltipService, viewContainerRef, renderer) {
        this.tooltipService = tooltipService;
        this.viewContainerRef = viewContainerRef;
        this.renderer = renderer;
        this.tooltipCssClass = '';
        this.tooltipTitle = '';
        this.tooltipAppendToBody = true;
        this.tooltipSpacing = 10;
        this.tooltipDisabled = false;
        this.tooltipShowCaret = true;
        this.tooltipPlacement = PlacementTypes.top;
        this.tooltipAlignment = AlignmentTypes.center;
        this.tooltipType = StyleTypes.popover;
        this.tooltipCloseOnClickOutside = true;
        this.tooltipCloseOnMouseLeave = true;
        this.tooltipHideTimeout = 300;
        this.tooltipShowTimeout = 100;
        this.tooltipShowEvent = ShowTypes.all;
        this.tooltipImmediateExit = false;
        this.show = new EventEmitter();
        this.hide = new EventEmitter();
    }
    Object.defineProperty(TooltipDirective.prototype, "listensForFocus", {
        get: function () {
            return this.tooltipShowEvent === ShowTypes.all ||
                this.tooltipShowEvent === ShowTypes.focus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "listensForHover", {
        get: function () {
            return this.tooltipShowEvent === ShowTypes.all ||
                this.tooltipShowEvent === ShowTypes.mouseover;
        },
        enumerable: true,
        configurable: true
    });
    TooltipDirective.prototype.ngOnDestroy = function () {
        this.hideTooltip(true);
    };
    TooltipDirective.prototype.onFocus = function () {
        if (this.listensForFocus) {
            this.showTooltip();
        }
    };
    TooltipDirective.prototype.onBlur = function () {
        if (this.listensForFocus) {
            this.hideTooltip(true);
        }
    };
    TooltipDirective.prototype.onMouseEnter = function () {
        if (this.listensForHover) {
            this.showTooltip();
        }
    };
    TooltipDirective.prototype.onMouseLeave = function (target) {
        if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
            clearTimeout(this.timeout);
            if (this.component) {
                var contentDom = this.component.instance.element.nativeElement;
                var contains = contentDom.contains(target);
                if (contains)
                    return;
            }
            this.hideTooltip(this.tooltipImmediateExit);
        }
    };
    TooltipDirective.prototype.onMouseClick = function () {
        if (this.listensForHover) {
            this.hideTooltip(true);
        }
    };
    TooltipDirective.prototype.showTooltip = function (immediate) {
        var _this = this;
        if (this.component || this.tooltipDisabled)
            return;
        var time = immediate ? 0 : this.tooltipShowTimeout;
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
            _this.tooltipService.destroyAll();
            var options = _this.createBoundOptions();
            _this.component = _this.tooltipService.create(options);
            // add a tiny timeout to avoid event re-triggers
            setTimeout(function () {
                if (_this.component) {
                    _this.addHideListeners(_this.component.instance.element.nativeElement);
                }
            }, 10);
            _this.show.emit(true);
        }, time);
    };
    TooltipDirective.prototype.addHideListeners = function (tooltip) {
        var _this = this;
        // on mouse enter, cancel the hide triggered by the leave
        this.mouseEnterContentEvent = this.renderer.listen(tooltip, 'mouseenter', function () {
            clearTimeout(_this.timeout);
        });
        // content mouse leave listener
        if (this.tooltipCloseOnMouseLeave) {
            this.mouseLeaveContentEvent = this.renderer.listen(tooltip, 'mouseleave', function () {
                _this.hideTooltip(_this.tooltipImmediateExit);
            });
        }
        // content close on click outside
        if (this.tooltipCloseOnClickOutside) {
            this.documentClickEvent = this.renderer.listen(document, 'click', function (event$$1) {
                var contains = tooltip.contains(event$$1.target);
                if (!contains)
                    _this.hideTooltip();
            });
        }
    };
    TooltipDirective.prototype.hideTooltip = function (immediate) {
        var _this = this;
        if (immediate === void 0) { immediate = false; }
        if (!this.component)
            return;
        var destroyFn = function () {
            // remove events
            if (_this.mouseLeaveContentEvent)
                _this.mouseLeaveContentEvent();
            if (_this.mouseEnterContentEvent)
                _this.mouseEnterContentEvent();
            if (_this.documentClickEvent)
                _this.documentClickEvent();
            // emit events
            _this.hide.emit(true);
            // destroy component
            _this.tooltipService.destroy(_this.component);
            _this.component = undefined;
        };
        clearTimeout(this.timeout);
        if (!immediate) {
            this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
        }
        else {
            destroyFn();
        }
    };
    TooltipDirective.prototype.createBoundOptions = function () {
        return {
            title: this.tooltipTitle,
            template: this.tooltipTemplate,
            host: this.viewContainerRef.element,
            placement: this.tooltipPlacement,
            alignment: this.tooltipAlignment,
            type: this.tooltipType,
            showCaret: this.tooltipShowCaret,
            cssClass: this.tooltipCssClass,
            spacing: this.tooltipSpacing,
            context: this.tooltipContext
        };
    };
    var _a, _b, _c, _d, _e, _f, _g;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipCssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipAppendToBody", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipSpacing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipShowCaret", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof PlacementTypes !== "undefined" && PlacementTypes) === "function" ? _a : Object)
    ], TooltipDirective.prototype, "tooltipPlacement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof AlignmentTypes !== "undefined" && AlignmentTypes) === "function" ? _b : Object)
    ], TooltipDirective.prototype, "tooltipAlignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_c = typeof StyleTypes !== "undefined" && StyleTypes) === "function" ? _c : Object)
    ], TooltipDirective.prototype, "tooltipType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipCloseOnClickOutside", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipCloseOnMouseLeave", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipHideTimeout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipShowTimeout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_d = typeof ShowTypes !== "undefined" && ShowTypes) === "function" ? _d : Object)
    ], TooltipDirective.prototype, "tooltipShowEvent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltipContext", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipImmediateExit", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "show", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "hide", void 0);
    __decorate([
        HostListener('focusin'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onFocus", null);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onBlur", null);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseLeave", null);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseClick", null);
    TooltipDirective = __decorate([ __metadata("design:paramtypes", [typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object, typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object, typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object])
    ], TooltipDirective);
TooltipDirective.ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object)); };
TooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "ngx-tooltip", ""]], hostBindings: function TooltipDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function TooltipDirective_focusin_HostBindingHandler() { return ctx.onFocus(); })("blur", function TooltipDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event.target); })("click", function TooltipDirective_click_HostBindingHandler() { return ctx.onMouseClick(); });
    } }, inputs: { tooltipCssClass: "tooltipCssClass", tooltipTitle: "tooltipTitle", tooltipAppendToBody: "tooltipAppendToBody", tooltipSpacing: "tooltipSpacing", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipPlacement: "tooltipPlacement", tooltipAlignment: "tooltipAlignment", tooltipType: "tooltipType", tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside", tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave", tooltipHideTimeout: "tooltipHideTimeout", tooltipShowTimeout: "tooltipShowTimeout", tooltipShowEvent: "tooltipShowEvent", tooltipImmediateExit: "tooltipImmediateExit", tooltipTemplate: "tooltipTemplate", tooltipContext: "tooltipContext" }, outputs: { show: "show", hide: "hide" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipDirective, [{
        type: Directive,
        args: [{ selector: '[ngx-tooltip]' }]
    }], function () { return [{ type: typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object }, { type: typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object }, { type: typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object }]; }, { tooltipCssClass: [{
            type: Input
        }], tooltipTitle: [{
            type: Input
        }], tooltipAppendToBody: [{
            type: Input
        }], tooltipSpacing: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipShowCaret: [{
            type: Input
        }], tooltipPlacement: [{
            type: Input
        }], tooltipAlignment: [{
            type: Input
        }], tooltipType: [{
            type: Input
        }], tooltipCloseOnClickOutside: [{
            type: Input
        }], tooltipCloseOnMouseLeave: [{
            type: Input
        }], tooltipHideTimeout: [{
            type: Input
        }], tooltipShowTimeout: [{
            type: Input
        }], tooltipShowEvent: [{
            type: Input
        }], tooltipImmediateExit: [{
            type: Input
        }], show: [{
            type: Output
        }], hide: [{
            type: Output
        }], onFocus: [{
            type: HostListener,
            args: ['focusin']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave', ['$event.target']]
        }], onMouseClick: [{
            type: HostListener,
            args: ['click']
        }], tooltipTemplate: [{
            type: Input
        }], tooltipContext: [{
            type: Input
        }] }); })();
    return TooltipDirective;
}());

var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
TooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TooltipModule });
TooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TooltipModule_Factory(t) { return new (t || TooltipModule)(); }, providers: [InjectionService, TooltipService], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TooltipModule, { declarations: function () { return [TooltipContentComponent,
        TooltipDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TooltipContentComponent,
        TooltipDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [TooltipContentComponent, TooltipDirective],
                providers: [InjectionService, TooltipService],
                exports: [TooltipContentComponent, TooltipDirective],
                imports: [CommonModule],
                entryComponents: [TooltipContentComponent]
            }]
    }], function () { return []; }, null); })();
    return TooltipModule;
}());

var ChartComponent = /** @class */ (function () {
    function ChartComponent(vcr, tooltipService) {
        this.vcr = vcr;
        this.tooltipService = tooltipService;
        this.showLegend = false;
        this.animations = true;
        this.legendLabelClick = new EventEmitter();
        this.legendLabelActivate = new EventEmitter();
        this.legendLabelDeactivate = new EventEmitter();
        this.tooltipService.injectionService.setRootViewContainer(this.vcr);
    }
    ChartComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    ChartComponent.prototype.update = function () {
        var legendColumns = 0;
        if (this.showLegend) {
            this.legendType = this.getLegendType();
            if (!this.legendOptions || this.legendOptions.position === 'right') {
                if (this.legendType === 'scaleLegend') {
                    legendColumns = 1;
                }
                else {
                    legendColumns = 2;
                }
            }
        }
        var chartColumns = 12 - legendColumns;
        this.chartWidth = Math.floor((this.view[0] * chartColumns / 12.0));
        this.legendWidth = (!this.legendOptions || this.legendOptions.position === 'right')
            ? Math.floor((this.view[0] * legendColumns / 12.0))
            : this.chartWidth;
    };
    ChartComponent.prototype.getLegendType = function () {
        if (this.legendOptions.scaleType === 'linear') {
            return 'scaleLegend';
        }
        else {
            return 'legend';
        }
    };
    var _a, _b, _c, _d, _e;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "showLegend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendOptions", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendData", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ChartComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], ChartComponent.prototype, "legendLabelClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], ChartComponent.prototype, "legendLabelActivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], ChartComponent.prototype, "legendLabelDeactivate", void 0);
    ChartComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object, typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object])
    ], ChartComponent);
ChartComponent.ɵfac = function ChartComponent_Factory(t) { return new (t || ChartComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object)); };
ChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartComponent, selectors: [["ngx-charts-chart"]], inputs: { showLegend: "showLegend", animations: "animations", legendType: "legendType", view: "view", legendOptions: "legendOptions", data: "data", legendData: "legendData", colors: "colors", activeEntries: "activeEntries" }, outputs: { legendLabelClick: "legendLabelClick", legendLabelActivate: "legendLabelActivate", legendLabelDeactivate: "legendLabelDeactivate" }, features: [ɵngcc0.ɵɵProvidersFeature([TooltipService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 5, vars: 8, consts: [[1, "ngx-charts-outer"], [1, "ngx-charts"], ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"], ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"], [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"], [1, "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate"]], template: function ChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ChartComponent_ngx_charts_scale_legend_3_Template, 1, 5, "ngx-charts-scale-legend", 2);
        ɵngcc0.ɵɵtemplate(4, ChartComponent_ngx_charts_legend_4_Template, 1, 7, "ngx-charts-legend", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.view[0], "px");
        ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.chartWidth)("height", ctx.view[1]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "scaleLegend");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "legend");
    } }, directives: function () { return [ɵngcc1.NgIf, ScaleLegendComponent,
        LegendComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({ opacity: 0 }),
                    animate('500ms 100ms', style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartComponent, [{
        type: Component,
        args: [{
                providers: [TooltipService],
                selector: 'ngx-charts-chart',
                template: "\n    <div\n      class=\"ngx-charts-outer\"\n      [style.width.px]=\"view[0]\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\">\n      <svg\n        class=\"ngx-charts\"\n        [attr.width]=\"chartWidth\"\n        [attr.height]=\"view[1]\">\n        <ng-content></ng-content>\n      </svg>\n      <ngx-charts-scale-legend\n        *ngIf=\"showLegend && legendType === 'scaleLegend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [valueRange]=\"legendOptions.domain\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\">\n      </ngx-charts-scale-legend>\n      <ngx-charts-legend\n        *ngIf=\"showLegend && legendType === 'legend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [data]=\"legendOptions.domain\"\n        [title]=\"legendOptions.title\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\"\n        [activeEntries]=\"activeEntries\"\n        (labelClick)=\"legendLabelClick.emit($event)\"\n        (labelActivate)=\"legendLabelActivate.emit($event)\"\n        (labelDeactivate)=\"legendLabelDeactivate.emit($event)\">\n      </ngx-charts-legend>\n    </div>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({ opacity: 0 }),
                            animate('500ms 100ms', style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object }, { type: typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object }]; }, { showLegend: [{
            type: Input
        }], animations: [{
            type: Input
        }], legendLabelClick: [{
            type: Output
        }], legendLabelActivate: [{
            type: Output
        }], legendLabelDeactivate: [{
            type: Output
        }], legendType: [{
            type: Input
        }], view: [{
            type: Input
        }], legendOptions: [{
            type: Input
        }], data: [{
            type: Input
        }], legendData: [{
            type: Input
        }], colors: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return ChartComponent;
}());

/**
 * Formats a label given a date, number or string.
 *
 * @export
 * @param {*} label
 * @returns {string}
 */
function formatLabel(label) {
    if (label instanceof Date) {
        label = label.toLocaleDateString();
    }
    else {
        label = label.toLocaleString();
    }
    return label;
}
/**
 * Escapes a label.
 *
 * @export
 * @param {*} label
 * @returns {string}
 */
function escapeLabel(label) {
    return label.toLocaleString().replace(/[&'`"<>]/g, function (match) {
        return {
            '&': '&amp;',
            '\'': '&#x27;',
            '`': '&#x60;',
            '"': '&quot;',
            '<': '&lt;',
            '>': '&gt;',
        }[match];
    });
}

var LegendComponent = /** @class */ (function () {
    function LegendComponent(cd) {
        this.cd = cd;
        this.horizontal = false;
        this.labelClick = new EventEmitter();
        this.labelActivate = new EventEmitter();
        this.labelDeactivate = new EventEmitter();
        this.legendEntries = [];
    }
    LegendComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LegendComponent.prototype.update = function () {
        this.cd.markForCheck();
        this.legendEntries = this.getLegendEntries();
    };
    LegendComponent.prototype.getLegendEntries = function () {
        var items = [];
        var _loop_1 = function (label) {
            var formattedLabel = formatLabel(label);
            var idx = items.findIndex(function (i) {
                return i.label === formattedLabel;
            });
            if (idx === -1) {
                items.push({
                    label: label,
                    formattedLabel: formattedLabel,
                    color: this_1.colors.getColor(label)
                });
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var label = _a[_i];
            _loop_1(label);
        }
        return items;
    };
    LegendComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.label === d.name;
        });
        return item !== undefined;
    };
    LegendComponent.prototype.activate = function (item) {
        this.labelActivate.emit(item);
    };
    LegendComponent.prototype.deactivate = function (item) {
        this.labelDeactivate.emit(item);
    };
    LegendComponent.prototype.trackBy = function (index, item) {
        return item.label;
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "horizontal", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LegendComponent.prototype, "labelClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LegendComponent.prototype, "labelActivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], LegendComponent.prototype, "labelDeactivate", void 0);
    LegendComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object])
    ], LegendComponent);
LegendComponent.ɵfac = function LegendComponent_Factory(t) { return new (t || LegendComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object)); };
LegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendComponent, selectors: [["ngx-charts-legend"]], inputs: { horizontal: "horizontal", data: "data", title: "title", colors: "colors", height: "height", width: "width", activeEntries: "activeEntries" }, outputs: { labelClick: "labelClick", labelActivate: "labelActivate", labelDeactivate: "labelDeactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 9, consts: [["class", "legend-title", 4, "ngIf"], [1, "legend-wrap"], [1, "legend-labels"], ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "legend-title"], [1, "legend-title-text"], [1, "legend-label"], [3, "label", "formattedLabel", "color", "isActive", "select", "activate", "deactivate"]], template: function LegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtemplate(1, LegendComponent_header_1_Template, 3, 1, "header", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "ul", 2);
        ɵngcc0.ɵɵtemplate(4, LegendComponent_li_4_Template, 2, 4, "li", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.title == null ? null : ctx.title.length) > 0);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.height - 45, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendEntries)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, LegendEntryComponent]; }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend li,.chart-legend ul{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-legend',
                template: "\n    <div [style.width.px]=\"width\">\n      <header class=\"legend-title\" *ngIf=\"title?.length > 0\">\n        <span class=\"legend-title-text\">{{title}}</span>\n      </header>\n      <div class=\"legend-wrap\">\n        <ul class=\"legend-labels\"\n            [class.horizontal-legend]=\"horizontal\"\n          [style.max-height.px]=\"height - 45\">\n          <li\n            *ngFor=\"let entry of legendEntries; trackBy: trackBy\"\n            class=\"legend-label\">\n            <ngx-charts-legend-entry\n              [label]=\"entry.label\"\n              [formattedLabel]=\"entry.formattedLabel\"\n              [color]=\"entry.color\"\n              [isActive]=\"isActive(entry)\"\n              (select)=\"labelClick.emit($event)\"\n              (activate)=\"activate($event)\"\n              (deactivate)=\"deactivate($event)\">\n            </ngx-charts-legend-entry>\n          </li>\n        </ul>\n      </div>\n    </div>\n  ",
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend li,.chart-legend ul{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object }]; }, { horizontal: [{
            type: Input
        }], labelClick: [{
            type: Output
        }], labelActivate: [{
            type: Output
        }], labelDeactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], title: [{
            type: Input
        }], colors: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return LegendComponent;
}());

var ScaleLegendComponent = /** @class */ (function () {
    function ScaleLegendComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.horizontal = false;
    }
    ScaleLegendComponent.prototype.ngOnChanges = function (changes) {
        var gradientValues = this.gradientString(this.colors.range(), this.colors.domain());
        var direction = (this.horizontal) ? 'right' : 'bottom';
        this.gradient = this.sanitizer.bypassSecurityTrustStyle("linear-gradient(to " + direction + ", " + gradientValues + ")");
    };
    ScaleLegendComponent.prototype.gradientString = function (colors, splits) {
        splits.push(1);
        var pairs = [];
        colors.reverse().forEach(function (c, i) {
            pairs.push(c + " " + Math.round(splits[i] * 100) + "%");
        });
        return pairs.join(', ');
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "valueRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "horizontal", void 0);
    ScaleLegendComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object])
    ], ScaleLegendComponent);
ScaleLegendComponent.ɵfac = function ScaleLegendComponent_Factory(t) { return new (t || ScaleLegendComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object)); };
ScaleLegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ScaleLegendComponent, selectors: [["ngx-charts-scale-legend"]], inputs: { horizontal: "horizontal", valueRange: "valueRange", colors: "colors", height: "height", width: "width" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 10, consts: [[1, "scale-legend"], [1, "scale-legend-label"], [1, "scale-legend-wrap"]], template: function ScaleLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "span");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "div", 1);
        ɵngcc0.ɵɵelementStart(6, "span");
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.horizontal ? undefined : ctx.height, "px")("width", ctx.width, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[1].toLocaleString());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background", ctx.gradient, ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[0].toLocaleString());
    } }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScaleLegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-scale-legend',
                template: "\n    <div\n      class=\"scale-legend\"\n      [class.horizontal-legend]=\"horizontal\"\n      [style.height.px]=\"horizontal ? undefined : height\"\n      [style.width.px]=\"width\">\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[1].toLocaleString() }}</span>\n      </div>\n      <div\n        class=\"scale-legend-wrap\"\n        [style.background]=\"gradient\">\n      </div>\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[0].toLocaleString() }}</span>\n      </div>\n    </div>\n  ",
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object }]; }, { horizontal: [{
            type: Input
        }], valueRange: [{
            type: Input
        }], colors: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }] }); })();
    return ScaleLegendComponent;
}());

var LegendEntryComponent = /** @class */ (function () {
    function LegendEntryComponent() {
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.toggle = new EventEmitter();
    }
    Object.defineProperty(LegendEntryComponent.prototype, "trimmedLabel", {
        get: function () {
            return this.formattedLabel || '(empty)';
        },
        enumerable: true,
        configurable: true
    });
    LegendEntryComponent.prototype.onMouseEnter = function () {
        this.activate.emit({ name: this.label });
    };
    LegendEntryComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit({ name: this.label });
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LegendEntryComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendEntryComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LegendEntryComponent.prototype, "formattedLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LegendEntryComponent.prototype, "isActive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LegendEntryComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LegendEntryComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], LegendEntryComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_d = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _d : Object)
    ], LegendEntryComponent.prototype, "toggle", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LegendEntryComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LegendEntryComponent.prototype, "onMouseLeave", null);
LegendEntryComponent.ɵfac = function LegendEntryComponent_Factory(t) { return new (t || LegendEntryComponent)(); };
LegendEntryComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendEntryComponent, selectors: [["ngx-charts-legend-entry"]], hostBindings: function LegendEntryComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function LegendEntryComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function LegendEntryComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { isActive: "isActive", color: "color", label: "label", formattedLabel: "formattedLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", toggle: "toggle" }, decls: 4, vars: 6, consts: [["tabindex", "-1", 3, "title", "click"], [1, "legend-label-color", 3, "click"], [1, "legend-label-text"]], template: function LegendEntryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_0_listener() { return ctx.select.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_1_listener() { return ctx.toggle.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵproperty("title", ctx.formattedLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.trimmedLabel, " ");
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LegendEntryComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-legend-entry',
                template: "\n    <span \n      [title]=\"formattedLabel\"\n      tabindex=\"-1\"\n      [class.active]=\"isActive\"\n      (click)=\"select.emit(formattedLabel)\">\n      <span\n        class=\"legend-label-color\"\n        [style.background-color]=\"color\"\n        (click)=\"toggle.emit(formattedLabel)\">\n      </span>\n      <span class=\"legend-label-text\">\n        {{trimmedLabel}}\n      </span>\n    </span>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], toggle: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], color: [{
            type: Input
        }], label: [{
            type: Input
        }], formattedLabel: [{
            type: Input
        }] }); })();
    return LegendEntryComponent;
}());

function trimLabel(s, max$$1) {
    if (max$$1 === void 0) { max$$1 = 16; }
    if (typeof s !== 'string') {
        if (typeof s === 'number') {
            return s + '';
        }
        else {
            return '';
        }
    }
    s = s.trim();
    if (s.length <= max$$1) {
        return s;
    }
    else {
        return s.slice(0, max$$1) + "...";
    }
}

var AdvancedLegendComponent = /** @class */ (function () {
    function AdvancedLegendComponent() {
        this.label = 'Total';
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.legendItems = [];
        this.labelFormatting = function (label) { return label; };
        this.percentageFormatting = function (percentage) { return percentage; };
        this.defaultValueFormatting = function (value) { return value.toLocaleString(); };
    }
    AdvancedLegendComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AdvancedLegendComponent.prototype.getTotal = function () {
        return this.data.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
    };
    AdvancedLegendComponent.prototype.update = function () {
        this.total = this.getTotal();
        this.roundedTotal = this.total;
        this.legendItems = this.getLegendItems();
    };
    AdvancedLegendComponent.prototype.getLegendItems = function () {
        var _this = this;
        return this.data.map(function (d) {
            var label = formatLabel(d.name);
            var value = d.value;
            var color = _this.colors.getColor(label);
            var percentage = _this.total > 0 ? (value / _this.total) * 100 : 0;
            var formattedLabel = typeof _this.labelFormatting === 'function' ? _this.labelFormatting(label) : label;
            return {
                _value: value,
                data: d,
                value: value,
                color: color,
                label: formattedLabel,
                displayLabel: trimLabel(formattedLabel, 20),
                origialLabel: d.name,
                percentage: _this.percentageFormatting ? _this.percentageFormatting(percentage) : percentage.toLocaleString()
            };
        });
    };
    AdvancedLegendComponent.prototype.trackBy = function (item) {
        return item.formattedLabel;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AdvancedLegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedLegendComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedLegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AdvancedLegendComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedLegendComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AdvancedLegendComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AdvancedLegendComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], AdvancedLegendComponent.prototype, "deactivate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "percentageFormatting", void 0);
AdvancedLegendComponent.ɵfac = function AdvancedLegendComponent_Factory(t) { return new (t || AdvancedLegendComponent)(); };
AdvancedLegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AdvancedLegendComponent, selectors: [["ngx-charts-advanced-legend"]], inputs: { label: "label", animations: "animations", labelFormatting: "labelFormatting", percentageFormatting: "percentageFormatting", width: "width", data: "data", colors: "colors", valueFormatting: "valueFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 7, consts: [[1, "advanced-pie-legend"], ["class", "total-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "total-value", 4, "ngIf"], [1, "total-label"], [1, "legend-items-container"], [1, "legend-items"], ["tabindex", "-1", "class", "legend-item", 3, "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-count-up", "", 1, "total-value", 3, "countTo", "valueFormatting"], [1, "total-value"], ["tabindex", "-1", 1, "legend-item", 3, "mouseenter", "mouseleave", "click"], [1, "item-color"], ["class", "item-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "item-value", 4, "ngIf"], [1, "item-label"], ["class", "item-percent", "ngx-charts-count-up", "", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "item-percent", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "item-value", 3, "countTo", "valueFormatting"], [1, "item-value"], ["ngx-charts-count-up", "", 1, "item-percent", 3, "countTo", "countSuffix"], [1, "item-percent"]], template: function AdvancedLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, AdvancedLegendComponent_div_1_Template, 1, 2, "div", 1);
        ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_2_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_Template, 8, 7, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendItems)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, CountUpDirective]; }, styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translate(0,-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:0}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AdvancedLegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-advanced-legend',
                template: "\n    <div class=\"advanced-pie-legend\" [style.width.px]=\"width\">\n      <div\n        *ngIf=\"animations\"\n        class=\"total-value\"\n        ngx-charts-count-up\n        [countTo]=\"roundedTotal\"\n        [valueFormatting]=\"valueFormatting\"\n      ></div>\n      <div class=\"total-value\" *ngIf=\"!animations\">\n        {{ valueFormatting ? valueFormatting(roundedTotal) : defaultValueFormatting(roundedTotal) }}\n      </div>\n      <div class=\"total-label\">\n        {{ label }}\n      </div>\n      <div class=\"legend-items-container\">\n        <div class=\"legend-items\">\n          <div\n            *ngFor=\"let legendItem of legendItems; trackBy: trackBy\"\n            tabindex=\"-1\"\n            class=\"legend-item\"\n            (mouseenter)=\"activate.emit(legendItem.data)\"\n            (mouseleave)=\"deactivate.emit(legendItem.data)\"\n            (click)=\"select.emit(legendItem.data)\"\n          >\n            <div class=\"item-color\" [style.border-left-color]=\"legendItem.color\"></div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-value\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem._value\"\n              [valueFormatting]=\"valueFormatting\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-value\">\n              {{ valueFormatting ? valueFormatting(legendItem.value) : defaultValueFormatting(legendItem.value) }}\n            </div>\n            <div class=\"item-label\">{{ legendItem.displayLabel }}</div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-percent\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem.percentage\"\n              [countSuffix]=\"'%'\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-percent\">{{ legendItem.percentage.toLocaleString() }}%</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  ",
                styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translate(0,-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:0}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { label: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], labelFormatting: [{
            type: Input
        }], percentageFormatting: [{
            type: Input
        }], width: [{
            type: Input
        }], data: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }] }); })();
    return AdvancedLegendComponent;
}());

var cache = {};
/**
 * Generates a short id.
 *
 * Description:
 *   A 4-character alphanumeric sequence (364 = 1.6 million)
 *   This should only be used for JavaScript specific models.
 *   http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js
 *
 *   Example: `ebgf`
 */
function id() {
    var newId = ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
    // append a 'a' because neo gets mad
    newId = "a" + newId;
    // ensure not already used
    if (!cache[newId]) {
        cache[newId] = true;
        return newId;
    }
    return id();
}

var colorSets = [
    {
        name: 'vivid',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#647c8a', '#3f51b5', '#2196f3', '#00b862', '#afdf0a', '#a7b61a', '#f3e562', '#ff9800', '#ff5722', '#ff4514'
        ]
    },
    {
        name: 'natural',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#bf9d76', '#e99450', '#d89f59', '#f2dfa7', '#a5d7c6', '#7794b1', '#afafaf', '#707160', '#ba9383', '#d9d5c3'
        ]
    },
    {
        name: 'cool',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#a8385d', '#7aa3e5', '#a27ea8', '#aae3f5', '#adcded', '#a95963', '#8796c0', '#7ed3ed', '#50abcc', '#ad6886'
        ]
    },
    {
        name: 'fire',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#ff3d00', '#bf360c', '#ff8f00', '#ff6f00', '#ff5722', '#e65100', '#ffca28', '#ffab00'
        ]
    },
    {
        name: 'solar',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#fff8e1', '#ffecb3', '#ffe082', '#ffd54f', '#ffca28', '#ffc107', '#ffb300', '#ffa000', '#ff8f00', '#ff6f00'
        ]
    },
    {
        name: 'air',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#e1f5fe', '#b3e5fc', '#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#039be5', '#0288d1', '#0277bd', '#01579b'
        ]
    },
    {
        name: 'aqua',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#e0f7fa', '#b2ebf2', '#80deea', '#4dd0e1', '#26c6da', '#00bcd4', '#00acc1', '#0097a7', '#00838f', '#006064'
        ]
    },
    {
        name: 'flame',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#A10A28', '#D3342D', '#EF6D49', '#FAAD67', '#FDDE90', '#DBED91', '#A9D770', '#6CBA67', '#2C9653', '#146738'
        ]
    },
    {
        name: 'ocean',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#1D68FB', '#33C0FC', '#4AFFFE', '#AFFFFF', '#FFFC63', '#FDBD2D', '#FC8A25', '#FA4F1E', '#FA141B', '#BA38D1'
        ]
    },
    {
        name: 'forest',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#55C22D', '#C1F33D', '#3CC099', '#AFFFFF', '#8CFC9D', '#76CFFA', '#BA60FB', '#EE6490', '#C42A1C', '#FC9F32'
        ]
    },
    {
        name: 'horizon',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#2597FB', '#65EBFD', '#99FDD0', '#FCEE4B', '#FEFCFA', '#FDD6E3', '#FCB1A8', '#EF6F7B', '#CB96E8', '#EFDEE0'
        ]
    },
    {
        name: 'neons',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#FF3333', '#FF33FF', '#CC33FF', '#0000FF', '#33CCFF', '#33FFFF', '#33FF66', '#CCFF33', '#FFCC00', '#FF6600'
        ]
    },
    {
        name: 'picnic',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#FAC51D', '#66BD6D', '#FAA026', '#29BB9C', '#E96B56', '#55ACD2', '#B7332F', '#2C83C9', '#9166B8', '#92E7E8'
        ]
    },
    {
        name: 'night',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#2B1B5A', '#501356', '#183356', '#28203F', '#391B3C', '#1E2B3C', '#120634',
            '#2D0432', '#051932', '#453080', '#75267D', '#2C507D', '#4B3880', '#752F7D', '#35547D'
        ]
    },
    {
        name: 'nightLights',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#4e31a5', '#9c25a7', '#3065ab', '#57468b', '#904497', '#46648b',
            '#32118d', '#a00fb3', '#1052a2', '#6e51bd', '#b63cc3', '#6c97cb', '#8671c1', '#b455be', '#7496c3'
        ]
    }
];

function sortLinear(data, property, direction) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        if (direction === 'asc') {
            return a[property] - b[property];
        }
        else {
            return b[property] - a[property];
        }
    });
}
function sortByDomain(data, property, direction, domain) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        var aVal = a[property];
        var bVal = b[property];
        var aIdx = domain.indexOf(aVal);
        var bIdx = domain.indexOf(bVal);
        if (direction === 'asc') {
            return aIdx - bIdx;
        }
        else {
            return bIdx - aIdx;
        }
    });
}
function sortByTime(data, property, direction) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        var aDate = a[property].getTime();
        var bDate = b[property].getTime();
        if (direction === 'asc') {
            if (aDate > bDate)
                return 1;
            if (bDate > aDate)
                return -1;
            return 0;
        }
        else {
            if (aDate > bDate)
                return -1;
            if (bDate > aDate)
                return 1;
            return 0;
        }
    });
}

/**
 * Accepts a color (string) and returns a inverted hex color (string)
 * http://stackoverflow.com/questions/9600295/automatically-change-text-color-to-assure-readability
 *
 * @export
 * @param {any} value
 * @returns {string}
 */
function invertColor(value) {
    var color = rgb(value);
    var r = color.r, g = color.g, b = color.b, opacity = color.opacity;
    if (opacity === 0) {
        return color.toString();
    }
    var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    var depth = (yiq >= 128) ? -.8 : .8;
    return shadeRGBColor(color, depth);
}
/**
 * Given a rgb, it will darken/lighten
 * http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
 *
 * @export
 * @param {any} { r, g, b }
 * @param {any} percent
 * @returns
 */
function shadeRGBColor(_a, percent) {
    var r = _a.r, g = _a.g, b = _a.b;
    var t = percent < 0 ? 0 : 255;
    var p = percent < 0 ? percent * -1 : percent;
    r = (Math.round((t - r) * p) + r);
    g = (Math.round((t - g) * p) + g);
    b = (Math.round((t - b) * p) + b);
    return "rgb(" + r + ", " + g + ", " + b + ")";
}

/**
 * Visibility Observer
 */
var VisibilityObserver = /** @class */ (function () {
    function VisibilityObserver(element, zone) {
        this.element = element;
        this.zone = zone;
        this.visible = new EventEmitter();
        this.isVisible = false;
        this.runCheck();
    }
    VisibilityObserver.prototype.destroy = function () {
        clearTimeout(this.timeout);
    };
    VisibilityObserver.prototype.onVisibilityChange = function () {
        var _this = this;
        // trigger zone recalc for columns
        this.zone.run(function () {
            _this.isVisible = true;
            _this.visible.emit(true);
        });
    };
    VisibilityObserver.prototype.runCheck = function () {
        var _this = this;
        var check = function () {
            if (!_this.element) {
                return;
            }
            // https://davidwalsh.name/offsetheight-visibility
            var _a = _this.element.nativeElement, offsetHeight = _a.offsetHeight, offsetWidth = _a.offsetWidth;
            if (offsetHeight && offsetWidth) {
                clearTimeout(_this.timeout);
                _this.onVisibilityChange();
            }
            else {
                clearTimeout(_this.timeout);
                _this.zone.runOutsideAngular(function () {
                    _this.timeout = setTimeout(function () { return check(); }, 100);
                });
            }
        };
        this.zone.runOutsideAngular(function () {
            _this.timeout = setTimeout(function () { return check(); });
        });
    };
    var _a;
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], VisibilityObserver.prototype, "visible", void 0);
VisibilityObserver.ɵfac = function VisibilityObserver_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
VisibilityObserver.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VisibilityObserver, outputs: { visible: "visible" } });

    return VisibilityObserver;
}());

function isDate(value) {
    return toString.call(value) === '[object Date]';
}

var BaseChartComponent = /** @class */ (function () {
    function BaseChartComponent(chartElement, zone, cd) {
        this.chartElement = chartElement;
        this.zone = zone;
        this.cd = cd;
        this.scheme = 'cool';
        this.schemeType = 'ordinal';
        this.animations = true;
        this.select = new EventEmitter();
    }
    BaseChartComponent.prototype.ngAfterViewInit = function () {
        this.bindWindowResizeEvent();
        // listen for visibility of the element for hidden by default scenario
        this.visibilityObserver = new VisibilityObserver(this.chartElement, this.zone);
        this.visibilityObserver.visible.subscribe(this.update.bind(this));
    };
    BaseChartComponent.prototype.ngOnDestroy = function () {
        this.unbindEvents();
        if (this.visibilityObserver) {
            this.visibilityObserver.visible.unsubscribe();
            this.visibilityObserver.destroy();
        }
    };
    BaseChartComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BaseChartComponent.prototype.update = function () {
        if (this.results) {
            this.results = this.cloneData(this.results);
        }
        else {
            this.results = [];
        }
        if (this.view) {
            this.width = this.view[0];
            this.height = this.view[1];
        }
        else {
            var dims = this.getContainerDims();
            if (dims) {
                this.width = dims.width;
                this.height = dims.height;
            }
        }
        // default values if width or height are 0 or undefined
        if (!this.width) {
            this.width = 600;
        }
        if (!this.height) {
            this.height = 400;
        }
        this.width = Math.floor(this.width);
        this.height = Math.floor(this.height);
        if (this.cd) {
            this.cd.markForCheck();
        }
    };
    BaseChartComponent.prototype.getContainerDims = function () {
        var width;
        var height;
        var hostElem = this.chartElement.nativeElement;
        if (hostElem.parentNode !== null) {
            // Get the container dimensions
            var dims = hostElem.parentNode.getBoundingClientRect();
            width = dims.width;
            height = dims.height;
        }
        if (width && height) {
            return { width: width, height: height };
        }
        return null;
    };
    /**
     * Converts all date objects that appear as name
     * into formatted date strings
     */
    BaseChartComponent.prototype.formatDates = function () {
        for (var i = 0; i < this.results.length; i++) {
            var g = this.results[i];
            g.label = g.name;
            if (g.label instanceof Date) {
                g.label = g.label.toLocaleDateString();
            }
            if (g.series) {
                for (var j = 0; j < g.series.length; j++) {
                    var d = g.series[j];
                    d.label = d.name;
                    if (d.label instanceof Date) {
                        d.label = d.label.toLocaleDateString();
                    }
                }
            }
        }
    };
    BaseChartComponent.prototype.unbindEvents = function () {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    };
    BaseChartComponent.prototype.bindWindowResizeEvent = function () {
        var _this = this;
        var source = fromEvent(window, 'resize');
        var subscription = source.pipe(debounceTime(200)).subscribe(function (e) {
            _this.update();
            if (_this.cd) {
                _this.cd.markForCheck();
            }
        });
        this.resizeSubscription = subscription;
    };
    /**
     * Clones the data into a new object
     *
     * @private
     * @param {any} data
     * @returns {*}
     *
     * @memberOf BaseChart
     */
    BaseChartComponent.prototype.cloneData = function (data) {
        var results = [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var item = data_1[_i];
            var copy = {
                name: item['name']
            };
            if (item['value'] !== undefined) {
                copy['value'] = item['value'];
            }
            if (item['series'] !== undefined) {
                copy['series'] = [];
                for (var _a = 0, _b = item['series']; _a < _b.length; _a++) {
                    var seriesItem = _b[_a];
                    var seriesItemCopy = Object.assign({}, seriesItem);
                    copy['series'].push(seriesItemCopy);
                }
            }
            if (item['extra'] !== undefined) {
                copy['extra'] = JSON.parse(JSON.stringify(item['extra']));
            }
            results.push(copy);
        }
        return results;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BaseChartComponent.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "scheme", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BaseChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "customColors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BaseChartComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "select", void 0);
    BaseChartComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object, typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object, typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object])
    ], BaseChartComponent);
BaseChartComponent.ɵfac = function BaseChartComponent_Factory(t) { return new (t || BaseChartComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object)); };
BaseChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BaseChartComponent, selectors: [["base-chart"]], inputs: { scheme: "scheme", schemeType: "schemeType", animations: "animations", results: "results", view: "view", customColors: "customColors" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 0, template: function BaseChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div");
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseChartComponent, [{
        type: Component,
        args: [{
                selector: 'base-chart',
                template: "\n    <div></div>\n  "
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }, { type: typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object }, { type: typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object }]; }, { scheme: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], results: [{
            type: Input
        }], view: [{
            type: Input
        }], customColors: [{
            type: Input
        }] }); })();
    return BaseChartComponent;
}());

var AxisLabelComponent = /** @class */ (function () {
    function AxisLabelComponent(element) {
        this.textHeight = 25;
        this.margin = 5;
        this.element = element.nativeElement;
    }
    AxisLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AxisLabelComponent.prototype.update = function () {
        this.strokeWidth = '0.01';
        this.textAnchor = 'middle';
        this.transform = '';
        switch (this.orient) {
            case 'top':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'bottom':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'left':
                this.y = -(this.offset + this.textHeight + this.margin);
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            case 'right':
                this.y = this.offset + this.margin;
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            default:
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "height", void 0);
    AxisLabelComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], AxisLabelComponent);
AxisLabelComponent.ɵfac = function AxisLabelComponent_Factory(t) { return new (t || AxisLabelComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
AxisLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisLabelComponent, selectors: [["g", "ngx-charts-axis-label", ""]], inputs: { orient: "orient", label: "label", offset: "offset", width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c3, decls: 2, vars: 6, template: function AxisLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AxisLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-axis-label]',
                template: "\n    <svg:text\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\">\n      {{label}}\n    </svg:text>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { orient: [{
            type: Input
        }], label: [{
            type: Input
        }], offset: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }] }); })();
    return AxisLabelComponent;
}());

function reduceTicks(ticks, maxTicks) {
    if (ticks.length > maxTicks) {
        var reduced = [];
        var modulus = Math.floor(ticks.length / maxTicks);
        for (var i = 0; i < ticks.length; i++) {
            if (i % modulus === 0) {
                reduced.push(ticks[i]);
            }
        }
        ticks = reduced;
    }
    return ticks;
}

var XAxisTicksComponent = /** @class */ (function () {
    function XAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.rotateTicks = true;
        this.dimensionsChanged = new EventEmitter();
        this.verticalSpacing = 20;
        this.rotateLabels = false;
        this.innerTickSize = 6;
        this.outerTickSize = 6;
        this.tickPadding = 3;
        this.textAnchor = 'middle';
        this.maxTicksLength = 0;
        this.maxAllowedLength = 16;
        this.height = 0;
    }
    XAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
        if (height !== this.height) {
            this.height = height;
            this.dimensionsChanged.emit({ height: height });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    XAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
        this.adjustedScale = this.scale.bandwidth
            ? function (d) {
                return this.scale(d) + this.scale.bandwidth() * 0.5;
            }
            : this.scale;
        this.textTransform = '';
        if (angle && angle !== 0) {
            this.textTransform = "rotate(" + angle + ")";
            this.textAnchor = 'end';
            this.verticalSpacing = 10;
        }
        else {
            this.textAnchor = 'middle';
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.getRotationAngle = function (ticks) {
        var angle = 0;
        this.maxTicksLength = 0;
        for (var i = 0; i < ticks.length; i++) {
            var tick = this.tickFormat(ticks[i]).toString();
            var tickLength = tick.length;
            if (this.trimTicks) {
                tickLength = this.tickTrim(tick).length;
            }
            if (tickLength > this.maxTicksLength) {
                this.maxTicksLength = tickLength;
            }
        }
        var len = Math.min(this.maxTicksLength, this.maxAllowedLength);
        var charWidth = 8; // need to measure this
        var wordWidth = len * charWidth;
        var baseWidth = wordWidth;
        var maxBaseWidth = Math.floor(this.width / ticks.length);
        // calculate optimal angle
        while (baseWidth > maxBaseWidth && angle > -90) {
            angle -= 30;
            baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
        }
        return angle;
    };
    XAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(100);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    XAxisTicksComponent.prototype.getMaxTicks = function (tickWidth) {
        return Math.floor(this.width / tickWidth);
    };
    XAxisTicksComponent.prototype.tickTransform = function (tick) {
        return 'translate(' + this.adjustedScale(tick) + ',' + this.verticalSpacing + ')';
    };
    XAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(0," + (-this.verticalSpacing - 5) + ")";
    };
    XAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], XAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "gridLineHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisTicksComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], XAxisTicksComponent.prototype, "ticksElement", void 0);
XAxisTicksComponent.ɵfac = function XAxisTicksComponent_Factory(t) { return new (t || XAxisTicksComponent)(); };
XAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisTicksComponent, selectors: [["g", "ngx-charts-x-axis-ticks", ""]], viewQuery: function XAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", rotateTicks: "rotateTicks", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineHeight: "gridLineHeight", width: "width" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c5, decls: 4, vars: 2, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [4, "ngIf"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]], template: function XAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, XAxisTicksComponent__svg_g_2_Template, 5, 7, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"tickTransform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.text-anchor]=\"textAnchor\"\n          [attr.transform]=\"textTransform\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"tickTransform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line class=\"gridline-path gridline-path-vertical\" [attr.y1]=\"-gridLineHeight\" y2=\"0\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], rotateTicks: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineHeight: [{
            type: Input
        }], width: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel', { static: false }]
        }] }); })();
    return XAxisTicksComponent;
}());

var XAxisComponent = /** @class */ (function () {
    function XAxisComponent() {
        this.rotateTicks = true;
        this.showGridLines = false;
        this.xOrient = 'bottom';
        this.xAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.xAxisClassName = 'x axis';
        this.labelOffset = 0;
        this.fill = 'none';
        this.stroke = 'stroke';
        this.tickStroke = '#ccc';
        this.strokeWidth = 'none';
        this.padding = 5;
    }
    XAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisComponent.prototype.update = function () {
        this.transform = "translate(0," + (this.xAxisOffset + this.padding + this.dims.height) + ")";
        if (typeof this.xAxisTickCount !== 'undefined') {
            this.tickArguments = [this.xAxisTickCount];
        }
    };
    XAxisComponent.prototype.emitTicksHeight = function (_a) {
        var _this = this;
        var height = _a.height;
        var newLabelOffset = height + 25 + 5;
        if (newLabelOffset !== this.labelOffset) {
            this.labelOffset = newLabelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ height: height });
            }, 0);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], XAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xAxisTickInterval", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xAxisTickCount", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], XAxisComponent.prototype, "xOrient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisComponent.prototype, "xAxisOffset", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(XAxisTicksComponent, { static: false }),
        __metadata("design:type", typeof (_a = typeof XAxisTicksComponent !== "undefined" && XAxisTicksComponent) === "function" ? _a : Object)
    ], XAxisComponent.prototype, "ticksComponent", void 0);
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c6, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, XAxisTicksComponent,
        AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: "\n    <svg:g [attr.class]=\"xAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-x-axis-ticks\n        *ngIf=\"xScale\"\n        [trimTicks]=\"trimTicks\"\n        [rotateTicks]=\"rotateTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"xScale\"\n        [orient]=\"xOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineHeight]=\"dims.height\"\n        [width]=\"dims.width\"\n        [tickValues]=\"ticks\"\n        (dimensionsChanged)=\"emitTicksHeight($event)\"\n      />\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"'bottom'\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], xOrient: [{
            type: Input
        }], xAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], xScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], ticks: [{
            type: Input
        }], xAxisTickInterval: [{
            type: Input
        }], xAxisTickCount: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [XAxisTicksComponent, { static: false }]
        }] }); })();
    return XAxisComponent;
}());

/**
 * Generates a rounded rectanglar path
 *
 * @export
 * @param {*} x, y, w, h, r, tl, tr, bl, br
 * @returns {string}
 */
function roundedRect(x, y, w, h, r, _a) {
    var tl = _a[0], tr = _a[1], bl = _a[2], br = _a[3];
    var retval = '';
    w = Math.floor(w);
    h = Math.floor(h);
    w = w === 0 ? 1 : w;
    h = h === 0 ? 1 : h;
    retval = "M" + [x + r, y];
    retval += "h" + (w - 2 * r);
    if (tr) {
        retval += "a" + [r, r] + " 0 0 1 " + [r, r];
    }
    else {
        retval += "h" + r + "v" + r;
    }
    retval += "v" + (h - 2 * r);
    if (br) {
        retval += "a" + [r, r] + " 0 0 1 " + [-r, r];
    }
    else {
        retval += "v" + r + "h" + -r;
    }
    retval += "h" + (2 * r - w);
    if (bl) {
        retval += "a" + [r, r] + " 0 0 1 " + [-r, -r];
    }
    else {
        retval += "h" + -r + "v" + -r;
    }
    retval += "v" + (2 * r - h);
    if (tl) {
        retval += "a" + [r, r] + " 0 0 1 " + [r, -r];
    }
    else {
        retval += "v" + -r + "h" + r;
    }
    retval += "z";
    return retval;
}

var YAxisTicksComponent = /** @class */ (function () {
    function YAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.showRefLabels = false;
        this.showRefLines = false;
        this.dimensionsChanged = new EventEmitter();
        this.innerTickSize = 6;
        this.tickPadding = 3;
        this.verticalSpacing = 20;
        this.textAnchor = 'middle';
        this.width = 0;
        this.outerTickSize = 6;
        this.rotateLabels = false;
        this.referenceLineLength = 0;
    }
    YAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    YAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    YAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var width = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
        if (width !== this.width) {
            this.width = width;
            this.dimensionsChanged.emit({ width: width });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    YAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale;
        var sign = this.orient === 'top' || this.orient === 'right' ? -1 : 1;
        this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding;
        scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        this.adjustedScale = scale.bandwidth
            ? function (d) {
                return scale(d) + scale.bandwidth() * 0.5;
            }
            : scale;
        if (this.showRefLines && this.referenceLines) {
            this.setReferencelines();
        }
        switch (this.orient) {
            case 'top':
                this.transform = function (tick) {
                    return 'translate(' + this.adjustedScale(tick) + ',0)';
                };
                this.textAnchor = 'middle';
                this.y2 = this.innerTickSize * sign;
                this.y1 = this.tickSpacing * sign;
                this.dy = sign < 0 ? '0em' : '.71em';
                break;
            case 'bottom':
                this.transform = function (tick) {
                    return 'translate(' + this.adjustedScale(tick) + ',0)';
                };
                this.textAnchor = 'middle';
                this.y2 = this.innerTickSize * sign;
                this.y1 = this.tickSpacing * sign;
                this.dy = sign < 0 ? '0em' : '.71em';
                break;
            case 'left':
                this.transform = function (tick) {
                    return 'translate(0,' + this.adjustedScale(tick) + ')';
                };
                this.textAnchor = 'end';
                this.x2 = this.innerTickSize * -sign;
                this.x1 = this.tickSpacing * -sign;
                this.dy = '.32em';
                break;
            case 'right':
                this.transform = function (tick) {
                    return 'translate(0,' + this.adjustedScale(tick) + ')';
                };
                this.textAnchor = 'start';
                this.x2 = this.innerTickSize * -sign;
                this.x1 = this.tickSpacing * -sign;
                this.dy = '.32em';
                break;
            default:
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    YAxisTicksComponent.prototype.setReferencelines = function () {
        this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map(function (item) { return item.value; })));
        this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map(function (item) { return item.value; })));
        this.referenceLineLength = this.referenceLines.length;
        this.referenceAreaPath = roundedRect(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [
            false,
            false,
            false,
            false
        ]);
    };
    YAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(50);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    YAxisTicksComponent.prototype.getMaxTicks = function (tickHeight) {
        return Math.floor(this.height / tickHeight);
    };
    YAxisTicksComponent.prototype.tickTransform = function (tick) {
        return "translate(" + this.adjustedScale(tick) + "," + this.verticalSpacing + ")";
    };
    YAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(5,0)";
    };
    YAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], YAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "gridLineWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "showRefLines", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], YAxisTicksComponent.prototype, "ticksElement", void 0);
YAxisTicksComponent.ɵfac = function YAxisTicksComponent_Factory(t) { return new (t || YAxisTicksComponent)(); };
YAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisTicksComponent, selectors: [["g", "ngx-charts-y-axis-ticks", ""]], viewQuery: function YAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", showRefLabels: "showRefLabels", showRefLines: "showRefLines", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineWidth: "gridLineWidth", height: "height", referenceLines: "referenceLines" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c7, decls: 6, vars: 4, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], ["class", "reference-area", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [1, "reference-area"], [4, "ngIf"], ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"], ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"], ["x1", "0", 1, "refline-path", "gridline-path-horizontal"], [1, "refline-label"]], template: function YAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_2_Template, 5, 9, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, YAxisTicksComponent__svg_path_3_Template, 1, 2, "path", 2);
        ɵngcc0.ɵɵtemplate(4, YAxisTicksComponent__svg_g_4_Template, 2, 2, "g", 3);
        ɵngcc0.ɵɵtemplate(5, YAxisTicksComponent__svg_g_5_Template, 2, 1, "g", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.referenceLineLength > 1 && ctx.refMax && ctx.refMin && ctx.showRefLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.referenceLines);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"transform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.dy]=\"dy\"\n          [attr.x]=\"x1\"\n          [attr.y]=\"y1\"\n          [attr.text-anchor]=\"textAnchor\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:path\n      *ngIf=\"referenceLineLength > 1 && refMax && refMin && showRefLines\"\n      class=\"reference-area\"\n      [attr.d]=\"referenceAreaPath\"\n      [attr.transform]=\"gridLineTransform()\"\n    />\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"transform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line\n          *ngIf=\"orient === 'left'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n        />\n        <svg:line\n          *ngIf=\"orient === 'right'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"-gridLineWidth\"\n        />\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let refLine of referenceLines\">\n      <svg:g *ngIf=\"showRefLines\" [attr.transform]=\"transform(refLine.value)\">\n        <svg:line\n          class=\"refline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n          [attr.transform]=\"gridLineTransform()\"\n        />\n        <svg:g *ngIf=\"showRefLabels\">\n          <title>{{ tickTrim(tickFormat(refLine.value)) }}</title>\n          <svg:text\n            class=\"refline-label\"\n            [attr.dy]=\"dy\"\n            [attr.y]=\"-6\"\n            [attr.x]=\"gridLineWidth\"\n            [attr.text-anchor]=\"textAnchor\"\n          >\n            {{ refLine.name }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineWidth: [{
            type: Input
        }], height: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel', { static: false }]
        }] }); })();
    return YAxisTicksComponent;
}());

var YAxisComponent = /** @class */ (function () {
    function YAxisComponent() {
        this.showGridLines = false;
        this.yOrient = 'left';
        this.yAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.yAxisClassName = 'y axis';
        this.labelOffset = 15;
        this.fill = 'none';
        this.stroke = '#CCC';
        this.tickStroke = '#CCC';
        this.strokeWidth = 1;
        this.padding = 5;
    }
    YAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    YAxisComponent.prototype.update = function () {
        this.offset = -(this.yAxisOffset + this.padding);
        if (this.yOrient === 'right') {
            this.labelOffset = 65;
            this.transform = "translate(" + (this.offset + this.dims.width) + " , 0)";
        }
        else {
            this.offset = this.offset;
            this.transform = "translate(" + this.offset + " , 0)";
        }
        if (this.yAxisTickCount !== undefined) {
            this.tickArguments = [this.yAxisTickCount];
        }
    };
    YAxisComponent.prototype.emitTicksWidth = function (_a) {
        var _this = this;
        var width = _a.width;
        if (width !== this.labelOffset && this.yOrient === 'right') {
            this.labelOffset = width + this.labelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ width: width });
            }, 0);
        }
        else if (width !== this.labelOffset) {
            this.labelOffset = width;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ width: width });
            }, 0);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], YAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yAxisTickInterval", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yAxisTickCount", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], YAxisComponent.prototype, "yOrient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showRefLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisComponent.prototype, "yAxisOffset", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(YAxisTicksComponent, { static: false }),
        __metadata("design:type", typeof (_a = typeof YAxisTicksComponent !== "undefined" && YAxisTicksComponent) === "function" ? _a : Object)
    ], YAxisComponent.prototype, "ticksComponent", void 0);
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(); };
YAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisComponent, selectors: [["g", "ngx-charts-y-axis", ""]], viewQuery: function YAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(YAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { showGridLines: "showGridLines", yOrient: "yOrient", yAxisOffset: "yAxisOffset", yScale: "yScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", ticks: "ticks", showLabel: "showLabel", labelText: "labelText", yAxisTickInterval: "yAxisTickInterval", yAxisTickCount: "yAxisTickCount", referenceLines: "referenceLines", showRefLines: "showRefLines", showRefLabels: "showRefLabels" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c8, decls: 3, vars: 4, consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function YAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, YAxisComponent__svg_g_1_Template, 1, 14, "g", 0);
        ɵngcc0.ɵɵtemplate(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.yAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, YAxisTicksComponent,
        AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis]',
                template: "\n    <svg:g [attr.class]=\"yAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-y-axis-ticks\n        *ngIf=\"yScale\"\n        [trimTicks]=\"trimTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickValues]=\"ticks\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"yScale\"\n        [orient]=\"yOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineWidth]=\"dims.width\"\n        [referenceLines]=\"referenceLines\"\n        [showRefLines]=\"showRefLines\"\n        [showRefLabels]=\"showRefLabels\"\n        [height]=\"dims.height\"\n        (dimensionsChanged)=\"emitTicksWidth($event)\"\n      />\n\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"yOrient\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { showGridLines: [{
            type: Input
        }], yOrient: [{
            type: Input
        }], yAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], yScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], ticks: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], yAxisTickInterval: [{
            type: Input
        }], yAxisTickCount: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [YAxisTicksComponent, { static: false }]
        }] }); })();
    return YAxisComponent;
}());

var AxesModule = /** @class */ (function () {
    function AxesModule() {
    }
AxesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AxesModule });
AxesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AxesModule_Factory(t) { return new (t || AxesModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AxesModule, { declarations: function () { return [AxisLabelComponent,
        XAxisComponent,
        XAxisTicksComponent,
        YAxisComponent,
        YAxisTicksComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AxisLabelComponent,
        XAxisComponent,
        XAxisTicksComponent,
        YAxisComponent,
        YAxisTicksComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AxesModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent],
                exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]
            }]
    }], function () { return []; }, null); })();
    return AxesModule;
}());

var ColorHelper = /** @class */ (function () {
    function ColorHelper(scheme, type, domain, customColors) {
        if (typeof scheme === 'string') {
            scheme = colorSets.find(function (cs) {
                return cs.name === scheme;
            });
        }
        this.colorDomain = scheme.domain;
        this.scaleType = type;
        this.domain = domain;
        this.customColors = customColors;
        this.scale = this.generateColorScheme(scheme, type, this.domain);
    }
    ColorHelper.prototype.generateColorScheme = function (scheme, type, domain) {
        if (typeof scheme === 'string') {
            scheme = colorSets.find(function (cs) {
                return cs.name === scheme;
            });
        }
        var colorScale;
        if (type === 'quantile') {
            colorScale = scaleQuantile()
                .range(scheme.domain)
                .domain(domain);
        }
        else if (type === 'ordinal') {
            colorScale = scaleOrdinal()
                .range(scheme.domain)
                .domain(domain);
        }
        else if (type === 'linear') {
            // linear schemes must have at least 2 colors
            var colorDomain = scheme.domain.slice();
            if (colorDomain.length === 1) {
                colorDomain.push(colorDomain[0]);
                this.colorDomain = colorDomain;
            }
            var points = range(0, 1, 1.0 / colorDomain.length);
            colorScale = scaleLinear()
                .domain(points)
                .range(colorDomain);
        }
        return colorScale;
    };
    ColorHelper.prototype.getColor = function (value) {
        if (value === undefined || value === null) {
            throw new Error('Value can not be null');
        }
        if (this.scaleType === 'linear') {
            var valueScale = scaleLinear()
                .domain(this.domain)
                .range([0, 1]);
            return this.scale(valueScale(value));
        }
        else {
            if (typeof this.customColors === 'function') {
                return this.customColors(value);
            }
            var formattedValue_1 = value.toString();
            var found = void 0; // todo type customColors
            if (this.customColors && this.customColors.length > 0) {
                found = this.customColors.find(function (mapping) {
                    return mapping.name.toLowerCase() === formattedValue_1.toLowerCase();
                });
            }
            if (found) {
                return found.value;
            }
            else {
                return this.scale(value);
            }
        }
    };
    ColorHelper.prototype.getLinearGradientStops = function (value, start) {
        if (start === undefined) {
            start = this.domain[0];
        }
        var valueScale = scaleLinear()
            .domain(this.domain)
            .range([0, 1]);
        var colorValueScale = scaleBand()
            .domain(this.colorDomain)
            .range([0, 1]);
        var endColor = this.getColor(value);
        // generate the stops
        var startVal = valueScale(start);
        var startColor = this.getColor(start);
        var endVal = valueScale(value);
        var i = 1;
        var currentVal = startVal;
        var stops = [];
        stops.push({
            color: startColor,
            offset: startVal,
            originalOffset: startVal,
            opacity: 1
        });
        while (currentVal < endVal && i < this.colorDomain.length) {
            var color = this.colorDomain[i];
            var offset = colorValueScale(color);
            if (offset <= startVal) {
                i++;
                continue;
            }
            if (offset.toFixed(4) >= (endVal - colorValueScale.bandwidth()).toFixed(4)) {
                break;
            }
            stops.push({
                color: color,
                offset: offset,
                opacity: 1
            });
            currentVal = offset;
            i++;
        }
        if (stops[stops.length - 1].offset < 100) {
            stops.push({
                color: endColor,
                offset: endVal,
                opacity: 1
            });
        }
        if (endVal === startVal) {
            stops[0].offset = 0;
            stops[1].offset = 100;
        }
        else {
            // normalize the offsets into percentages
            if (stops[stops.length - 1].offset !== 100) {
                for (var _i = 0, stops_1 = stops; _i < stops_1.length; _i++) {
                    var s = stops_1[_i];
                    s.offset = ((s.offset - startVal) / (endVal - startVal)) * 100;
                }
            }
        }
        return stops;
    };
    return ColorHelper;
}());

var CircleSeriesComponent = /** @class */ (function () {
    function CircleSeriesComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.barVisible = false;
    }
    CircleSeriesComponent.prototype.ngOnInit = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
    };
    CircleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CircleSeriesComponent.prototype.update = function () {
        this.circle = this.getActiveCircle();
    };
    CircleSeriesComponent.prototype.getActiveCircle = function () {
        var _this = this;
        var indexActiveDataPoint = this.data.series.findIndex(function (d) {
            var label = d.name;
            return label && _this.visibleValue && label.toString() === _this.visibleValue.toString() && d.value !== undefined;
        });
        if (indexActiveDataPoint === -1) {
            // No valid point is 'active/hovered over' at this moment.
            return undefined;
        }
        return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
    };
    CircleSeriesComponent.prototype.mapDataPointToCircle = function (d, i) {
        var seriesName = this.data.name;
        var value = d.value;
        var label = d.name;
        var tooltipLabel = formatLabel(label);
        var cx;
        if (this.scaleType === 'time') {
            cx = this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            cx = this.xScale(Number(label));
        }
        else {
            cx = this.xScale(label);
        }
        var cy = this.yScale(this.type === 'standard' ? value : d.d1);
        var radius = 5;
        var height = this.yScale.range()[0] - cy;
        var opacity = 1;
        var color;
        if (this.colors.scaleType === 'linear') {
            if (this.type === 'standard') {
                color = this.colors.getColor(value);
            }
            else {
                color = this.colors.getColor(d.d1);
            }
        }
        else {
            color = this.colors.getColor(seriesName);
        }
        var data = Object.assign({}, d, {
            series: seriesName,
            value: value,
            name: label
        });
        return {
            classNames: ["circle-data-" + i],
            value: value,
            label: label,
            data: data,
            cx: cx,
            cy: cy,
            radius: radius,
            height: height,
            tooltipLabel: tooltipLabel,
            color: color,
            opacity: opacity,
            seriesName: seriesName,
            gradientStops: this.getGradientStops(color),
            min: d.min,
            max: d.max
        };
    };
    CircleSeriesComponent.prototype.getTooltipText = function (_a) {
        var tooltipLabel = _a.tooltipLabel, value = _a.value, seriesName = _a.seriesName, min$$1 = _a.min, max$$1 = _a.max;
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(seriesName) + " \u2022 " + escapeLabel(tooltipLabel) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + this.getTooltipMinMaxText(min$$1, max$$1) + "</span>\n    ";
    };
    CircleSeriesComponent.prototype.getTooltipMinMaxText = function (min$$1, max$$1) {
        if (min$$1 !== undefined || max$$1 !== undefined) {
            var result = ' (';
            if (min$$1 !== undefined) {
                if (max$$1 === undefined) {
                    result += '≥';
                }
                result += min$$1.toLocaleString();
                if (max$$1 !== undefined) {
                    result += ' - ';
                }
            }
            else if (max$$1 !== undefined) {
                result += '≤';
            }
            if (max$$1 !== undefined) {
                result += max$$1.toLocaleString();
            }
            result += ')';
            return result;
        }
        else {
            return '';
        }
    };
    CircleSeriesComponent.prototype.getGradientStops = function (color) {
        return [
            {
                offset: 0,
                color: color,
                opacity: 0.2
            },
            {
                offset: 100,
                color: color,
                opacity: 1
            }
        ];
    };
    CircleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    CircleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    CircleSeriesComponent.prototype.activateCircle = function () {
        this.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    CircleSeriesComponent.prototype.deactivateCircle = function () {
        this.barVisible = false;
        this.circle.opacity = 0;
        this.deactivate.emit({ name: this.data.name });
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof ColorHelper !== "undefined" && ColorHelper) === "function" ? _a : Object)
    ], CircleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CircleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CircleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _b : Object)
    ], CircleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "deactivate", void 0);
CircleSeriesComponent.ɵfac = function CircleSeriesComponent_Factory(t) { return new (t || CircleSeriesComponent)(); };
CircleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleSeriesComponent, selectors: [["g", "ngx-charts-circle-series", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", visibleValue: "visibleValue", activeEntries: "activeEntries", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c9, decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], [1, "tooltip-bar"]], template: function CircleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CircleSeriesComponent__svg_g_0_Template, 5, 20, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.circle);
    } }, directives: function () { return [ɵngcc1.NgIf, SvgLinearGradientComponent,
        CircleComponent,
        TooltipDirective]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CircleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle-series]',
                template: "\n    <svg:g *ngIf=\"circle\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"circle.gradientStops\"\n        />\n      </defs>\n      <svg:rect\n        *ngIf=\"barVisible && type === 'standard'\"\n        [@animationState]=\"'active'\"\n        [attr.x]=\"circle.cx - circle.radius\"\n        [attr.y]=\"circle.cy\"\n        [attr.width]=\"circle.radius * 2\"\n        [attr.height]=\"circle.height\"\n        [attr.fill]=\"gradientFill\"\n        class=\"tooltip-bar\"\n      />\n      <svg:g\n        ngx-charts-circle\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circle.radius\"\n        [fill]=\"circle.color\"\n        [class.active]=\"isActive({ name: circle.seriesName })\"\n        [pointerEvents]=\"circle.value === 0 ? 'none' : 'all'\"\n        [data]=\"circle.value\"\n        [classNames]=\"circle.classNames\"\n        (select)=\"onClick(circle.data)\"\n        (activate)=\"activateCircle()\"\n        (deactivate)=\"deactivateCircle()\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return CircleSeriesComponent;
}());

var CircleComponent = /** @class */ (function () {
    function CircleComponent() {
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    CircleComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    CircleComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    CircleComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    CircleComponent.prototype.ngOnChanges = function (changes) {
        this.classNames = Array.isArray(this.classNames) ?
            this.classNames.join(' ') :
            '';
        this.classNames += 'circle';
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "cx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "cy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "r", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "stroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "classNames", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "circleOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "pointerEvents", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onClick", null);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onMouseLeave", null);
CircleComponent.ɵfac = function CircleComponent_Factory(t) { return new (t || CircleComponent)(); };
CircleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleComponent, selectors: [["g", "ngx-charts-circle", ""]], hostBindings: function CircleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function CircleComponent_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function CircleComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function CircleComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { classNames: "classNames", cx: "cx", cy: "cy", r: "r", fill: "fill", stroke: "stroke", data: "data", circleOpacity: "circleOpacity", pointerEvents: "pointerEvents" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c11, decls: 1, vars: 8, template: function CircleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "circle");
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r)("fill", ctx.fill)("stroke", ctx.stroke)("opacity", ctx.circleOpacity)("class", ctx.classNames)("pointer-events", ctx.pointerEvents);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CircleComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle]',
                template: "\n    <svg:circle\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      [attr.opacity]=\"circleOpacity\"\n      [attr.class]=\"classNames\"\n      [attr.pointer-events]=\"pointerEvents\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], classNames: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], r: [{
            type: Input
        }], fill: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }], circleOpacity: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }] }); })();
    return CircleComponent;
}());

var GridPanelComponent = /** @class */ (function () {
    function GridPanelComponent() {
    }
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "y", void 0);
GridPanelComponent.ɵfac = function GridPanelComponent_Factory(t) { return new (t || GridPanelComponent)(); };
GridPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelComponent, selectors: [["g", "ngx-charts-grid-panel", ""]], inputs: { path: "path", width: "width", height: "height", x: "x", y: "y" }, attrs: _c12, decls: 1, vars: 4, consts: [["stroke", "none", 1, "gridpanel"]], template: function GridPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "rect", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("height", ctx.height)("width", ctx.width)("x", ctx.x)("y", ctx.y);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridPanelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel]',
                template: "\n    <svg:rect\n      [attr.height]=\"height\"\n      [attr.width]=\"width\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      stroke=\"none\"\n      class=\"gridpanel\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { path: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }] }); })();
    return GridPanelComponent;
}());

var GridPanelSeriesComponent = /** @class */ (function () {
    function GridPanelSeriesComponent() {
    }
    GridPanelSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GridPanelSeriesComponent.prototype.update = function () {
        this.gridPanels = this.getGridPanels();
    };
    GridPanelSeriesComponent.prototype.getGridPanels = function () {
        var _this = this;
        return this.data.map(function (d) {
            var offset;
            var width;
            var height;
            var x;
            var y;
            var className = 'odd';
            if (_this.orient === 'vertical') {
                var position = _this.xScale(d.name);
                var positionIndex = Number.parseInt((position / _this.xScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = _this.xScale.bandwidth() * _this.xScale.paddingInner();
                width = _this.xScale.bandwidth() + offset;
                height = _this.dims.height;
                x = _this.xScale(d.name) - offset / 2;
                y = 0;
            }
            else if (_this.orient === 'horizontal') {
                var position = _this.yScale(d.name);
                var positionIndex = Number.parseInt((position / _this.yScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = _this.yScale.bandwidth() * _this.yScale.paddingInner();
                width = _this.dims.width;
                height = _this.yScale.bandwidth() + offset;
                x = 0;
                y = _this.yScale(d.name) - offset / 2;
            }
            return {
                name: d.name,
                class: className,
                height: height,
                width: width,
                x: x,
                y: y
            };
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "orient", void 0);
GridPanelSeriesComponent.ɵfac = function GridPanelSeriesComponent_Factory(t) { return new (t || GridPanelSeriesComponent)(); };
GridPanelSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelSeriesComponent, selectors: [["g", "ngx-charts-grid-panel-series", ""]], inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale", orient: "orient" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c13, decls: 1, vars: 1, consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]], template: function GridPanelSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.gridPanels);
    } }, directives: [ɵngcc1.NgForOf, GridPanelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridPanelSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel-series]',
                template: "\n    <svg:g ngx-charts-grid-panel *ngFor=\"let gridPanel of gridPanels\"\n      [height]=\"gridPanel.height\"\n      [width]=\"gridPanel.width\"\n      [x]=\"gridPanel.x\"\n      [y]=\"gridPanel.y\"\n      [class.grid-panel]=\"true\"\n      [class.odd]=\"gridPanel.class === 'odd'\"\n      [class.even]=\"gridPanel.class === 'even'\">\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { data: [{
            type: Input
        }], dims: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], orient: [{
            type: Input
        }] }); })();
    return GridPanelSeriesComponent;
}());

var SvgLinearGradientComponent = /** @class */ (function () {
    function SvgLinearGradientComponent() {
        this.orientation = 'vertical';
    }
    SvgLinearGradientComponent.prototype.ngOnChanges = function (changes) {
        this.x1 = '0%';
        this.x2 = '0%';
        this.y1 = '0%';
        this.y2 = '0%';
        if (this.orientation === 'horizontal') {
            this.x2 = '100%';
        }
        else if (this.orientation === 'vertical') {
            this.y1 = '100%';
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgLinearGradientComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgLinearGradientComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SvgLinearGradientComponent.prototype, "stops", void 0);
SvgLinearGradientComponent.ɵfac = function SvgLinearGradientComponent_Factory(t) { return new (t || SvgLinearGradientComponent)(); };
SvgLinearGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgLinearGradientComponent, selectors: [["g", "ngx-charts-svg-linear-gradient", ""]], inputs: { orientation: "orientation", name: "name", stops: "stops" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c14, decls: 2, vars: 6, consts: [[3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgLinearGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "linearGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgLinearGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("x1", ctx.x1)("y1", ctx.y1)("x2", ctx.x2)("y2", ctx.y2);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgLinearGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-linear-gradient]',
                template: "\n    <svg:linearGradient\n      [id]=\"name\"\n      [attr.x1]=\"x1\"\n      [attr.y1]=\"y1\"\n      [attr.x2]=\"x2\"\n      [attr.y2]=\"y2\">\n      <svg:stop *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:linearGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], name: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return SvgLinearGradientComponent;
}());

var SvgRadialGradientComponent = /** @class */ (function () {
    function SvgRadialGradientComponent() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    Object.defineProperty(SvgRadialGradientComponent.prototype, "stops", {
        get: function () {
            return this.stopsInput || this.stopsDefault;
        },
        set: function (value) {
            this.stopsInput = value;
        },
        enumerable: true,
        configurable: true
    });
    SvgRadialGradientComponent.prototype.ngOnChanges = function (changes) {
        this.r = '30%';
        if (('color' in changes) ||
            ('startOpacity' in changes) ||
            ('endOpacity' in changes)) {
            this.stopsDefault = [{
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                }, {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }];
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SvgRadialGradientComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SvgRadialGradientComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgRadialGradientComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "cx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "cy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], SvgRadialGradientComponent.prototype, "stops", null);
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c15, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: "\n    <svg:radialGradient\n      [id]=\"name\"\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      gradientUnits=\"userSpaceOnUse\">\n      <svg:stop *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:radialGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();
    return SvgRadialGradientComponent;
}());

var Timeline = /** @class */ (function () {
    function Timeline(element, cd) {
        this.cd = cd;
        this.height = 50;
        this.select = new EventEmitter();
        this.onDomainChange = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    Timeline.prototype.ngOnChanges = function (changes) {
        this.update();
        if (!this.initialized) {
            this.addBrush();
            this.initialized = true;
        }
    };
    Timeline.prototype.update = function () {
        this.dims = this.getDims();
        this.height = this.dims.height;
        var offsetY = this.view[1] - this.height;
        this.xDomain = this.getXDomain();
        this.xScale = this.getXScale();
        if (this.brush) {
            this.updateBrush();
        }
        this.transform = "translate(0 , " + offsetY + ")";
        this.filterId = 'filter' + id().toString();
        this.filter = "url(#" + this.filterId + ")";
        this.cd.markForCheck();
    };
    Timeline.prototype.getXDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        var domain = [];
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
        }
        else {
            domain = values;
        }
        return domain;
    };
    Timeline.prototype.getXScale = function () {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime()
                .range([0, this.dims.width])
                .domain(this.xDomain);
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear()
                .range([0, this.dims.width])
                .domain(this.xDomain);
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint()
                .range([0, this.dims.width])
                .padding(0.1)
                .domain(this.xDomain);
        }
        return scale;
    };
    Timeline.prototype.addBrush = function () {
        var _this = this;
        if (this.brush)
            return;
        var height = this.height;
        var width = this.view[0];
        this.brush = brushX()
            .extent([[0, 0], [width, height]])
            .on('brush end', function () {
            var selection = event.selection || _this.xScale.range();
            var newDomain = selection.map(_this.xScale.invert);
            _this.onDomainChange.emit(newDomain);
            _this.cd.markForCheck();
        });
        select(this.element)
            .select('.brush')
            .call(this.brush);
    };
    Timeline.prototype.updateBrush = function () {
        if (!this.brush)
            return;
        var height = this.height;
        var width = this.view[0];
        this.brush.extent([[0, 0], [width, height]]);
        select(this.element)
            .select('.brush')
            .call(this.brush);
        select(this.element).select('.selection')
            .attr('fill', undefined)
            .attr('stroke', undefined)
            .attr('fill-opacity', undefined);
        this.cd.markForCheck();
    };
    Timeline.prototype.getDims = function () {
        var width = this.view[0];
        var dims = {
            width: width,
            height: this.height
        };
        return dims;
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "scheme", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "customColors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "miniChart", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], Timeline.prototype, "height", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "onDomainChange", void 0);
    Timeline = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object, typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object])
    ], Timeline);
Timeline.ɵfac = function Timeline_Factory(t) { return new (t || Timeline)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object)); };
Timeline.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Timeline, selectors: [["g", "ngx-charts-timeline", ""]], inputs: { height: "height", view: "view", state: "state", results: "results", scheme: "scheme", customColors: "customColors", legend: "legend", miniChart: "miniChart", autoScale: "autoScale", scaleType: "scaleType" }, outputs: { select: "select", onDomainChange: "onDomainChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c16, ngContentSelectors: _c2, decls: 7, vars: 4, consts: [[1, "timeline"], ["in", "SourceGraphic", "type", "matrix", "values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"], [1, "embedded-chart"], ["x", "0", "y", "0", 1, "brush-background"], [1, "brush"]], template: function Timeline_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "filter");
        ɵngcc0.ɵɵelement(2, "feColorMatrix", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "rect", 3);
        ɵngcc0.ɵɵelement(6, "g", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("id", ctx.filterId);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵattribute("width", ctx.view[0])("height", ctx.height);
    } }, styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Timeline, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-timeline]',
                template: "\n    <svg:g\n      class=\"timeline\"\n      [attr.transform]=\"transform\">\n      <svg:filter [attr.id]=\"filterId\">\n        <svg:feColorMatrix in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\" />\n      </svg:filter>\n      <svg:g class=\"embedded-chart\">\n        <ng-content></ng-content>\n      </svg:g>\n      <svg:rect x=\"0\"\n        [attr.width]=\"view[0]\"\n        y=\"0\"\n        [attr.height]=\"height\"\n        class=\"brush-background\"\n      />\n      <svg:g class=\"brush\"></svg:g>\n    </svg:g>\n  ",
                styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object }]; }, { height: [{
            type: Input
        }], select: [{
            type: Output
        }], onDomainChange: [{
            type: Output
        }], view: [{
            type: Input
        }], state: [{
            type: Input
        }], results: [{
            type: Input
        }], scheme: [{
            type: Input
        }], customColors: [{
            type: Input
        }], legend: [{
            type: Input
        }], miniChart: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], scaleType: [{
            type: Input
        }] }); })();
    return Timeline;
}());

var AreaComponent = /** @class */ (function () {
    function AreaComponent(element) {
        this.opacity = 1;
        this.startOpacity = 0.5;
        this.endOpacity = 1;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.element = element.nativeElement;
    }
    AreaComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    AreaComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
    };
    AreaComponent.prototype.loadAnimation = function () {
        this.areaPath = this.startingPath;
        setTimeout(this.update.bind(this), 100);
    };
    AreaComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.area');
        if (this.animations) {
            node.transition().duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    AreaComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: this.endOpacity
            }
        ];
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "startingPath", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "opacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "activeLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaComponent.prototype, "stops", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "select", void 0);
    AreaComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], AreaComponent);
AreaComponent.ɵfac = function AreaComponent_Factory(t) { return new (t || AreaComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
AreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaComponent, selectors: [["g", "ngx-charts-area", ""]], inputs: { opacity: "opacity", startOpacity: "startOpacity", endOpacity: "endOpacity", gradient: "gradient", animations: "animations", data: "data", path: "path", startingPath: "startingPath", fill: "fill", activeLabel: "activeLabel", stops: "stops" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c17, decls: 2, vars: 5, consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function AreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, AreaComponent__svg_defs_0_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.opacity);
        ɵngcc0.ɵɵattribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area]',
                template: "\n    <svg:defs *ngIf=\"gradient\">\n      <svg:g ngx-charts-svg-linear-gradient\n        orientation=\"vertical\"\n        [name]=\"gradientId\"\n        [stops]=\"gradientStops\"\n      />\n    </svg:defs>\n    <svg:path\n      class=\"area\"\n      [attr.d]=\"areaPath\"\n      [attr.fill]=\"gradient ? gradientFill : fill\"\n      [style.opacity]=\"opacity\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { opacity: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }], endOpacity: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], path: [{
            type: Input
        }], startingPath: [{
            type: Input
        }], fill: [{
            type: Input
        }], activeLabel: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return AreaComponent;
}());

// If we don't check whether 'window' and 'global' variables are defined,
// code will fail in browser/node with 'variable is undefined' error.
var root;
if (typeof window !== 'undefined') {
    root = window;
}
else if (typeof global !== 'undefined') {
    root = global;
}
// tslint:disable-next-line:variable-name
var MouseEvent = root.MouseEvent;
function createMouseEvent(name, bubbles, cancelable) {
    if (bubbles === void 0) { bubbles = false; }
    if (cancelable === void 0) { cancelable = true; }
    // Calling new of an event does not work correctly on IE. The following is a tested workaround
    // See https://stackoverflow.com/questions/27176983/dispatchevent-not-working-in-ie11
    if (typeof (MouseEvent) === 'function') {
        // Sane browsers
        return new MouseEvent(name, { bubbles: bubbles, cancelable: cancelable });
    }
    else {
        // IE
        var event$$1 = document.createEvent('MouseEvent');
        event$$1.initEvent(name, bubbles, cancelable);
        return event$$1;
    }
}

var TooltipArea = /** @class */ (function () {
    function TooltipArea() {
        this.anchorOpacity = 0;
        this.anchorPos = -1;
        this.anchorValues = [];
        this.showPercentage = false;
        this.tooltipDisabled = false;
        this.hover = new EventEmitter();
    }
    TooltipArea.prototype.getValues = function (xVal) {
        var results = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var item = group.series.find(function (d) { return d.name.toString() === xVal.toString(); });
            var groupName = group.name;
            if (groupName instanceof Date) {
                groupName = groupName.toLocaleDateString();
            }
            if (item) {
                var label = item.name;
                var val = item.value;
                if (this.showPercentage) {
                    val = (item.d1 - item.d0).toFixed(2) + '%';
                }
                var color = void 0;
                if (this.colors.scaleType === 'linear') {
                    var v = val;
                    if (item.d1) {
                        v = item.d1;
                    }
                    color = this.colors.getColor(v);
                }
                else {
                    color = this.colors.getColor(group.name);
                }
                var data = Object.assign({}, item, {
                    value: val,
                    name: label,
                    series: groupName,
                    min: item.min,
                    max: item.max,
                    color: color
                });
                results.push(data);
            }
        }
        return results;
    };
    TooltipArea.prototype.mouseMove = function (event$$1) {
        var xPos = event$$1.pageX - event$$1.target.getBoundingClientRect().left;
        var closestIndex = this.findClosestPointIndex(xPos);
        var closestPoint = this.xSet[closestIndex];
        this.anchorPos = this.xScale(closestPoint);
        this.anchorPos = Math.max(0, this.anchorPos);
        this.anchorPos = Math.min(this.dims.width, this.anchorPos);
        this.anchorValues = this.getValues(closestPoint);
        if (this.anchorPos !== this.lastAnchorPos) {
            var ev = createMouseEvent('mouseleave');
            this.tooltipAnchor.nativeElement.dispatchEvent(ev);
            this.anchorOpacity = 0.7;
            this.hover.emit({
                value: closestPoint
            });
            this.showTooltip();
            this.lastAnchorPos = this.anchorPos;
        }
    };
    TooltipArea.prototype.findClosestPointIndex = function (xPos) {
        var minIndex = 0;
        var maxIndex = this.xSet.length - 1;
        var minDiff = Number.MAX_VALUE;
        var closestIndex = 0;
        while (minIndex <= maxIndex) {
            var currentIndex = ((minIndex + maxIndex) / 2) | 0;
            var currentElement = this.xScale(this.xSet[currentIndex]);
            var curDiff = Math.abs(currentElement - xPos);
            if (curDiff < minDiff) {
                minDiff = curDiff;
                closestIndex = currentIndex;
            }
            if (currentElement < xPos) {
                minIndex = currentIndex + 1;
            }
            else if (currentElement > xPos) {
                maxIndex = currentIndex - 1;
            }
            else {
                minDiff = 0;
                closestIndex = currentIndex;
                break;
            }
        }
        return closestIndex;
    };
    TooltipArea.prototype.showTooltip = function () {
        var event$$1 = createMouseEvent('mouseenter');
        this.tooltipAnchor.nativeElement.dispatchEvent(event$$1);
    };
    TooltipArea.prototype.hideTooltip = function () {
        var event$$1 = createMouseEvent('mouseleave');
        this.tooltipAnchor.nativeElement.dispatchEvent(event$$1);
        this.anchorOpacity = 0;
        this.lastAnchorPos = -1;
    };
    TooltipArea.prototype.getToolTipText = function (tooltipItem) {
        var result = '';
        if (tooltipItem.series !== undefined) {
            result += tooltipItem.series;
        }
        else {
            result += '???';
        }
        result += ': ';
        if (tooltipItem.value !== undefined) {
            result += tooltipItem.value.toLocaleString();
        }
        if (tooltipItem.min !== undefined || tooltipItem.max !== undefined) {
            result += ' (';
            if (tooltipItem.min !== undefined) {
                if (tooltipItem.max === undefined) {
                    result += '≥';
                }
                result += tooltipItem.min.toLocaleString();
                if (tooltipItem.max !== undefined) {
                    result += ' - ';
                }
            }
            else if (tooltipItem.max !== undefined) {
                result += '≤';
            }
            if (tooltipItem.max !== undefined) {
                result += tooltipItem.max.toLocaleString();
            }
            result += ')';
        }
        return result;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "xSet", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipArea.prototype, "showPercentage", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipArea.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TooltipArea.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "hover", void 0);
    __decorate([
        ViewChild('tooltipAnchor', { static: false }),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "tooltipAnchor", void 0);
TooltipArea.ɵfac = function TooltipArea_Factory(t) { return new (t || TooltipArea)(); };
TooltipArea.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipArea, selectors: [["g", "ngx-charts-tooltip-area", ""]], viewQuery: function TooltipArea_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c18, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipAnchor = _t.first);
    } }, inputs: { showPercentage: "showPercentage", tooltipDisabled: "tooltipDisabled", dims: "dims", xSet: "xSet", xScale: "xScale", yScale: "yScale", results: "results", colors: "colors", tooltipTemplate: "tooltipTemplate" }, outputs: { hover: "hover" }, attrs: _c19, decls: 6, vars: 18, consts: [["y", "0", 1, "tooltip-area", 2, "opacity", "0", "cursor", "auto", 3, "mousemove", "mouseleave"], ["defaultTooltipTemplate", ""], ["y", "0", "ngx-tooltip", "", 1, "tooltip-anchor", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipSpacing", "tooltipTemplate", "tooltipContext", "tooltipImmediateExit"], ["tooltipAnchor", ""], [1, "area-tooltip-container"], ["class", "tooltip-item", 4, "ngFor", "ngForOf"], [1, "tooltip-item"], [1, "tooltip-item-color"]], template: function TooltipArea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "rect", 0);
        ɵngcc0.ɵɵlistener("mousemove", function TooltipArea_Template__svg_rect_mousemove_1_listener($event) { return ctx.mouseMove($event); })("mouseleave", function TooltipArea_Template__svg_rect_mouseleave_1_listener() { return ctx.hideTooltip(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, TooltipArea__xhtml_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelement(4, "rect", 2, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        var _r0 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", 0)("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.anchorOpacity)("pointer-events", "none");
        ɵngcc0.ɵɵproperty("@animationState", ctx.anchorOpacity !== 0 ? "active" : "inactive")("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "right")("tooltipType", "tooltip")("tooltipSpacing", 15)("tooltipTemplate", ctx.tooltipTemplate ? ctx.tooltipTemplate : _r0)("tooltipContext", ctx.anchorValues)("tooltipImmediateExit", true);
        ɵngcc0.ɵɵattribute("x", ctx.anchorPos)("width", 1)("height", ctx.dims.height);
    } }, directives: [TooltipDirective, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition('inactive => active', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 0.7 }))
                ]),
                transition('active => inactive', [
                    style({
                        opacity: 0.7
                    }),
                    animate(250, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipArea, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tooltip-area]',
                template: "\n    <svg:g>\n      <svg:rect\n        class=\"tooltip-area\"\n        [attr.x]=\"0\"\n        y=\"0\"\n        [attr.width]=\"dims.width\"\n        [attr.height]=\"dims.height\"\n        style=\"opacity: 0; cursor: 'auto';\"\n        (mousemove)=\"mouseMove($event)\"\n        (mouseleave)=\"hideTooltip()\"\n      />\n      <xhtml:ng-template #defaultTooltipTemplate let-model=\"model\">\n        <xhtml:div class=\"area-tooltip-container\">\n          <xhtml:div *ngFor=\"let tooltipItem of model\" class=\"tooltip-item\">\n            <span class=\"tooltip-item-color\" [style.background-color]=\"tooltipItem.color\"> </span>\n            {{ getToolTipText(tooltipItem) }}\n          </xhtml:div>\n        </xhtml:div>\n      </xhtml:ng-template>\n      <svg:rect\n        #tooltipAnchor\n        [@animationState]=\"anchorOpacity !== 0 ? 'active' : 'inactive'\"\n        class=\"tooltip-anchor\"\n        [attr.x]=\"anchorPos\"\n        y=\"0\"\n        [attr.width]=\"1\"\n        [attr.height]=\"dims.height\"\n        [style.opacity]=\"anchorOpacity\"\n        [style.pointer-events]=\"'none'\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'right'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipSpacing]=\"15\"\n        [tooltipTemplate]=\"tooltipTemplate ? tooltipTemplate : defaultTooltipTemplate\"\n        [tooltipContext]=\"anchorValues\"\n        [tooltipImmediateExit]=\"true\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition('inactive => active', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 0.7 }))
                        ]),
                        transition('active => inactive', [
                            style({
                                opacity: 0.7
                            }),
                            animate(250, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { showPercentage: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], hover: [{
            type: Output
        }], dims: [{
            type: Input
        }], xSet: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], results: [{
            type: Input
        }], colors: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], tooltipAnchor: [{
            type: ViewChild,
            args: ['tooltipAnchor', { static: false }]
        }] }); })();
    return TooltipArea;
}());

// Robert Penner's easeOutExpo
function easeOutExpo(t, b, c, d) {
    return (c * (-Math.pow(2, (-10 * t) / d) + 1) * 1024) / 1023 + b;
}
/**
 * Counts from a number to the end incrementally.
 *
 * @export
 * @param {any} countFrom
 * @param {any} countTo
 * @param {any} countDecimals
 * @param {any} countDuration
 * @param {any} callback
 * @returns
 */
function count(countFrom, countTo, countDecimals, countDuration, callback) {
    var startVal = Number(countFrom);
    var endVal = Number(countTo);
    var countDown = startVal > endVal;
    var decimals = Math.max(0, countDecimals);
    var dec = Math.pow(10, decimals);
    var duration = Number(countDuration) * 1000;
    var startTime;
    function runCount(timestamp) {
        var frameVal;
        var progress = timestamp - startTime;
        if (countDown) {
            frameVal = startVal - easeOutExpo(progress, 0, startVal - endVal, duration);
        }
        else {
            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);
        }
        if (countDown) {
            frameVal = frameVal < endVal ? endVal : frameVal;
        }
        else {
            frameVal = frameVal > endVal ? endVal : frameVal;
        }
        frameVal = Math.round(frameVal * dec) / dec;
        var tick = progress < duration;
        callback({
            value: frameVal,
            progress: progress,
            timestamp: timestamp,
            finished: !tick
        });
        if (tick) {
            return requestAnimationFrame(function (val) { return runCount(val); });
        }
    }
    return requestAnimationFrame(function (timestamp) {
        startTime = timestamp;
        return runCount(timestamp);
    });
}
/**
 * Determine decimals places
 *
 * @export
 * @param {any} countTo
 * @returns
 */
function decimalChecker(countTo) {
    var endVal = Number(countTo);
    if (endVal % 1 !== 0 && Math.abs(endVal) <= 10) {
        return 2;
    }
    return 0;
}

/**
 * Count up component
 *
 * Loosely inspired by:
 *  - https://github.com/izupet/angular2-counto
 *  - https://inorganik.github.io/countUp.js/
 *
 * @export
 * @class CountUpDirective
 */
var CountUpDirective = /** @class */ (function () {
    function CountUpDirective(cd, element) {
        this.cd = cd;
        this.countDuration = 1;
        this.countPrefix = '';
        this.countSuffix = '';
        this.countChange = new EventEmitter();
        this.countFinish = new EventEmitter();
        this.value = '';
        this._countDecimals = 0;
        this._countTo = 0;
        this._countFrom = 0;
        this.nativeElement = element.nativeElement;
    }
    Object.defineProperty(CountUpDirective.prototype, "countDecimals", {
        get: function () {
            if (this._countDecimals)
                return this._countDecimals;
            return decimalChecker(this.countTo);
        },
        set: function (val) {
            this._countDecimals = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CountUpDirective.prototype, "countTo", {
        get: function () {
            return this._countTo;
        },
        set: function (val) {
            this._countTo = parseFloat(val);
            this.start();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CountUpDirective.prototype, "countFrom", {
        get: function () {
            return this._countFrom;
        },
        set: function (val) {
            this._countFrom = parseFloat(val);
            this.start();
        },
        enumerable: true,
        configurable: true
    });
    CountUpDirective.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationReq);
    };
    CountUpDirective.prototype.start = function () {
        var _this = this;
        cancelAnimationFrame(this.animationReq);
        var valueFormatting = this.valueFormatting || (function (value) { return "" + _this.countPrefix + value.toLocaleString() + _this.countSuffix; });
        var callback = function (_a) {
            var value = _a.value, progress = _a.progress, finished = _a.finished;
            _this.value = valueFormatting(value);
            _this.cd.markForCheck();
            if (!finished)
                _this.countChange.emit({ value: _this.value, progress: progress });
            if (finished)
                _this.countFinish.emit({ value: _this.value, progress: progress });
        };
        this.animationReq = count(this.countFrom, this.countTo, this.countDecimals, this.countDuration, callback);
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CountUpDirective.prototype, "countDuration", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CountUpDirective.prototype, "countPrefix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CountUpDirective.prototype, "countSuffix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], CountUpDirective.prototype, "countDecimals", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CountUpDirective.prototype, "countTo", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CountUpDirective.prototype, "countFrom", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "countChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "countFinish", void 0);
    CountUpDirective = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object, typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object])
    ], CountUpDirective);
CountUpDirective.ɵfac = function CountUpDirective_Factory(t) { return new (t || CountUpDirective)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)); };
CountUpDirective.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CountUpDirective, selectors: [["", "ngx-charts-count-up", ""]], inputs: { countDuration: "countDuration", countPrefix: "countPrefix", countSuffix: "countSuffix", countDecimals: "countDecimals", countTo: "countTo", countFrom: "countFrom", valueFormatting: "valueFormatting" }, outputs: { countChange: "countChange", countFinish: "countFinish" }, attrs: _c20, decls: 1, vars: 1, template: function CountUpDirective_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.value);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountUpDirective, [{
        type: Component,
        args: [{
                selector: '[ngx-charts-count-up]',
                template: "{{value}}"
            }]
    }], function () { return [{ type: typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }]; }, { countDuration: [{
            type: Input
        }], countPrefix: [{
            type: Input
        }], countSuffix: [{
            type: Input
        }], countChange: [{
            type: Output
        }], countFinish: [{
            type: Output
        }], countDecimals: [{
            type: Input
        }], countTo: [{
            type: Input
        }], countFrom: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }] }); })();
    return CountUpDirective;
}());

var COMPONENTS = [
    AreaComponent,
    BaseChartComponent,
    CountUpDirective,
    TooltipArea,
    ChartComponent,
    LegendComponent,
    LegendEntryComponent,
    ScaleLegendComponent,
    CircleComponent,
    CircleSeriesComponent,
    GridPanelComponent,
    GridPanelSeriesComponent,
    SvgLinearGradientComponent,
    SvgRadialGradientComponent,
    Timeline,
    AdvancedLegendComponent
];
var ChartCommonModule = /** @class */ (function () {
    function ChartCommonModule() {
    }
ChartCommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartCommonModule });
ChartCommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChartCommonModule_Factory(t) { return new (t || ChartCommonModule)(); }, imports: [[
            CommonModule,
            AxesModule,
            TooltipModule
        ],
        CommonModule,
        AxesModule,
        TooltipModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartCommonModule, { declarations: function () { return [AreaComponent,
        BaseChartComponent,
        CountUpDirective,
        TooltipArea,
        ChartComponent,
        LegendComponent,
        LegendEntryComponent,
        ScaleLegendComponent,
        CircleComponent,
        CircleSeriesComponent,
        GridPanelComponent,
        GridPanelSeriesComponent,
        SvgLinearGradientComponent,
        SvgRadialGradientComponent,
        Timeline,
        AdvancedLegendComponent]; }, imports: function () { return [CommonModule,
        AxesModule,
        TooltipModule]; }, exports: function () { return [CommonModule,
        AxesModule,
        TooltipModule,
        AreaComponent,
        BaseChartComponent,
        CountUpDirective,
        TooltipArea,
        ChartComponent,
        LegendComponent,
        LegendEntryComponent,
        ScaleLegendComponent,
        CircleComponent,
        CircleSeriesComponent,
        GridPanelComponent,
        GridPanelSeriesComponent,
        SvgLinearGradientComponent,
        SvgRadialGradientComponent,
        Timeline,
        AdvancedLegendComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartCommonModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    AxesModule,
                    TooltipModule
                ],
                declarations: COMPONENTS.slice(),
                exports: [
                    CommonModule,
                    AxesModule,
                    TooltipModule
                ].concat(COMPONENTS)
            }]
    }], function () { return []; }, null); })();
    return ChartCommonModule;
}());

function calculateViewDimensions(_a) {
    var width = _a.width, height = _a.height, margins = _a.margins, _b = _a.showXAxis, showXAxis = _b === void 0 ? false : _b, _c = _a.showYAxis, showYAxis = _c === void 0 ? false : _c, _d = _a.xAxisHeight, xAxisHeight = _d === void 0 ? 0 : _d, _e = _a.yAxisWidth, yAxisWidth = _e === void 0 ? 0 : _e, _f = _a.showXLabel, showXLabel = _f === void 0 ? false : _f, _g = _a.showYLabel, showYLabel = _g === void 0 ? false : _g, _h = _a.showLegend, showLegend = _h === void 0 ? false : _h, _j = _a.legendType, legendType = _j === void 0 ? 'ordinal' : _j, _k = _a.legendPosition, legendPosition = _k === void 0 ? 'right' : _k, _l = _a.columns, columns = _l === void 0 ? 12 : _l;
    var xOffset = margins[3];
    var chartWidth = width;
    var chartHeight = height - margins[0] - margins[2];
    if (showLegend && legendPosition === 'right') {
        if (legendType === 'ordinal') {
            columns -= 2;
        }
        else {
            columns -= 1;
        }
    }
    chartWidth = chartWidth * columns / 12;
    chartWidth = chartWidth - margins[1] - margins[3];
    if (showXAxis) {
        chartHeight -= 5;
        chartHeight -= xAxisHeight;
        if (showXLabel) {
            // text height + spacing between axis label and tick labels
            var offset = 25 + 5;
            chartHeight -= offset;
        }
    }
    if (showYAxis) {
        chartWidth -= 5;
        chartWidth -= yAxisWidth;
        xOffset += yAxisWidth;
        xOffset += 10;
        if (showYLabel) {
            // text height + spacing between axis label and tick labels
            var offset = 25 + 5;
            chartWidth -= offset;
            xOffset += offset;
        }
    }
    chartWidth = Math.max(0, chartWidth);
    chartHeight = Math.max(0, chartHeight);
    return {
        width: Math.floor(chartWidth),
        height: Math.floor(chartHeight),
        xOffset: Math.floor(xOffset)
    };
}

/**
 * Based on the data, return an array with unique values.
 *
 * @export
 * @returns array
 * @param results
 */
function getUniqueXDomainValues(results) {
    var valueSet = new Set();
    for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
        var result = results_1[_i];
        for (var _a = 0, _b = result.series; _a < _b.length; _a++) {
            var d = _b[_a];
            valueSet.add(d.name);
        }
    }
    return Array.from(valueSet);
}
/**
 * Get the scaleType of enumerable of values.
 * @param values
 * @returns {string} 'time', 'linear' or 'ordinal'
 */
function getScaleType(values, checkDateType) {
    if (checkDateType === void 0) { checkDateType = true; }
    if (checkDateType) {
        var allDates = values.every(function (value) { return value instanceof Date; });
        if (allDates) {
            return 'time';
        }
    }
    var allNumbers = values.every(function (value) { return typeof value === 'number'; });
    if (allNumbers) {
        return 'linear';
    }
    return 'ordinal';
}

var AreaChartComponent = /** @class */ (function (_super) {
    __extends(AreaChartComponent, _super);
    function AreaChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.baseValue = 'auto';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var values = domain.slice();
        if (!this.autoScale) {
            values.push(0);
        }
        if (this.baseValue !== 'auto') {
            values.push(this.baseValue);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, values);
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, values);
        return [min$$1, max$$1];
    };
    AreaChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartComponent.prototype.getScaleType = function (values) {
        var date = true;
        var num = true;
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            if (!this.isDate(value)) {
                date = false;
            }
            if (typeof value !== 'number') {
                num = false;
            }
        }
        if (date) {
            return 'time';
        }
        if (num) {
            return 'linear';
        }
        return 'ordinal';
    };
    AreaChartComponent.prototype.isDate = function (value) {
        if (value instanceof Date) {
            return true;
        }
        return false;
    };
    AreaChartComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "baseValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartComponent.prototype, "hideCircles", null);
AreaChartComponent.ɵfac = function AreaChartComponent_Factory(t) { return ɵAreaChartComponent_BaseFactory(t || AreaChartComponent); };
AreaChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartComponent, selectors: [["ngx-charts-area-chart"]], contentQueries: function AreaChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", state: "state", xAxis: "xAxis", yAxis: "yAxis", baseValue: "baseValue", autoScale: "autoScale", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "activeEntries", "scaleType", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartComponent__svg_g_8_Template, 2, 10, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        AreaSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [baseValue]=\"baseValue\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [baseValue]=\"baseValue\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], state: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], baseValue: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartComponent;
}(BaseChartComponent));

var AreaChartNormalizedComponent = /** @class */ (function (_super) {
    __extends(AreaChartNormalizedComponent, _super);
    function AreaChartNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartNormalizedComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        var _loop_1 = function (i) {
            var val = this_1.xSet[i];
            var d0 = 0;
            var total = 0;
            for (var _i = 0, _a = this_1.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    total += d.value;
                }
            }
            for (var _b = 0, _c = this_1.results; _b < _c.length; _b++) {
                var group = _c[_b];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    d.d0 = d0;
                    d.d1 = d0 + d.value;
                    d0 += d.value;
                }
                else {
                    d = {
                        name: val,
                        value: 0,
                        d0: d0,
                        d1: d0
                    };
                    group.series.push(d);
                }
                if (total > 0) {
                    d.d0 = (d.d0 * 100) / total;
                    d.d1 = (d.d1 * 100) / total;
                }
                else {
                    d.d0 = 0;
                    d.d1 = 0;
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_1(i);
        }
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartNormalizedComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartNormalizedComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartNormalizedComponent.prototype.getYDomain = function () {
        return [0, 100];
    };
    AreaChartNormalizedComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartNormalizedComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartNormalizedComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartNormalizedComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartNormalizedComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartNormalizedComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartNormalizedComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartNormalizedComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartNormalizedComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartNormalizedComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartNormalizedComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartNormalizedComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartNormalizedComponent.prototype, "hideCircles", null);
AreaChartNormalizedComponent.ɵfac = function AreaChartNormalizedComponent_Factory(t) { return ɵAreaChartNormalizedComponent_BaseFactory(t || AreaChartNormalizedComponent); };
AreaChartNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartNormalizedComponent, selectors: [["ngx-charts-area-chart-normalized"]], contentQueries: function AreaChartNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartNormalizedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "activeEntries", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "showPercentage", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartNormalizedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartNormalizedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartNormalizedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartNormalizedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartNormalizedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        AreaSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartNormalizedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [activeEntries]=\"activeEntries\"\n              [gradient]=\"gradient\"\n              normalized=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [showPercentage]=\"true\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            normalized=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartNormalizedComponent;
}(BaseChartComponent));

var AreaChartStackedComponent = /** @class */ (function (_super) {
    __extends(AreaChartStackedComponent, _super);
    function AreaChartStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartStackedComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        var _loop_1 = function (i) {
            var val = this_1.xSet[i];
            var d0 = 0;
            for (var _i = 0, _a = this_1.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    d.d0 = d0;
                    d.d1 = d0 + d.value;
                    d0 += d.value;
                }
                else {
                    d = {
                        name: val,
                        value: 0,
                        d0: d0,
                        d1: d0
                    };
                    group.series.push(d);
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_1(i);
        }
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartStackedComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartStackedComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartStackedComponent.prototype.getYDomain = function () {
        var _this = this;
        var domain = [];
        var _loop_2 = function (i) {
            var val = this_2.xSet[i];
            var sum = 0;
            for (var _i = 0, _a = this_2.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    sum += d.value;
                }
            }
            domain.push(sum);
        };
        var this_2 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_2(i);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    AreaChartStackedComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartStackedComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartStackedComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartStackedComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartStackedComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartStackedComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartStackedComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartStackedComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartStackedComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartStackedComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartStackedComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartStackedComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartStackedComponent.prototype, "hideCircles", null);
AreaChartStackedComponent.ɵfac = function AreaChartStackedComponent_Factory(t) { return ɵAreaChartStackedComponent_BaseFactory(t || AreaChartStackedComponent); };
AreaChartStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartStackedComponent, selectors: [["ngx-charts-area-chart-stacked"]], contentQueries: function AreaChartStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartStackedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "activeEntries", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartStackedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartStackedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartStackedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartStackedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartStackedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        AreaSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartStackedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [activeEntries]=\"activeEntries\"\n              stacked=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            stacked=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartStackedComponent;
}(BaseChartComponent));

var AreaSeriesComponent = /** @class */ (function () {
    function AreaSeriesComponent() {
        this.baseValue = 'auto';
        this.stacked = false;
        this.normalized = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    AreaSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AreaSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradient();
        var currentArea;
        var startingArea;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        if (this.stacked || this.normalized) {
            currentArea = area()
                .x(xProperty)
                .y0(function (d, i) { return _this.yScale(d.d0); })
                .y1(function (d, i) { return _this.yScale(d.d1); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.yScale.range()[0]; })
                .y1(function (d) { return _this.yScale.range()[0]; });
        }
        else {
            currentArea = area()
                .x(xProperty)
                .y0(function () { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })
                .y1(function (d) { return _this.yScale(d.value); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })
                .y1(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); });
        }
        currentArea.curve(this.curve);
        startingArea.curve(this.curve);
        this.opacity = .8;
        var data = this.data.series;
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        this.path = currentArea(data);
        this.startingPath = startingArea(data);
    };
    AreaSeriesComponent.prototype.updateGradient = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            if (this.stacked || this.normalized) {
                var d0values = this.data.series.map(function (d) { return d.d0; });
                var d1values = this.data.series.map(function (d) { return d.d1; });
                var max$$1 = Math.max.apply(Math, d1values);
                var min$$1 = Math.min.apply(Math, d0values);
                this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
            }
            else {
                var values = this.data.series.map(function (d) { return d.value; });
                var max$$1 = Math.max.apply(Math, values);
                this.gradientStops = this.colors.getLinearGradientStops(max$$1);
            }
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
        }
    };
    AreaSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    AreaSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "baseValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "stacked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "normalized", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "select", void 0);
AreaSeriesComponent.ɵfac = function AreaSeriesComponent_Factory(t) { return new (t || AreaSeriesComponent)(); };
AreaSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaSeriesComponent, selectors: [["g", "ngx-charts-area-series", ""]], inputs: { baseValue: "baseValue", stacked: "stacked", normalized: "normalized", animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", gradient: "gradient", curve: "curve", activeEntries: "activeEntries" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c24, decls: 1, vars: 12, consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]], template: function AreaSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    } }, directives: [AreaComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area-series]',
                template: "\n    <svg:g ngx-charts-area\n      class=\"area-series\"\n      [data]=\"data\"\n      [path]=\"path\"\n      [fill]=\"colors.getColor(data.name)\"\n      [stops]=\"gradientStops\"\n      [startingPath]=\"startingPath\"\n      [opacity]=\"opacity\"\n      [gradient]=\"gradient || hasGradient\"\n      [animations]=\"animations\"\n      [class.active]=\"isActive(data)\"\n      [class.inactive]=\"isInactive(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { baseValue: [{
            type: Input
        }], stacked: [{
            type: Input
        }], normalized: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return AreaSeriesComponent;
}());

var AreaChartModule = /** @class */ (function () {
    function AreaChartModule() {
    }
AreaChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AreaChartModule });
AreaChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AreaChartModule_Factory(t) { return new (t || AreaChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AreaChartModule, { declarations: [AreaChartComponent,
        AreaChartNormalizedComponent,
        AreaChartStackedComponent,
        AreaSeriesComponent], imports: [ChartCommonModule], exports: [AreaChartComponent,
        AreaChartNormalizedComponent,
        AreaChartStackedComponent,
        AreaSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AreaChartComponent,
                    AreaChartNormalizedComponent,
                    AreaChartStackedComponent,
                    AreaSeriesComponent
                ],
                exports: [
                    AreaChartComponent,
                    AreaChartNormalizedComponent,
                    AreaChartStackedComponent,
                    AreaSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return AreaChartModule;
}());

var BarComponent = /** @class */ (function () {
    function BarComponent(element) {
        this.roundEdges = true;
        this.gradient = false;
        this.offset = 0;
        this.isActive = false;
        this.animations = true;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.hideBar = false;
        this.element = element.nativeElement;
    }
    BarComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    BarComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
        this.checkToHideBar();
    };
    BarComponent.prototype.loadAnimation = function () {
        this.path = this.getStartingPath();
        setTimeout(this.update.bind(this), 100);
    };
    BarComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.bar');
        var path = this.getPath();
        if (this.animations) {
            node
                .transition()
                .duration(500)
                .attr('d', path);
        }
        else {
            node.attr('d', path);
        }
    };
    BarComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.getStartOpacity()
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    BarComponent.prototype.getStartingPath = function () {
        if (!this.animations) {
            return this.getPath();
        }
        var radius = this.getRadius();
        var path;
        if (this.roundEdges) {
            if (this.orientation === 'vertical') {
                radius = Math.min(this.height, radius);
                path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                radius = Math.min(this.width, radius);
                path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
            }
        }
        else {
            if (this.orientation === 'vertical') {
                path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
            }
        }
        return path;
    };
    BarComponent.prototype.getPath = function () {
        var radius = this.getRadius();
        var path;
        if (this.roundEdges) {
            if (this.orientation === 'vertical') {
                radius = Math.min(this.height, radius);
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                radius = Math.min(this.width, radius);
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
        }
        else {
            path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
        }
        return path;
    };
    BarComponent.prototype.getRadius = function () {
        var radius = 0;
        if (this.roundEdges && this.height > 5 && this.width > 5) {
            radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
        }
        return radius;
    };
    BarComponent.prototype.getStartOpacity = function () {
        if (this.roundEdges) {
            return 0.2;
        }
        else {
            return 0.5;
        }
    };
    Object.defineProperty(BarComponent.prototype, "edges", {
        get: function () {
            var edges = [false, false, false, false];
            if (this.roundEdges) {
                if (this.orientation === 'vertical') {
                    if (this.data.value > 0) {
                        edges = [true, true, false, false];
                    }
                    else {
                        edges = [false, false, true, true];
                    }
                }
                else if (this.orientation === 'horizontal') {
                    if (this.data.value > 0) {
                        edges = [false, true, false, true];
                    }
                    else {
                        edges = [true, false, true, false];
                    }
                }
            }
            return edges;
        },
        enumerable: true,
        configurable: true
    });
    BarComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    BarComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    BarComponent.prototype.checkToHideBar = function () {
        this.hideBar =
            this.noBarWhenZero &&
                ((this.orientation === 'vertical' && this.height === 0) ||
                    (this.orientation === 'horizontal' && this.width === 0));
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "isActive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarComponent.prototype, "stops", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarComponent.prototype, "ariaLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BarComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BarComponent.prototype, "onMouseLeave", null);
    BarComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], BarComponent);
BarComponent.ɵfac = function BarComponent_Factory(t) { return new (t || BarComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
BarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarComponent, selectors: [["g", "ngx-charts-bar", ""]], hostBindings: function BarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function BarComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function BarComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { roundEdges: "roundEdges", gradient: "gradient", offset: "offset", isActive: "isActive", animations: "animations", noBarWhenZero: "noBarWhenZero", fill: "fill", data: "data", width: "width", height: "height", x: "x", y: "y", orientation: "orientation", stops: "stops", ariaLabel: "ariaLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c25, decls: 2, vars: 8, consts: [[4, "ngIf"], ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]], template: function BarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BarComponent__svg_defs_0_Template, 2, 3, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "path", 1);
        ɵngcc0.ɵɵlistener("click", function BarComponent_Template__svg_path_click_1_listener() { return ctx.select.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive)("hidden", ctx.hideBar);
        ɵngcc0.ɵɵattribute("d", ctx.path)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar]',
                template: "\n    <svg:defs *ngIf=\"hasGradient\">\n      <svg:g ngx-charts-svg-linear-gradient [orientation]=\"orientation\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n    </svg:defs>\n    <svg:path\n      class=\"bar\"\n      stroke=\"none\"\n      role=\"img\"\n      tabIndex=\"-1\"\n      [class.active]=\"isActive\"\n      [class.hidden]=\"hideBar\"\n      [attr.d]=\"path\"\n      [attr.aria-label]=\"ariaLabel\"\n      [attr.fill]=\"hasGradient ? gradientFill : fill\"\n      (click)=\"select.emit(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { roundEdges: [{
            type: Input
        }], gradient: [{
            type: Input
        }], offset: [{
            type: Input
        }], isActive: [{
            type: Input
        }], animations: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: Input
        }], data: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], orientation: [{
            type: Input
        }], stops: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }] }); })();
    return BarComponent;
}());

var BarHorizontalComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalComponent, _super);
    function BarHorizontalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontalComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalComponent.prototype.getXScale = function () {
        this.xDomain = this.getXDomain();
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.xDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalComponent.prototype.getYScale = function () {
        this.yDomain = this.getYDomain();
        var spacing = this.yDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.yDomain);
    };
    BarHorizontalComponent.prototype.getXDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var min$$1 = this.xScaleMin ? Math.min.apply(Math, [this.xScaleMin].concat(values)) : Math.min.apply(Math, [0].concat(values));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(values)) : Math.max.apply(Math, [0].concat(values));
        return [min$$1, max$$1];
    };
    BarHorizontalComponent.prototype.getYDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    BarHorizontalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BarHorizontalComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.yDomain;
        }
        else {
            domain = this.xDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.yDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.xDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (event$$1.index === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontalComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalComponent.ɵfac = function BarHorizontalComponent_Factory(t) { return ɵBarHorizontalComponent_BaseFactory(t || BarHorizontalComponent); };
BarHorizontalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalComponent, selectors: [["ngx-charts-bar-horizontal"]], contentQueries: function BarHorizontalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", xScaleMin: "xScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-horizontal", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "activeEntries", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"]], template: function BarHorizontalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("select", function BarHorizontalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function BarHorizontalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarHorizontalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("dataLabelWidthChanged", function BarHorizontalComponent_Template__svg_g_dataLabelWidthChanged_4_listener($event) { return ctx.onDataLabelMaxWidthChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesHorizontal,
        XAxisComponent,
        YAxisComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵBarHorizontalComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontalComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-horizontal\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalComponent;
}(BaseChartComponent));

var BarHorizontal2DComponent = /** @class */ (function (_super) {
    __extends(BarHorizontal2DComponent, _super);
    function BarHorizontal2DComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.groupPadding = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontal2DComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valuesDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontal2DComponent.prototype.getGroupScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    };
    BarHorizontal2DComponent.prototype.getInnerScale = function () {
        var height = this.groupScale.bandwidth();
        var spacing = this.innerDomain.length / (height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, height])
            .paddingInner(spacing)
            .domain(this.innerDomain);
    };
    BarHorizontal2DComponent.prototype.getValueScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valuesDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontal2DComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontal2DComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontal2DComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(domain)) : Math.max.apply(Math, [0].concat(domain));
        return [min$$1, max$$1];
    };
    BarHorizontal2DComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.groupScale(group.label) + ")";
    };
    BarHorizontal2DComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontal2DComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontal2DComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valuesDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontal2DComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valuesDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontal2DComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontal2DComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontal2DComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontal2DComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontal2DComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "groupPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontal2DComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontal2DComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontal2DComponent.prototype, "tooltipTemplate", void 0);
BarHorizontal2DComponent.ɵfac = function BarHorizontal2DComponent_Factory(t) { return ɵBarHorizontal2DComponent_BaseFactory(t || BarHorizontal2DComponent); };
BarHorizontal2DComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontal2DComponent, selectors: [["ngx-charts-bar-horizontal-2d"]], contentQueries: function BarHorizontal2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "horizontal", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", 3, "xScale", "activeEntries", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontal2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontal2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontal2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarHorizontal2DComponent__svg_g_5_Template, 2, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.valueScale)("yScale", ctx.groupScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent,
        GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesHorizontal]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontal2DComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontal2DComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontal2DComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"valueScale\"\n          [yScale]=\"groupScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"horizontal\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            [xScale]=\"valueScale\"\n            [activeEntries]=\"activeEntries\"\n            [yScale]=\"innerScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [roundEdges]=\"roundEdges\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], groupPadding: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontal2DComponent;
}(BaseChartComponent));

var BarHorizontalNormalizedComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalNormalizedComponent, _super);
    function BarHorizontalNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    BarHorizontalNormalizedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalNormalizedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontalNormalizedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontalNormalizedComponent.prototype.getValueDomain = function () {
        return [0, 100];
    };
    BarHorizontalNormalizedComponent.prototype.getYScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarHorizontalNormalizedComponent.prototype.getXScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalNormalizedComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.yScale(group.name) + ")";
    };
    BarHorizontalNormalizedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontalNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontalNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalNormalizedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalNormalizedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalNormalizedComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalNormalizedComponent.ɵfac = function BarHorizontalNormalizedComponent_Factory(t) { return ɵBarHorizontalNormalizedComponent_BaseFactory(t || BarHorizontalNormalizedComponent); };
BarHorizontalNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalNormalizedComponent, selectors: [["ngx-charts-bar-horizontal-normalized"]], contentQueries: function BarHorizontalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarHorizontalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalNormalizedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalNormalizedComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesHorizontal]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontalNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalNormalizedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontalNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalNormalizedComponent;
}(BaseChartComponent));

var BarHorizontalStackedComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalStackedComponent, _super);
    function BarHorizontalStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontalStackedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalStackedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontalStackedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontalStackedComponent.prototype.getValueDomain = function () {
        var domain = [];
        var smallest = 0;
        var biggest = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var smallestSum = 0;
            var biggestSum = 0;
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(domain)) : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    BarHorizontalStackedComponent.prototype.getYScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarHorizontalStackedComponent.prototype.getXScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalStackedComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.yScale(group.name) + ")";
    };
    BarHorizontalStackedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontalStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontalStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalStackedComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontalStackedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalStackedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalStackedComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalStackedComponent.ɵfac = function BarHorizontalStackedComponent_Factory(t) { return ɵBarHorizontalStackedComponent_BaseFactory(t || BarHorizontalStackedComponent); };
BarHorizontalStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalStackedComponent, selectors: [["ngx-charts-bar-horizontal-stacked"]], contentQueries: function BarHorizontalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "stacked", 3, "xScale", "yScale", "colors", "series", "activeEntries", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesHorizontal]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontalStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalStackedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontalStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [activeEntries]=\"activeEntries\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalStackedComponent;
}(BaseChartComponent));

var BarVerticalComponent = /** @class */ (function (_super) {
    __extends(BarVerticalComponent, _super);
    function BarVerticalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVerticalComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVerticalComponent.prototype.getXScale = function () {
        this.xDomain = this.getXDomain();
        var spacing = this.xDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .range([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.xDomain);
    };
    BarVerticalComponent.prototype.getYScale = function () {
        this.yDomain = this.getYDomain();
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.yDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalComponent.prototype.getXDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    BarVerticalComponent.prototype.getYDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var min$$1 = this.yScaleMin ? Math.min.apply(Math, [this.yScaleMin].concat(values)) : Math.min.apply(Math, [0].concat(values));
        if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
            min$$1 = Math.min.apply(Math, [min$$1].concat(this.yAxisTicks));
        }
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(values)) : Math.max.apply(Math, [0].concat(values));
        if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
            max$$1 = Math.max.apply(Math, [max$$1].concat(this.yAxisTicks));
        }
        return [min$$1, max$$1];
    };
    BarVerticalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BarVerticalComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.xDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.xDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (event$$1.index === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVerticalComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalComponent.prototype, "tooltipTemplate", void 0);
BarVerticalComponent.ɵfac = function BarVerticalComponent_Factory(t) { return ɵBarVerticalComponent_BaseFactory(t || BarVerticalComponent); };
BarVerticalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalComponent, selectors: [["ngx-charts-bar-vertical"]], contentQueries: function BarVerticalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", yScaleMin: "yScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero", "activate", "deactivate", "select", "dataLabelHeightChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function BarVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("activate", function BarVerticalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarVerticalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("select", function BarVerticalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("dataLabelHeightChanged", function BarVerticalComponent_Template__svg_g_dataLabelHeightChanged_4_listener($event) { return ctx.onDataLabelMaxHeightChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesVerticalComponent,
        XAxisComponent,
        YAxisComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵBarVerticalComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVerticalComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (select)=\"onClick($event)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalComponent;
}(BaseChartComponent));

var BarVertical2DComponent = /** @class */ (function (_super) {
    __extends(BarVertical2DComponent, _super);
    function BarVertical2DComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.scaleType = 'ordinal';
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.groupPadding = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVertical2DComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valuesDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVertical2DComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVertical2DComponent.prototype.getGroupScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    };
    BarVertical2DComponent.prototype.getInnerScale = function () {
        var width = this.groupScale.bandwidth();
        var spacing = this.innerDomain.length / (width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, width])
            .paddingInner(spacing)
            .domain(this.innerDomain);
    };
    BarVertical2DComponent.prototype.getValueScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valuesDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVertical2DComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVertical2DComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVertical2DComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(domain)) : Math.max.apply(Math, [0].concat(domain));
        return [min$$1, max$$1];
    };
    BarVertical2DComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.groupScale(group.label) + ", 0)";
    };
    BarVertical2DComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVertical2DComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVertical2DComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valuesDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVertical2DComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valuesDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVertical2DComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVertical2DComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVertical2DComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVertical2DComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "groupPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVertical2DComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVertical2DComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVertical2DComponent.prototype, "tooltipTemplate", void 0);
BarVertical2DComponent.ɵfac = function BarVertical2DComponent_Factory(t) { return ɵBarVertical2DComponent_BaseFactory(t || BarVertical2DComponent); };
BarVertical2DComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVertical2DComponent, selectors: [["ngx-charts-bar-vertical-2d"]], contentQueries: function BarVertical2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", scaleType: "scaleType", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "vertical", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVertical2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVertical2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVertical2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarVertical2DComponent__svg_g_5_Template, 1, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.groupScale)("yScale", ctx.valueScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent,
        GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesVerticalComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVertical2DComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVertical2DComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVertical2DComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"groupScale\"\n          [yScale]=\"valueScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"vertical\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n          [activeEntries]=\"activeEntries\"\n          [xScale]=\"innerScale\"\n          [yScale]=\"valueScale\"\n          [colors]=\"colors\"\n          [series]=\"group.series\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [seriesName]=\"group.name\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event, group)\"\n          (activate)=\"onActivate($event, group)\"\n          (deactivate)=\"onDeactivate($event, group)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], groupPadding: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVertical2DComponent;
}(BaseChartComponent));

var BarVerticalNormalizedComponent = /** @class */ (function (_super) {
    __extends(BarVerticalNormalizedComponent, _super);
    function BarVerticalNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    BarVerticalNormalizedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarVerticalNormalizedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVerticalNormalizedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVerticalNormalizedComponent.prototype.getValueDomain = function () {
        return [0, 100];
    };
    BarVerticalNormalizedComponent.prototype.getXScale = function () {
        var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarVerticalNormalizedComponent.prototype.getYScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalNormalizedComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.xScale(group.name) + ", 0)";
    };
    BarVerticalNormalizedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVerticalNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVerticalNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalNormalizedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalNormalizedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalNormalizedComponent.prototype, "tooltipTemplate", void 0);
BarVerticalNormalizedComponent.ɵfac = function BarVerticalNormalizedComponent_Factory(t) { return ɵBarVerticalNormalizedComponent_BaseFactory(t || BarVerticalNormalizedComponent); };
BarVerticalNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalNormalizedComponent, selectors: [["ngx-charts-bar-vertical-normalized"]], contentQueries: function BarVerticalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarVerticalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalNormalizedComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalNormalizedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesVerticalComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVerticalNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalNormalizedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVerticalNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalNormalizedComponent;
}(BaseChartComponent));

var BarVerticalStackedComponent = /** @class */ (function (_super) {
    __extends(BarVerticalStackedComponent, _super);
    function BarVerticalStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVerticalStackedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVerticalStackedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVerticalStackedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVerticalStackedComponent.prototype.getValueDomain = function () {
        var domain = [];
        var smallest = 0;
        var biggest = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var smallestSum = 0;
            var biggestSum = 0;
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(domain)) : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    BarVerticalStackedComponent.prototype.getXScale = function () {
        var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarVerticalStackedComponent.prototype.getYScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalStackedComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVerticalStackedComponent.prototype.groupTransform = function (group) {
        return "translate(" + (this.xScale(group.name) || 0) + ", 0)";
    };
    BarVerticalStackedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVerticalStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVerticalStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalStackedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalStackedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalStackedComponent.prototype, "tooltipTemplate", void 0);
BarVerticalStackedComponent.ɵfac = function BarVerticalStackedComponent_Factory(t) { return ɵBarVerticalStackedComponent_BaseFactory(t || BarVerticalStackedComponent); };
BarVerticalStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalStackedComponent, selectors: [["ngx-charts-bar-vertical-stacked"]], contentQueries: function BarVerticalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "stacked", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVerticalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesVerticalComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVerticalStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalStackedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVerticalStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalStackedComponent;
}(BaseChartComponent));

var D0Types;
(function (D0Types) {
    D0Types["positive"] = "positive";
    D0Types["negative"] = "negative";
})(D0Types || (D0Types = {}));
var SeriesVerticalComponent = /** @class */ (function () {
    function SeriesVerticalComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelHeightChanged = new EventEmitter();
        this.barsForDataLabels = [];
    }
    SeriesVerticalComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesVerticalComponent.prototype.update = function () {
        var _this = this;
        var _a;
        this.updateTooltipSettings();
        var width;
        if (this.series.length) {
            width = this.xScale.bandwidth();
        }
        width = Math.round(width);
        var yScaleMin = Math.max(this.yScale.domain()[0], 0);
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                width: width,
                formattedLabel: formattedLabel,
                height: 0,
                x: 0,
                y: 0
            };
            if (_this.type === 'standard') {
                bar.height = Math.abs(_this.yScale(value) - _this.yScale(yScaleMin));
                bar.x = _this.xScale(label);
                if (value < 0) {
                    bar.y = _this.yScale(0);
                }
                else {
                    bar.y = _this.yScale(value);
                }
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                bar.x = 0;
                bar.y = _this.yScale(offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                bar.x = 0;
                bar.y = _this.yScale(offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + escapeLabel(tooltipLabel) + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesVerticalComponent.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            if (section.total > 0) {
                section.height = this.yScale(totalPositive);
            }
            else {
                section.height = this.yScale(totalNegative);
            }
            section.width = this.xScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(d.label);
                section.y = _this.yScale(0);
                section.height = _this.yScale(section.total) - _this.yScale(0);
                section.width = _this.xScale.bandwidth();
                return section;
            });
        }
    };
    SeriesVerticalComponent.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesVerticalComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesVerticalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    SeriesVerticalComponent.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesVerticalComponent.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesVerticalComponent.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SeriesVerticalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SeriesVerticalComponent.prototype, "seriesName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], SeriesVerticalComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dataLabelHeightChanged", void 0);
SeriesVerticalComponent.ɵfac = function SeriesVerticalComponent_Factory(t) { return new (t || SeriesVerticalComponent)(); };
SeriesVerticalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesVerticalComponent, selectors: [["g", "ngx-charts-series-vertical", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c26, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesVerticalComponent__svg_g_0_Template, 1, 22, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent,
        TooltipDirective,
        BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SeriesVerticalComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-vertical]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'vertical'\"\n      [roundEdges]=\"bar.roundEdges\"\n      [gradient]=\"gradient\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [isActive]=\"isActive(bar.data)\"\n      (select)=\"onClick($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n      [animations]=\"animations\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'vertical'\"\n        (dimensionsChanged)=\"dataLabelHeightChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelHeightChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesVerticalComponent;
}());

var SeriesHorizontal = /** @class */ (function () {
    function SeriesHorizontal() {
        this.barsForDataLabels = [];
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelWidthChanged = new EventEmitter();
    }
    SeriesHorizontal.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesHorizontal.prototype.update = function () {
        var _this = this;
        var _a;
        this.updateTooltipSettings();
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type;
        d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        var xScaleMin = Math.max(this.xScale.domain()[0], 0);
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                formattedLabel: formattedLabel
            };
            bar.height = _this.yScale.bandwidth();
            if (_this.type === 'standard') {
                bar.width = Math.abs(_this.xScale(value) - _this.xScale(xScaleMin));
                if (value < 0) {
                    bar.x = _this.xScale(value);
                }
                else {
                    bar.x = _this.xScale(xScaleMin);
                }
                bar.y = _this.yScale(label);
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + escapeLabel(tooltipLabel) + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesHorizontal.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            // if total is positive then we show it on the right, otherwise on the left
            if (section.total > 0) {
                section.width = this.xScale(totalPositive);
            }
            else {
                section.width = this.xScale(totalNegative);
            }
            section.height = this.yScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(0);
                section.y = _this.yScale(d.label);
                section.width = _this.xScale(section.total) - _this.xScale(0);
                section.height = _this.yScale.bandwidth();
                return section;
            });
        }
    };
    SeriesHorizontal.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesHorizontal.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesHorizontal.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesHorizontal.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesHorizontal.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    SeriesHorizontal.prototype.click = function (data) {
        this.select.emit(data);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SeriesHorizontal.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SeriesHorizontal.prototype, "seriesName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], SeriesHorizontal.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dataLabelWidthChanged", void 0);
SeriesHorizontal.ɵfac = function SeriesHorizontal_Factory(t) { return new (t || SeriesHorizontal)(); };
SeriesHorizontal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesHorizontal, selectors: [["g", "ngx-charts-series-horizontal", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelWidthChanged: "dataLabelWidthChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c27, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesHorizontal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent,
        TooltipDirective,
        BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SeriesHorizontal, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-horizontal]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'horizontal'\"\n      [roundEdges]=\"bar.roundEdges\"\n      (select)=\"click($event)\"\n      [gradient]=\"gradient\"\n      [isActive]=\"isActive(bar.data)\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [animations]=\"animations\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'horizontal'\"\n        (dimensionsChanged)=\"dataLabelWidthChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelWidthChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesHorizontal;
}());

var BarLabelComponent = /** @class */ (function () {
    function BarLabelComponent(element) {
        this.dimensionsChanged = new EventEmitter();
        this.horizontalPadding = 2;
        this.verticalPadding = 5;
        this.element = element.nativeElement;
    }
    BarLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BarLabelComponent.prototype.getSize = function () {
        var h = this.element.getBoundingClientRect().height;
        var w = this.element.getBoundingClientRect().width;
        return { height: h, width: w, negative: this.value < 0 };
    };
    BarLabelComponent.prototype.ngAfterViewInit = function () {
        this.dimensionsChanged.emit(this.getSize());
    };
    BarLabelComponent.prototype.update = function () {
        if (this.valueFormatting) {
            this.formatedValue = this.valueFormatting(this.value);
        }
        else {
            this.formatedValue = formatLabel(this.value);
        }
        if (this.orientation === 'horizontal') {
            this.x = this.barX + this.barWidth;
            if (this.value < 0) {
                this.x = this.x - this.horizontalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.x = this.x + this.horizontalPadding;
                this.textAnchor = 'start';
            }
            this.y = this.barY + this.barHeight / 2;
        }
        else {
            this.x = this.barX + this.barWidth / 2;
            this.y = this.barY + this.barHeight;
            if (this.value < 0) {
                this.y = this.y + this.verticalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.y = this.y - this.verticalPadding;
                this.textAnchor = 'start';
            }
            this.transform = "rotate(-45, " + this.x + " , " + this.y + ")";
        }
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barX", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barY", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "orientation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarLabelComponent.prototype, "dimensionsChanged", void 0);
    BarLabelComponent = __decorate([ __metadata("design:paramtypes", [typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object])
    ], BarLabelComponent);
BarLabelComponent.ɵfac = function BarLabelComponent_Factory(t) { return new (t || BarLabelComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)); };
BarLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarLabelComponent, selectors: [["g", "ngx-charts-bar-label", ""]], inputs: { value: "value", valueFormatting: "valueFormatting", barX: "barX", barY: "barY", barWidth: "barWidth", barHeight: "barHeight", orientation: "orientation" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c28, decls: 2, vars: 5, consts: [["alignment-baseline", "middle", 1, "textDataLabel"]], template: function BarLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.formatedValue, " ");
    } }, styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar-label]',
                template: "  \n    <svg:text   \n      class=\"textDataLabel\" \n      alignment-baseline=\"middle\"     \n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n      [attr.x]=\"x\" \n      [attr.y]=\"y\">\n      {{formatedValue}}     \n    </svg:text>          \n\n  ",
                styles: [".textDataLabel{font-size:11px}"],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }]; }, { dimensionsChanged: [{
            type: Output
        }], value: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], barX: [{
            type: Input
        }], barY: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], barHeight: [{
            type: Input
        }], orientation: [{
            type: Input
        }] }); })();
    return BarLabelComponent;
}());

var BarChartModule = /** @class */ (function () {
    function BarChartModule() {
    }
BarChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BarChartModule });
BarChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BarChartModule_Factory(t) { return new (t || BarChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BarChartModule, { declarations: [BarComponent,
        BarHorizontalComponent,
        BarHorizontal2DComponent,
        BarHorizontalNormalizedComponent,
        BarHorizontalStackedComponent,
        BarVerticalComponent,
        BarVertical2DComponent,
        BarVerticalNormalizedComponent,
        BarVerticalStackedComponent,
        BarLabelComponent,
        SeriesHorizontal,
        SeriesVerticalComponent], imports: [ChartCommonModule], exports: [BarComponent,
        BarHorizontalComponent,
        BarHorizontal2DComponent,
        BarHorizontalNormalizedComponent,
        BarHorizontalStackedComponent,
        BarVerticalComponent,
        BarVertical2DComponent,
        BarVerticalNormalizedComponent,
        BarVerticalStackedComponent,
        BarLabelComponent,
        SeriesHorizontal,
        SeriesVerticalComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ],
                exports: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return BarChartModule;
}());

function getDomain(values, scaleType, autoScale, minVal, maxVal) {
    var domain = [];
    if (scaleType === 'linear') {
        values = values.map(function (v) { return Number(v); });
        if (!autoScale) {
            values.push(0);
        }
    }
    if (scaleType === 'time' || scaleType === 'linear') {
        var min$$1 = minVal ? minVal : Math.min.apply(Math, values);
        var max$$1 = maxVal ? maxVal : Math.max.apply(Math, values);
        domain = [min$$1, max$$1];
    }
    else {
        domain = values;
    }
    return domain;
}
function getScale(domain, range$$1, scaleType, roundDomains) {
    var scale;
    if (scaleType === 'time') {
        scale = scaleTime()
            .range(range$$1)
            .domain(domain);
    }
    else if (scaleType === 'linear') {
        scale = scaleLinear()
            .range(range$$1)
            .domain(domain);
        if (roundDomains) {
            scale = scale.nice();
        }
    }
    else if (scaleType === 'ordinal') {
        scale = scalePoint()
            .range([range$$1[0], range$$1[1]])
            .domain(domain);
    }
    return scale;
}

var BubbleChartComponent = /** @class */ (function (_super) {
    __extends(BubbleChartComponent, _super);
    function BubbleChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.showGridLines = true;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.xAxis = true;
        _this.yAxis = true;
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.maxRadius = 10;
        _this.minRadius = 3;
        _this.schemeType = 'ordinal';
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.scaleType = 'linear';
        _this.margin = [10, 20, 10, 20];
        _this.bubblePadding = [0, 0, 0, 0];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.activeEntries = [];
        return _this;
    }
    BubbleChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.seriesDomain = this.results.map(function (d) { return d.name; });
        this.rDomain = this.getRDomain();
        this.xDomain = this.getXDomain();
        this.yDomain = this.getYDomain();
        this.transform = "translate(" + this.dims.xOffset + "," + this.margin[0] + ")";
        var colorDomain = this.schemeType === 'ordinal' ? this.seriesDomain : this.rDomain;
        this.colors = new ColorHelper(this.scheme, this.schemeType, colorDomain, this.customColors);
        this.data = this.results;
        this.minRadius = Math.max(this.minRadius, 1);
        this.maxRadius = Math.max(this.maxRadius, 1);
        this.rScale = this.getRScale(this.rDomain, [this.minRadius, this.maxRadius]);
        this.bubblePadding = [0, 0, 0, 0];
        this.setScales();
        this.bubblePadding = this.getBubblePadding();
        this.setScales();
        this.legendOptions = this.getLegendOptions();
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    BubbleChartComponent.prototype.hideCircles = function () {
        this.deactivateAll();
    };
    BubbleChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    BubbleChartComponent.prototype.getBubblePadding = function () {
        var yMin = 0;
        var xMin = 0;
        var yMax = this.dims.height;
        var xMax = this.dims.width;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var s = _a[_i];
            for (var _b = 0, _c = s.series; _b < _c.length; _b++) {
                var d = _c[_b];
                var r = this.rScale(d.r);
                var cx = this.xScaleType === 'linear' ? this.xScale(Number(d.x)) : this.xScale(d.x);
                var cy = this.yScaleType === 'linear' ? this.yScale(Number(d.y)) : this.yScale(d.y);
                xMin = Math.max(r - cx, xMin);
                yMin = Math.max(r - cy, yMin);
                yMax = Math.max(cy + r, yMax);
                xMax = Math.max(cx + r, xMax);
            }
        }
        xMax = Math.max(xMax - this.dims.width, 0);
        yMax = Math.max(yMax - this.dims.height, 0);
        return [yMin, xMax, yMax, xMin];
    };
    BubbleChartComponent.prototype.setScales = function () {
        var width = this.dims.width;
        if (this.xScaleMin === undefined && this.xScaleMax === undefined) {
            width = width - this.bubblePadding[1];
        }
        var height = this.dims.height;
        if (this.yScaleMin === undefined && this.yScaleMax === undefined) {
            height = height - this.bubblePadding[2];
        }
        this.xScale = this.getXScale(this.xDomain, width);
        this.yScale = this.getYScale(this.yDomain, height);
    };
    BubbleChartComponent.prototype.getYScale = function (domain, height) {
        return getScale(domain, [height, this.bubblePadding[0]], this.yScaleType, this.roundDomains);
    };
    BubbleChartComponent.prototype.getXScale = function (domain, width) {
        return getScale(domain, [this.bubblePadding[3], width], this.xScaleType, this.roundDomains);
    };
    BubbleChartComponent.prototype.getRScale = function (domain, range$$1) {
        var scale = scaleLinear()
            .range(range$$1)
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BubbleChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            position: this.legendPosition,
            title: undefined
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.rDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BubbleChartComponent.prototype.getXDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.x)) {
                    values.push(d.x);
                }
            }
        }
        this.xScaleType = getScaleType(values);
        return getDomain(values, this.xScaleType, this.autoScale, this.xScaleMin, this.xScaleMax);
    };
    BubbleChartComponent.prototype.getYDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.y)) {
                    values.push(d.y);
                }
            }
        }
        this.yScaleType = getScaleType(values);
        return getDomain(values, this.yScaleType, this.autoScale, this.yScaleMin, this.yScaleMax);
    };
    BubbleChartComponent.prototype.getRDomain = function () {
        var min$$1 = Infinity;
        var max$$1 = -Infinity;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                var value = Number(d.r) || 1;
                min$$1 = Math.min(min$$1, value);
                max$$1 = Math.max(max$$1, value);
            }
        }
        return [min$$1, max$$1];
    };
    BubbleChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BubbleChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BubbleChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BubbleChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    BubbleChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    BubbleChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BubbleChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BubbleChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "maxRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "minRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BubbleChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BubbleChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BubbleChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BubbleChartComponent.prototype, "hideCircles", null);
BubbleChartComponent.ɵfac = function BubbleChartComponent_Factory(t) { return ɵBubbleChartComponent_BaseFactory(t || BubbleChartComponent); };
BubbleChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleChartComponent, selectors: [["ngx-charts-bubble-chart"]], contentQueries: function BubbleChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, hostBindings: function BubbleChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function BubbleChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { minRadius: "minRadius", maxRadius: "maxRadius", showGridLines: "showGridLines", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", autoScale: "autoScale", schemeType: "schemeType", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 20, consts: [[3, "view", "showLegend", "activeEntries", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bubble-chart", "chart"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["x", "0", "y", "0", 1, "bubble-chart-area", 2, "fill", "rgb(255, 0, 0)", "opacity", "0", "cursor", "auto", 3, "mouseenter"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-bubble-series", "", 3, "xScale", "yScale", "rScale", "xScaleType", "yScaleType", "xAxisLabel", "yAxisLabel", "colors", "data", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function BubbleChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, BubbleChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, BubbleChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "rect", 4);
        ɵngcc0.ɵɵlistener("mouseenter", function BubbleChartComponent_Template__svg_rect_mouseenter_7_listener() { return ctx.deactivateAll(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, BubbleChartComponent__svg_g_9_Template, 2, 13, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("activeEntries", ctx.activeEntries)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        BubbleSeriesComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBubbleChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BubbleChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bubble-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [activeEntries]=\"activeEntries\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"bubble-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [showGridLines]=\"showGridLines\"\n          [dims]=\"dims\"\n          [xScale]=\"xScale\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        />\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [showGridLines]=\"showGridLines\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        />\n        <svg:rect\n          class=\"bubble-chart-area\"\n          x=\"0\"\n          y=\"0\"\n          [attr.width]=\"dims.width\"\n          [attr.height]=\"dims.height\"\n          style=\"fill: rgb(255, 0, 0); opacity: 0; cursor: 'auto';\"\n          (mouseenter)=\"deactivateAll()\"\n        />\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of data; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-bubble-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [rScale]=\"rScale\"\n              [xScaleType]=\"xScaleType\"\n              [yScaleType]=\"yScaleType\"\n              [xAxisLabel]=\"xAxisLabel\"\n              [yAxisLabel]=\"yAxisLabel\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event, series)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { minRadius: [{
            type: Input
        }], maxRadius: [{
            type: Input
        }], hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], showGridLines: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BubbleChartComponent;
}(BaseChartComponent));

var BubbleSeriesComponent = /** @class */ (function () {
    function BubbleSeriesComponent() {
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    BubbleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BubbleSeriesComponent.prototype.update = function () {
        this.circles = this.getCircles();
    };
    BubbleSeriesComponent.prototype.getCircles = function () {
        var _this = this;
        var seriesName = this.data.name;
        return this.data.series
            .map(function (d, i) {
            if (typeof d.y !== 'undefined' && typeof d.x !== 'undefined') {
                var y = d.y;
                var x = d.x;
                var r = d.r;
                var radius = _this.rScale(r || 1);
                var tooltipLabel = formatLabel(d.name);
                var cx = _this.xScaleType === 'linear' ? _this.xScale(Number(x)) : _this.xScale(x);
                var cy = _this.yScaleType === 'linear' ? _this.yScale(Number(y)) : _this.yScale(y);
                var color = _this.colors.scaleType === 'linear' ? _this.colors.getColor(r) : _this.colors.getColor(seriesName);
                var isActive = !_this.activeEntries.length ? true : _this.isActive({ name: seriesName });
                var opacity = isActive ? 1 : 0.3;
                var data = Object.assign({}, d, {
                    series: seriesName,
                    name: d.name,
                    value: d.y,
                    x: d.x,
                    radius: d.r
                });
                return {
                    data: data,
                    x: x,
                    y: y,
                    r: r,
                    classNames: ["circle-data-" + i],
                    value: y,
                    label: x,
                    cx: cx,
                    cy: cy,
                    radius: radius,
                    tooltipLabel: tooltipLabel,
                    color: color,
                    opacity: opacity,
                    seriesName: seriesName,
                    isActive: isActive,
                    transform: "translate(" + cx + "," + cy + ")"
                };
            }
        })
            .filter(function (circle) { return circle !== undefined; });
    };
    BubbleSeriesComponent.prototype.getTooltipText = function (circle) {
        var hasRadius = typeof circle.r !== 'undefined';
        var hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
        var hasSeriesName = circle.seriesName && circle.seriesName.length;
        var radiusValue = hasRadius ? formatLabel(circle.r) : '';
        var xAxisLabel = this.xAxisLabel && this.xAxisLabel !== '' ? this.xAxisLabel + ":" : '';
        var yAxisLabel = this.yAxisLabel && this.yAxisLabel !== '' ? this.yAxisLabel + ":" : '';
        var x = formatLabel(circle.x);
        var y = formatLabel(circle.y);
        var name = hasSeriesName && hasTooltipLabel
            ? circle.seriesName + " \u2022 " + circle.tooltipLabel
            : circle.seriesName + circle.tooltipLabel;
        var tooltipTitle = hasSeriesName || hasTooltipLabel ?
            "<span class=\"tooltip-label\">" + escapeLabel(name) + "</span>" : '';
        return "\n      " + tooltipTitle + "\n      <span class=\"tooltip-label\">\n        <label>" + escapeLabel(xAxisLabel) + "</label> " + escapeLabel(x) + "<br />\n        <label>" + escapeLabel(yAxisLabel) + "</label> " + escapeLabel(y) + "\n      </span>\n      <span class=\"tooltip-val\">\n        " + escapeLabel(radiusValue) + "\n      </span>\n    ";
    };
    BubbleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BubbleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    BubbleSeriesComponent.prototype.isVisible = function (circle) {
        if (this.activeEntries.length > 0) {
            return this.isActive({ name: circle.seriesName });
        }
        return circle.opacity !== 0;
    };
    BubbleSeriesComponent.prototype.activateCircle = function (circle) {
        circle.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    BubbleSeriesComponent.prototype.deactivateCircle = function (circle) {
        circle.barVisible = false;
        this.deactivate.emit({ name: this.data.name });
    };
    BubbleSeriesComponent.prototype.trackBy = function (index, circle) {
        return circle.data.series + " " + circle.data.name;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "rScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "xScaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "yScaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleSeriesComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleSeriesComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], BubbleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "deactivate", void 0);
BubbleSeriesComponent.ɵfac = function BubbleSeriesComponent_Factory(t) { return new (t || BubbleSeriesComponent)(); };
BubbleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleSeriesComponent, selectors: [["g", "ngx-charts-bubble-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", rScale: "rScale", xScaleType: "xScaleType", yScaleType: "yScaleType", colors: "colors", visibleValue: "visibleValue", activeEntries: "activeEntries", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c29, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function BubbleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BubbleSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CircleComponent,
        TooltipDirective], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0,
                        transform: 'scale(0)'
                    }),
                    animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bubble-series]',
                template: "\n    <svg:g *ngFor=\"let circle of circles; trackBy: trackBy\">\n      <svg:g [attr.transform]=\"circle.transform\">\n        <svg:g\n          ngx-charts-circle\n          [@animationState]=\"'active'\"\n          class=\"circle\"\n          [cx]=\"0\"\n          [cy]=\"0\"\n          [r]=\"circle.radius\"\n          [fill]=\"circle.color\"\n          [style.opacity]=\"circle.opacity\"\n          [class.active]=\"circle.isActive\"\n          [pointerEvents]=\"'all'\"\n          [data]=\"circle.value\"\n          [classNames]=\"circle.classNames\"\n          (select)=\"onClick(circle.data)\"\n          (activate)=\"activateCircle(circle)\"\n          (deactivate)=\"deactivateCircle(circle)\"\n          ngx-tooltip\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipPlacement]=\"'top'\"\n          [tooltipType]=\"'tooltip'\"\n          [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipContext]=\"circle.data\"\n        />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0,
                                transform: 'scale(0)'
                            }),
                            animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], rScale: [{
            type: Input
        }], xScaleType: [{
            type: Input
        }], yScaleType: [{
            type: Input
        }], colors: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return BubbleSeriesComponent;
}());

var BubbleChartModule = /** @class */ (function () {
    function BubbleChartModule() {
    }
BubbleChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BubbleChartModule });
BubbleChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BubbleChartModule_Factory(t) { return new (t || BubbleChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BubbleChartModule, { declarations: [BubbleChartComponent,
        BubbleSeriesComponent], imports: [ChartCommonModule], exports: [BubbleChartComponent,
        BubbleSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BubbleChartComponent,
                    BubbleSeriesComponent
                ],
                exports: [
                    BubbleChartComponent,
                    BubbleSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return BubbleChartModule;
}());

var ForceDirectedGraphComponent = /** @class */ (function (_super) {
    __extends(ForceDirectedGraphComponent, _super);
    function ForceDirectedGraphComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.force = forceSimulation()
            .force('charge', forceManyBody())
            .force('collide', forceCollide(5))
            .force('x', forceX())
            .force('y', forceY());
        _this.forceLink = forceLink().id(function (node) { return node.value; });
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.nodes = [];
        _this.links = [];
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [0, 0, 0, 0];
        _this.results = [];
        _this.groupResultsBy = function (node) { return node.value; };
        return _this;
    }
    ForceDirectedGraphComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.seriesDomain = this.getSeriesDomain();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "\n      translate(" + (this.dims.xOffset + this.dims.width / 2) + ", " + (this.margin[0] + this.dims.height / 2) + ")\n    ";
        if (this.force) {
            this.force
                .nodes(this.nodes)
                .force('link', this.forceLink.links(this.links))
                .alpha(0.5)
                .restart();
        }
    };
    ForceDirectedGraphComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    ForceDirectedGraphComponent.prototype.onActivate = function (event$$1) {
        if (this.activeEntries.indexOf(event$$1) > -1)
            return;
        this.activeEntries = [event$$1].concat(this.activeEntries);
        this.activate.emit({ value: event$$1, entries: this.activeEntries });
    };
    ForceDirectedGraphComponent.prototype.onDeactivate = function (event$$1) {
        var idx = this.activeEntries.indexOf(event$$1);
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: event$$1, entries: this.activeEntries });
    };
    ForceDirectedGraphComponent.prototype.getSeriesDomain = function () {
        var _this = this;
        return this.nodes
            .map(function (d) { return _this.groupResultsBy(d); })
            .reduce(function (nodes, node) { return (nodes.includes(node) ? nodes : nodes.concat([node])); }, [])
            .sort();
    };
    ForceDirectedGraphComponent.prototype.trackLinkBy = function (index, link) {
        return link.index;
    };
    ForceDirectedGraphComponent.prototype.trackNodeBy = function (index, node) {
        return node.value;
    };
    ForceDirectedGraphComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.seriesDomain, this.customColors);
    };
    ForceDirectedGraphComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            domain: this.seriesDomain,
            colors: this.colors,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    ForceDirectedGraphComponent.prototype.onDragStart = function (node, $event) {
        this.force.alphaTarget(0.3).restart();
        this.draggingNode = node;
        this.draggingStart = { x: $event.x - node.x, y: $event.y - node.y };
        this.draggingNode.fx = $event.x - this.draggingStart.x;
        this.draggingNode.fy = $event.y - this.draggingStart.y;
    };
    ForceDirectedGraphComponent.prototype.onDrag = function ($event) {
        if (!this.draggingNode)
            return;
        this.draggingNode.fx = $event.x - this.draggingStart.x;
        this.draggingNode.fy = $event.y - this.draggingStart.y;
    };
    ForceDirectedGraphComponent.prototype.onDragEnd = function ($event) {
        if (!this.draggingNode)
            return;
        this.force.alphaTarget(0);
        this.draggingNode.fx = undefined;
        this.draggingNode.fy = undefined;
        this.draggingNode = undefined;
    };
    ForceDirectedGraphComponent.prototype.escape = function (label) {
        return escapeLabel(label);
    };
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ForceDirectedGraphComponent.prototype, "force", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ForceDirectedGraphComponent.prototype, "forceLink", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ForceDirectedGraphComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ForceDirectedGraphComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ForceDirectedGraphComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ForceDirectedGraphComponent.prototype, "nodes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof Array !== "undefined" && Array) === "function" ? _a : Object)
    ], ForceDirectedGraphComponent.prototype, "links", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ForceDirectedGraphComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ForceDirectedGraphComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], ForceDirectedGraphComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], ForceDirectedGraphComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('linkTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], ForceDirectedGraphComponent.prototype, "linkTemplate", void 0);
    __decorate([
        ContentChild('nodeTemplate', { static: false }),
        __metadata("design:type", typeof (_e = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _e : Object)
    ], ForceDirectedGraphComponent.prototype, "nodeTemplate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_f = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _f : Object)
    ], ForceDirectedGraphComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ViewChild(ChartComponent, { read: ElementRef, static: false }),
        __metadata("design:type", typeof (_g = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _g : Object)
    ], ForceDirectedGraphComponent.prototype, "chart", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], ForceDirectedGraphComponent.prototype, "groupResultsBy", void 0);
    __decorate([
        HostListener('document:mousemove', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_h = typeof MouseEvent !== "undefined" && MouseEvent) === "function" ? _h : Object]),
        __metadata("design:returntype", void 0)
    ], ForceDirectedGraphComponent.prototype, "onDrag", null);
    __decorate([
        HostListener('document:mouseup', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_j = typeof MouseEvent !== "undefined" && MouseEvent) === "function" ? _j : Object]),
        __metadata("design:returntype", void 0)
    ], ForceDirectedGraphComponent.prototype, "onDragEnd", null);
ForceDirectedGraphComponent.ɵfac = function ForceDirectedGraphComponent_Factory(t) { return ɵForceDirectedGraphComponent_BaseFactory(t || ForceDirectedGraphComponent); };
ForceDirectedGraphComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ForceDirectedGraphComponent, selectors: [["ngx-charts-force-directed-graph"]], contentQueries: function ForceDirectedGraphComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c30, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c31, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linkTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function ForceDirectedGraphComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ChartComponent, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chart = _t.first);
    } }, hostBindings: function ForceDirectedGraphComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousemove", function ForceDirectedGraphComponent_mousemove_HostBindingHandler($event) { return ctx.onDrag($event); }, false, ɵngcc0.ɵɵresolveDocument)("mouseup", function ForceDirectedGraphComponent_mouseup_HostBindingHandler($event) { return ctx.onDragEnd($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { activeEntries: "activeEntries", force: "force", forceLink: "forceLink", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", nodes: "nodes", links: "links", tooltipDisabled: "tooltipDisabled", groupResultsBy: "groupResultsBy" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 12, consts: [[3, "view", "showLegend", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "force-directed-graph", "chart"], [1, "links"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "nodes"], ["ngx-tooltip", "", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "mousedown", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["strokeWidth", "1", "class", "edge", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["strokeWidth", "1", 1, "edge"], ["ngx-tooltip", "", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "mousedown", "click"], ["r", "5", 4, "ngIf"], ["r", "5"]], template: function ForceDirectedGraphComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, ForceDirectedGraphComponent__svg_g_3_Template, 3, 2, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵtemplate(5, ForceDirectedGraphComponent__svg_g_5_Template, 3, 11, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(9, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.links)("ngForTrackBy", ctx.trackLinkBy);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.nodes)("ngForTrackBy", ctx.trackNodeBy);
    } }, directives: [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, TooltipDirective], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".force-directed-graph .edge{stroke:#333}"], encapsulation: 2, changeDetection: 0 });
var ɵForceDirectedGraphComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ForceDirectedGraphComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ForceDirectedGraphComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-force-directed-graph',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"force-directed-graph chart\">\n        <svg:g class=\"links\">\n          <svg:g *ngFor=\"let link of links; trackBy: trackLinkBy\">\n            <ng-template\n              *ngIf=\"linkTemplate\"\n              [ngTemplateOutlet]=\"linkTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: link }\"\n            ></ng-template>\n            <svg:line\n              *ngIf=\"!linkTemplate\"\n              strokeWidth=\"1\"\n              class=\"edge\"\n              [attr.x1]=\"link.source.x\"\n              [attr.y1]=\"link.source.y\"\n              [attr.x2]=\"link.target.x\"\n              [attr.y2]=\"link.target.y\"\n            />\n          </svg:g>\n        </svg:g>\n        <svg:g class=\"nodes\">\n          <svg:g\n            *ngFor=\"let node of nodes; trackBy: trackNodeBy\"\n            [attr.transform]=\"'translate(' + node.x + ',' + node.y + ')'\"\n            [attr.fill]=\"colors.getColor(groupResultsBy(node))\"\n            [attr.stroke]=\"colors.getColor(groupResultsBy(node))\"\n            (mousedown)=\"onDragStart(node, $event)\"\n            (click)=\"onClick({ name: node.value })\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : escape(node.value)\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"node\"\n          >\n            <ng-template\n              *ngIf=\"nodeTemplate\"\n              [ngTemplateOutlet]=\"nodeTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: node }\"\n            ></ng-template>\n            <svg:circle *ngIf=\"!nodeTemplate\" r=\"5\" />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".force-directed-graph .edge{stroke:#333}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { activeEntries: [{
            type: Input
        }], onDrag: [{
            type: HostListener,
            args: ['document:mousemove', ['$event']]
        }], onDragEnd: [{
            type: HostListener,
            args: ['document:mouseup', ['$event']]
        }], force: [{
            type: Input
        }], forceLink: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], nodes: [{
            type: Input
        }], links: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], linkTemplate: [{
            type: ContentChild,
            args: ['linkTemplate', { static: false }]
        }], nodeTemplate: [{
            type: ContentChild,
            args: ['nodeTemplate', { static: false }]
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], chart: [{
            type: ViewChild,
            args: [ChartComponent, { read: ElementRef, static: false }]
        }], groupResultsBy: [{
            type: Input
        }] }); })();
    return ForceDirectedGraphComponent;
}(BaseChartComponent));

var ForceDirectedGraphModule = /** @class */ (function () {
    function ForceDirectedGraphModule() {
    }
ForceDirectedGraphModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ForceDirectedGraphModule });
ForceDirectedGraphModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ForceDirectedGraphModule_Factory(t) { return new (t || ForceDirectedGraphModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ForceDirectedGraphModule, { declarations: [ForceDirectedGraphComponent], imports: [ChartCommonModule], exports: [ForceDirectedGraphComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ForceDirectedGraphModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    ForceDirectedGraphComponent,
                ],
                exports: [
                    ForceDirectedGraphComponent,
                ]
            }]
    }], function () { return []; }, null); })();
    return ForceDirectedGraphModule;
}());

var HeatMapCellComponent = /** @class */ (function () {
    function HeatMapCellComponent(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.element = element.nativeElement;
    }
    HeatMapCellComponent.prototype.ngOnChanges = function (changes) {
        this.transform = "translate(" + this.x + " , " + this.y + ")";
        this.startOpacity = 0.3;
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        this.gradientStops = this.getGradientStops();
        if (this.animations) {
            this.loadAnimation();
        }
    };
    HeatMapCellComponent.prototype.getGradientStops = function () {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    HeatMapCellComponent.prototype.loadAnimation = function () {
        var node = select(this.element).select('.cell');
        node.attr('opacity', 0);
        this.animateToCurrentForm();
    };
    HeatMapCellComponent.prototype.animateToCurrentForm = function () {
        var node = select(this.element).select('.cell');
        node
            .transition()
            .duration(750)
            .attr('opacity', 1);
    };
    HeatMapCellComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    HeatMapCellComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    HeatMapCellComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapCellComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapCellComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeatMapCellComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeatMapCellComponent.prototype, "onMouseLeave", null);
    HeatMapCellComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], HeatMapCellComponent);
HeatMapCellComponent.ɵfac = function HeatMapCellComponent_Factory(t) { return new (t || HeatMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
HeatMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatMapCellComponent, selectors: [["g", "ngx-charts-heat-map-cell", ""]], hostBindings: function HeatMapCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function HeatMapCellComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function HeatMapCellComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { gradient: "gradient", animations: "animations", fill: "fill", x: "x", y: "y", width: "width", height: "height", data: "data", label: "label" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c32, decls: 3, vars: 5, consts: [[1, "cell"], [4, "ngIf"], ["rx", "3", 1, "cell", 2, "cursor", "pointer", 3, "click"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function HeatMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, HeatMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "rect", 2);
        ɵngcc0.ɵɵlistener("click", function HeatMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\">\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        rx=\"3\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"cell\"\n        style=\"cursor: pointer\"\n        (click)=\"onClick()\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], data: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
    return HeatMapCellComponent;
}());

var HeatCellSeriesComponent = /** @class */ (function () {
    function HeatCellSeriesComponent() {
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    HeatCellSeriesComponent.prototype.ngOnInit = function () {
        if (!this.tooltipText) {
            this.tooltipText = this.getTooltipText;
        }
    };
    HeatCellSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    HeatCellSeriesComponent.prototype.update = function () {
        this.cells = this.getCells();
    };
    HeatCellSeriesComponent.prototype.getCells = function () {
        var _this = this;
        var cells = [];
        this.data.map(function (row) {
            row.series.map(function (cell) {
                var value = cell.value;
                cell.series = row.name;
                cells.push({
                    row: row,
                    cell: cell,
                    x: _this.xScale(row.name),
                    y: _this.yScale(cell.name),
                    width: _this.xScale.bandwidth(),
                    height: _this.yScale.bandwidth(),
                    fill: _this.colors.getColor(value),
                    data: value,
                    label: formatLabel(cell.name),
                    series: row.name
                });
            });
        });
        return cells;
    };
    HeatCellSeriesComponent.prototype.getTooltipText = function (_a) {
        var label = _a.label, data = _a.data, series = _a.series;
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(series) + " \u2022 " + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + data.toLocaleString() + "</span>\n    ";
    };
    HeatCellSeriesComponent.prototype.trackBy = function (index, item) {
        return item.tooltipText;
    };
    HeatCellSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], HeatCellSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], HeatCellSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], HeatCellSeriesComponent.prototype, "deactivate", void 0);
HeatCellSeriesComponent.ɵfac = function HeatCellSeriesComponent_Factory(t) { return new (t || HeatCellSeriesComponent)(); };
HeatCellSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatCellSeriesComponent, selectors: [["g", "ngx-charts-heat-map-cell-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", data: "data", colors: "colors", xScale: "xScale", yScale: "yScale", gradient: "gradient", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c33, decls: 1, vars: 2, consts: [["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function HeatCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HeatCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, HeatMapCellComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatCellSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-heat-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [data]=\"c.data\"\n      (select)=\"onClick(c.cell)\"\n      (activate)=\"activate.emit(c.cell)\"\n      (deactivate)=\"deactivate.emit(c.cell)\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"{ series: c.series, name: c.label, value: c.data }\"\n    ></svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], data: [{
            type: Input
        }], colors: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return HeatCellSeriesComponent;
}());

var HeatMapComponent = /** @class */ (function (_super) {
    __extends(HeatMapComponent, _super);
    function HeatMapComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.innerPadding = 8;
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.tooltipDisabled = false;
        _this.activeEntries = [];
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.scaleType = 'linear';
        return _this;
    }
    HeatMapComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.formatDates();
        this.xDomain = this.getXDomain();
        this.yDomain = this.getYDomain();
        this.valueDomain = this.getValueDomain();
        this.scaleType = getScaleType(this.valueDomain, false);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.scaleType,
            legendPosition: this.legendPosition
        });
        if (this.scaleType === 'linear') {
            var min$$1 = this.min;
            var max$$1 = this.max;
            if (!this.min) {
                min$$1 = Math.min.apply(Math, [0].concat(this.valueDomain));
            }
            if (!this.max) {
                max$$1 = Math.max.apply(Math, this.valueDomain);
            }
            this.valueDomain = [min$$1, max$$1];
        }
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.rects = this.getRects();
    };
    HeatMapComponent.prototype.getXDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.name)) {
                domain.push(group.name);
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.name)) {
                    domain.push(d.name);
                }
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getDimension = function (value, index, N, L) {
        if (index === void 0) { index = 0; }
        if (typeof value === 'string') {
            value = value
                .replace('[', '')
                .replace(']', '')
                .replace('px', '')
                .replace('\'', '');
            if (value.includes(',')) {
                value = value.split(',');
            }
        }
        if (Array.isArray(value) && typeof index === 'number') {
            return this.getDimension(value[index], null, N, L);
        }
        if (typeof value === 'string' && value.includes('%')) {
            return +value.replace('%', '') / 100;
        }
        return N / (L / +value + 1);
    };
    HeatMapComponent.prototype.getXScale = function () {
        var f = this.getDimension(this.innerPadding, 0, this.xDomain.length, this.dims.width);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .domain(this.xDomain)
            .paddingInner(f);
    };
    HeatMapComponent.prototype.getYScale = function () {
        var f = this.getDimension(this.innerPadding, 1, this.yDomain.length, this.dims.height);
        return scaleBand()
            .rangeRound([this.dims.height, 0])
            .domain(this.yDomain)
            .paddingInner(f);
    };
    HeatMapComponent.prototype.getRects = function () {
        var _this = this;
        var rects = [];
        this.xDomain.map(function (xVal) {
            _this.yDomain.map(function (yVal) {
                rects.push({
                    x: _this.xScale(xVal),
                    y: _this.yScale(yVal),
                    rx: 3,
                    width: _this.xScale.bandwidth(),
                    height: _this.yScale.bandwidth(),
                    fill: 'rgba(200,200,200,0.03)'
                });
            });
        });
        return rects;
    };
    HeatMapComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    HeatMapComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
    };
    HeatMapComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: this.scaleType,
            domain: this.valueDomain,
            colors: this.scaleType === 'ordinal' ? this.colors : this.colors.scale,
            title: this.scaleType === 'ordinal' ? this.legendTitle : undefined,
            position: this.legendPosition
        };
    };
    HeatMapComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    HeatMapComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    HeatMapComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    HeatMapComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], HeatMapComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], HeatMapComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], HeatMapComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], HeatMapComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "activeEntries", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], HeatMapComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], HeatMapComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], HeatMapComponent.prototype, "tooltipTemplate", void 0);
HeatMapComponent.ɵfac = function HeatMapComponent_Factory(t) { return ɵHeatMapComponent_BaseFactory(t || HeatMapComponent); };
HeatMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatMapComponent, selectors: [["ngx-charts-heat-map"]], contentQueries: function HeatMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", gradient: "gradient", innerPadding: "innerPadding", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", min: "min", max: "max" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 20, consts: [[3, "view", "showLegend", "animations", "legendOptions", "legendLabelClick"], [1, "heat-map", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngx-charts-heat-map-cell-series", "", 3, "xScale", "yScale", "colors", "data", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "select", "activate", "deactivate"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function HeatMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function HeatMapComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, HeatMapComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, HeatMapComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, HeatMapComponent__svg_rect_4_Template, 1, 6, "rect", 4);
        ɵngcc0.ɵɵelementStart(5, "g", 5);
        ɵngcc0.ɵɵlistener("select", function HeatMapComponent_Template__svg_g_select_5_listener($event) { return ctx.onClick($event); })("activate", function HeatMapComponent_Template__svg_g_activate_5_listener($event) { return ctx.onActivate($event, undefined); })("deactivate", function HeatMapComponent_Template__svg_g_deactivate_5_listener($event) { return ctx.onDeactivate($event, undefined); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("animations", ctx.animations)("legendOptions", ctx.legendOptions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.rects);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("data", ctx.results)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, HeatCellSeriesComponent,
        XAxisComponent,
        YAxisComponent], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵHeatMapComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(HeatMapComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatMapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-heat-map',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [animations]=\"animations\"\n      [legendOptions]=\"legendOptions\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"heat-map chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:rect\n          *ngFor=\"let rect of rects\"\n          [attr.x]=\"rect.x\"\n          [attr.y]=\"rect.y\"\n          [attr.rx]=\"rect.rx\"\n          [attr.width]=\"rect.width\"\n          [attr.height]=\"rect.height\"\n          [attr.fill]=\"rect.fill\"\n        />\n        <svg:g\n          ngx-charts-heat-map-cell-series\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [data]=\"results\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event, undefined)\"\n          (deactivate)=\"onDeactivate($event, undefined)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], gradient: [{
            type: Input
        }], innerPadding: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return HeatMapComponent;
}(BaseChartComponent));

var HeatMapModule = /** @class */ (function () {
    function HeatMapModule() {
    }
HeatMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HeatMapModule });
HeatMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HeatMapModule_Factory(t) { return new (t || HeatMapModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeatMapModule, { declarations: [HeatMapCellComponent,
        HeatCellSeriesComponent,
        HeatMapComponent], imports: [ChartCommonModule], exports: [HeatMapCellComponent,
        HeatCellSeriesComponent,
        HeatMapComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatMapModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    HeatMapCellComponent,
                    HeatCellSeriesComponent,
                    HeatMapComponent
                ],
                exports: [
                    HeatMapCellComponent,
                    HeatCellSeriesComponent,
                    HeatMapComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return HeatMapModule;
}());

var LineComponent = /** @class */ (function () {
    function LineComponent(element) {
        this.element = element;
        this.fill = 'none';
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
    }
    LineComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.initialized = true;
            this.initialPath = this.path;
        }
        else {
            this.updatePathEl();
        }
    };
    LineComponent.prototype.updatePathEl = function () {
        var node = select(this.element.nativeElement).select('.line');
        if (this.animations) {
            node
                .transition().duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "stroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "select", void 0);
    LineComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], LineComponent);
LineComponent.ɵfac = function LineComponent_Factory(t) { return new (t || LineComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
LineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineComponent, selectors: [["g", "ngx-charts-line", ""]], inputs: { fill: "fill", animations: "animations", path: "path", stroke: "stroke", data: "data" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c35, decls: 1, vars: 4, consts: [["stroke-width", "1.5px", 1, "line"]], template: function LineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@animationState", "active");
        ɵngcc0.ɵɵattribute("d", ctx.initialPath)("fill", ctx.fill)("stroke", ctx.stroke);
    } }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        strokeDasharray: 2000,
                        strokeDashoffset: 2000
                    }),
                    animate(1000, style({
                        strokeDashoffset: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line]',
                template: "\n    <svg:path\n      [@animationState]=\"'active'\"\n      class=\"line\"\n      [attr.d]=\"initialPath\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      stroke-width=\"1.5px\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                strokeDasharray: 2000,
                                strokeDashoffset: 2000
                            }),
                            animate(1000, style({
                                strokeDashoffset: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { fill: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], path: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return LineComponent;
}());

var LineChartComponent = /** @class */ (function (_super) {
    __extends(LineChartComponent, _super);
    function LineChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.showRefLines = false;
        _this.showRefLabels = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    LineChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    LineChartComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    LineChartComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    LineChartComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    this.hasRange = true;
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    this.hasRange = true;
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        var values = domain.slice();
        if (!this.autoScale) {
            values.push(0);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, values);
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, values);
        return [min$$1, max$$1];
    };
    LineChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    LineChartComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime()
                .range([0, width])
                .domain(domain);
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear()
                .range([0, width])
                .domain(domain);
            if (this.roundDomains) {
                scale = scale.nice();
            }
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint()
                .range([0, width])
                .padding(0.1)
                .domain(domain);
        }
        return scale;
    };
    LineChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    LineChartComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    LineChartComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    LineChartComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    LineChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    LineChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    LineChartComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    LineChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    LineChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    LineChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    LineChartComponent.prototype.onActivate = function (item) {
        this.deactivateAll();
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item];
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    LineChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    LineChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showRefLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LineChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LineChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], LineChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], LineChartComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LineChartComponent.prototype, "hideCircles", null);
LineChartComponent.ɵfac = function LineChartComponent_Factory(t) { return ɵLineChartComponent_BaseFactory(t || LineChartComponent); };
LineChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineChartComponent, selectors: [["ngx-charts-line-chart"]], contentQueries: function LineChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function LineChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showRefLines: "showRefLines", referenceLines: "referenceLines", showRefLabels: "showRefLabels", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "line-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "hasRange", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "visibleValue", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "curve", "hasRange", "animations"]], template: function LineChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function LineChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, LineChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, LineChartComponent__svg_g_6_Template, 1, 12, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, LineChartComponent__svg_g_8_Template, 2, 11, "g", 4);
        ɵngcc0.ɵɵtemplate(9, LineChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, LineChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        LineSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵLineChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LineChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-line-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"line-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [referenceLines]=\"referenceLines\"\n          [showRefLines]=\"showRefLines\"\n          [showRefLabels]=\"showRefLabels\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-line-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [hasRange]=\"hasRange\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [activeEntries]=\"activeEntries\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [scaleType]=\"scaleType\"\n        [legend]=\"legend\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-line-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [curve]=\"curve\"\n            [hasRange]=\"hasRange\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return LineChartComponent;
}(BaseChartComponent));

var LineSeriesComponent = /** @class */ (function () {
    function LineSeriesComponent() {
        this.animations = true;
    }
    LineSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LineSeriesComponent.prototype.update = function () {
        this.updateGradients();
        var data = this.sortData(this.data.series);
        var lineGen = this.getLineGenerator();
        this.path = lineGen(data) || '';
        var areaGen = this.getAreaGenerator();
        this.areaPath = areaGen(data) || '';
        if (this.hasRange) {
            var range$$1 = this.getRangeGenerator();
            this.outerPath = range$$1(data) || '';
        }
        if (this.hasGradient) {
            this.stroke = this.gradientUrl;
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            if (max$$1 === min$$1) {
                this.stroke = this.colors.getColor(max$$1);
            }
        }
        else {
            this.stroke = this.colors.getColor(this.data.name);
        }
    };
    LineSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return line()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getRangeGenerator = function () {
        var _this = this;
        return area()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y0(function (d) { return _this.yScale(typeof d.min === 'number' ? d.min : d.value); })
            .y1(function (d) { return _this.yScale(typeof d.max === 'number' ? d.max : d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getAreaGenerator = function () {
        var _this = this;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        return area()
            .x(xProperty)
            .y0(function () { return _this.yScale.range()[0]; })
            .y1(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        return data;
    };
    LineSeriesComponent.prototype.updateGradients = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
            this.areaGradientStops = this.colors.getLinearGradientStops(max$$1);
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
            this.areaGradientStops = undefined;
        }
    };
    LineSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    LineSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineSeriesComponent.prototype, "hasRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineSeriesComponent.prototype, "animations", void 0);
LineSeriesComponent.ɵfac = function LineSeriesComponent_Factory(t) { return new (t || LineSeriesComponent)(); };
LineSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineSeriesComponent, selectors: [["g", "ngx-charts-line-series", ""]], inputs: { animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", hasRange: "hasRange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c36, decls: 6, vars: 22, consts: [["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]], template: function LineSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, LineSeriesComponent__svg_g_2_Template, 1, 2, "g", 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 1);
        ɵngcc0.ɵɵelement(4, "g", 2);
        ɵngcc0.ɵɵtemplate(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRange);
    } }, directives: [ɵngcc1.NgIf, AreaComponent,
        LineComponent,
        SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line-series]',
                template: "\n    <svg:g>\n      <defs>\n        <svg:g ngx-charts-svg-linear-gradient *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g ngx-charts-area\n        class=\"line-highlight\"\n        [data]=\"data\"\n        [path]=\"areaPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [opacity]=\"0.25\"\n        [startOpacity]=\"0\"\n        [gradient]=\"true\"\n        [stops]=\"areaGradientStops\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [animations]=\"animations\"\n      />\n      <svg:g ngx-charts-line\n        class=\"line-series\"\n        [data]=\"data\"\n        [path]=\"path\"\n        [stroke]=\"stroke\"\n        [animations]=\"animations\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n      />\n     <svg:g ngx-charts-area\n        *ngIf=\"hasRange\"\n        class=\"line-series-range\"\n        [data]=\"data\"\n        [path]=\"outerPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [opacity]=\"rangeFillOpacity\"\n        [animations]=\"animations\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], hasRange: [{
            type: Input
        }] }); })();
    return LineSeriesComponent;
}());

var LineChartModule = /** @class */ (function () {
    function LineChartModule() {
    }
LineChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LineChartModule });
LineChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LineChartModule_Factory(t) { return new (t || LineChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LineChartModule, { declarations: [LineComponent,
        LineChartComponent,
        LineSeriesComponent], imports: [ChartCommonModule], exports: [LineComponent,
        LineChartComponent,
        LineSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    LineComponent,
                    LineChartComponent,
                    LineSeriesComponent
                ],
                exports: [
                    LineComponent,
                    LineChartComponent,
                    LineSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return LineChartModule;
}());

var twoPI = 2 * Math.PI;
var PolarChartComponent = /** @class */ (function (_super) {
    __extends(PolarChartComponent, _super);
    function PolarChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveCardinalClosed;
        _this.activeEntries = [];
        _this.rangeFillOpacity = 0.15;
        _this.trimYAxisTicks = true;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.showSeriesOnHover = true;
        _this.gradient = false;
        _this.yAxisMinScale = 0;
        _this.labelTrim = true;
        _this.labelTrimSize = 10;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    PolarChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.setDims();
        this.setScales();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.setTicks();
    };
    PolarChartComponent.prototype.setDims = function () {
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        var halfWidth = Math.floor(this.dims.width / 2);
        var halfHeight = Math.floor(this.dims.height / 2);
        var outerRadius = (this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5));
        var yOffset = Math.max(0, halfHeight - outerRadius);
        this.yAxisDims = __assign({}, this.dims, { width: halfWidth });
        this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
        this.transformYAxis = "translate(0, " + yOffset + ")";
        this.labelOffset = this.dims.height + 40;
        this.transformPlot = "translate(" + halfWidth + ", " + halfHeight + ")";
    };
    PolarChartComponent.prototype.setScales = function () {
        var xValues = this.getXValues();
        this.scaleType = getScaleType(xValues);
        this.xDomain = this.filteredDomain || this.getXDomain(xValues);
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, twoPI);
        this.yScale = this.getYScale(this.yDomain, this.outerRadius);
        this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
    };
    PolarChartComponent.prototype.setTicks = function () {
        var _this = this;
        var tickFormat;
        if (this.xAxisTickFormatting) {
            tickFormat = this.xAxisTickFormatting;
        }
        else if (this.xScale.tickFormat) {
            tickFormat = this.xScale.tickFormat.apply(this.xScale, [5]);
        }
        else {
            tickFormat = function (d) {
                if (isDate(d)) {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var outerRadius = this.outerRadius;
        var s = 1.1;
        this.thetaTicks = this.xDomain.map(function (d) {
            var startAngle = _this.xScale(d);
            var dd = s * outerRadius * (startAngle > Math.PI ? -1 : 1);
            var label = tickFormat(d);
            var startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
            var pos = [dd, s * startPos[1]];
            return {
                innerRadius: 0,
                outerRadius: outerRadius,
                startAngle: startAngle,
                endAngle: startAngle,
                value: outerRadius,
                label: label,
                startPos: startPos,
                pos: pos
            };
        });
        var minDistance = 10;
        for (var i = 0; i < this.thetaTicks.length - 1; i++) {
            var a = this.thetaTicks[i];
            for (var j = i + 1; j < this.thetaTicks.length; j++) {
                var b = this.thetaTicks[j];
                if (b.pos[0] * a.pos[0] > 0) {
                    var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map(function (d) { return _this.yScale(d); });
    };
    PolarChartComponent.prototype.getXValues = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        return values;
    };
    PolarChartComponent.prototype.getXDomain = function (values) {
        if (values === void 0) { values = this.getXValues(); }
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            return [min$$1, max$$1];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            return [min$$1, max$$1];
        }
        return values;
    };
    PolarChartComponent.prototype.getYValues = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        return domain;
    };
    PolarChartComponent.prototype.getYDomain = function (domain) {
        if (domain === void 0) { domain = this.getYValues(); }
        var min$$1 = Math.min.apply(Math, domain);
        var max$$1 = Math.max.apply(Math, [this.yAxisMinScale].concat(domain));
        min$$1 = Math.max(0, min$$1);
        if (!this.autoScale) {
            min$$1 = Math.min(0, min$$1);
        }
        return [min$$1, max$$1];
    };
    PolarChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    PolarChartComponent.prototype.getXScale = function (domain, width) {
        switch (this.scaleType) {
            case 'time':
                return scaleTime()
                    .range([0, width])
                    .domain(domain);
            case 'linear':
                var scale = scaleLinear()
                    .range([0, width])
                    .domain(domain);
                return this.roundDomains ? scale.nice() : scale;
            default:
                return scalePoint()
                    .range([0, width - twoPI / domain.length])
                    .padding(0)
                    .domain(domain);
        }
    };
    PolarChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([0, height])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    PolarChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    PolarChartComponent.prototype.setColors = function () {
        var domain = this.schemeType === 'ordinal' ? this.seriesDomain : this.yDomain.reverse();
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    PolarChartComponent.prototype.getLegendOptions = function () {
        if (this.schemeType === 'ordinal') {
            return {
                scaleType: this.schemeType,
                colors: this.colors,
                domain: this.seriesDomain,
                title: this.legendTitle,
                position: this.legendPosition
            };
        }
        return {
            scaleType: this.schemeType,
            colors: this.colors.scale,
            domain: this.yDomain,
            title: undefined,
            position: this.legendPosition
        };
    };
    PolarChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    PolarChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    PolarChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = this.showSeriesOnHover ? [item].concat(this.activeEntries) : this.activeEntries;
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PolarChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    PolarChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    PolarChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PolarChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showSeriesOnHover", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "yAxisMinScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "labelTrim", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "labelTrimSize", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PolarChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PolarChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PolarChartComponent.prototype, "tooltipTemplate", void 0);
PolarChartComponent.ɵfac = function PolarChartComponent_Factory(t) { return ɵPolarChartComponent_BaseFactory(t || PolarChartComponent); };
PolarChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarChartComponent, selectors: [["ngx-charts-polar-chart"]], contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimYAxisTicks: "trimYAxisTicks", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showSeriesOnHover: "showSeriesOnHover", gradient: "gradient", yAxisMinScale: "yAxisMinScale", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 18, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], ["ngx-charts-polar-series", "", 3, "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function PolarChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelement(3, "circle", 2);
        ɵngcc0.ɵɵtemplate(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵtemplate(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, PolarChartComponent__svg_g_6_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5);
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, PolarChartComponent__svg_g_9_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(15, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("r", ctx.outerRadius);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGridLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis && ctx.showXAxisLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, PieLabelComponent,
        YAxisComponent,
        AxisLabelComponent,
        PolarSeriesComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area{pointer-events:none}.polar-series-path{pointer-events:none}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵPolarChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PolarChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-polar-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g class=\"polar-chart chart\" [attr.transform]=\"transform\">\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:circle class=\"polar-chart-background\" cx=\"0\" cy=\"0\" [attr.r]=\"this.outerRadius\" />\n          <svg:g *ngIf=\"showGridLines\">\n            <svg:circle\n              *ngFor=\"let r of radiusTicks\"\n              class=\"gridline-path radial-gridline-path\"\n              cx=\"0\"\n              cy=\"0\"\n              [attr.r]=\"r\"\n            />\n          </svg:g>\n          <svg:g *ngIf=\"xAxis\">\n            <svg:g\n              ngx-charts-pie-label\n              *ngFor=\"let tick of thetaTicks\"\n              [data]=\"tick\"\n              [radius]=\"outerRadius\"\n              [label]=\"tick.label\"\n              [max]=\"outerRadius\"\n              [value]=\"showGridLines ? 1 : outerRadius\"\n              [explodeSlices]=\"true\"\n              [animations]=\"animations\"\n              [labelTrim]=\"labelTrim\"\n              [labelTrimSize]=\"labelTrimSize\"\n            ></svg:g>\n          </svg:g>\n        </svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          [attr.transform]=\"transformYAxis\"\n          *ngIf=\"yAxis\"\n          [yScale]=\"yAxisScale\"\n          [dims]=\"yAxisDims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-axis-label\n          *ngIf=\"xAxis && showXAxisLabel\"\n          [label]=\"xAxisLabel\"\n          [offset]=\"labelOffset\"\n          [orient]=\"'bottom'\"\n          [height]=\"dims.height\"\n          [width]=\"dims.width\"\n        ></svg:g>\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-polar-series\n              [gradient]=\"gradient\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [animations]=\"animations\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [
                    ".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}",
                    ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}",
                    ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area{pointer-events:none}.polar-series-path{pointer-events:none}"
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showSeriesOnHover: [{
            type: Input
        }], gradient: [{
            type: Input
        }], yAxisMinScale: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PolarChartComponent;
}(BaseChartComponent));

var PolarSeriesComponent = /** @class */ (function () {
    function PolarSeriesComponent() {
        this.tooltipDisabled = false;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.circleRadius = 3;
    }
    PolarSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PolarSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradients();
        var line$$1 = this.getLineGenerator();
        var data = this.sortData(this.data.series);
        var seriesName = this.data.name;
        var linearScaleType = this.colors.scaleType === 'linear';
        var min$$1 = this.yScale.domain()[0];
        this.seriesColor = this.colors.getColor(linearScaleType ? min$$1 : seriesName);
        this.path = line$$1(data) || '';
        this.circles = data.map(function (d) {
            var a = _this.getAngle(d);
            var r = _this.getRadius(d);
            var value = d.value;
            var color = _this.colors.getColor(linearScaleType ? Math.abs(value) : seriesName);
            var cData = Object.assign({}, d, {
                series: seriesName,
                value: value,
                name: d.name
            });
            return {
                data: cData,
                cx: r * Math.sin(a),
                cy: -r * Math.cos(a),
                value: value,
                color: color,
                label: d.name
            };
        });
        this.active = this.isActive(this.data);
        this.inactive = this.isInactive(this.data);
        this.tooltipText = this.tooltipText || (function (c) { return _this.defaultTooltipText(c); });
    };
    PolarSeriesComponent.prototype.getAngle = function (d) {
        var label = d.name;
        if (this.scaleType === 'time') {
            return this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            return this.xScale(Number(label));
        }
        return this.xScale(label);
    };
    PolarSeriesComponent.prototype.getRadius = function (d) {
        return this.yScale(d.value);
    };
    PolarSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return lineRadial()
            .angle(function (d) { return _this.getAngle(d); })
            .radius(function (d) { return _this.getRadius(d); })
            .curve(this.curve);
    };
    PolarSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            return sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            return sortByTime(data, 'name');
        }
        return sortByDomain(data, 'name', 'asc', this.xScale.domain());
    };
    PolarSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    PolarSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    PolarSeriesComponent.prototype.defaultTooltipText = function (_a) {
        var label = _a.label, value = _a.value;
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(this.data.name) + " \u2022 " + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
    };
    PolarSeriesComponent.prototype.updateGradients = function () {
        this.hasGradient = this.gradient || this.colors.scaleType === 'linear';
        if (!this.hasGradient) {
            return;
        }
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        if (this.colors.scaleType === 'linear') {
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
        }
        else {
            this.gradientStops = undefined;
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PolarSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], PolarSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "deactivate", void 0);
PolarSeriesComponent.ɵfac = function PolarSeriesComponent_Factory(t) { return new (t || PolarSeriesComponent)(); };
PolarSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarSeriesComponent, selectors: [["g", "ngx-charts-polar-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", gradient: "gradient", animations: "animations", tooltipText: "tooltipText", name: "name", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c37, decls: 5, vars: 11, consts: [[1, "polar-charts-series"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops", 4, "ngIf"], ["ngx-charts-line", "", 1, "polar-series-path", 3, "path", "stroke", "fill", "animations"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", "tooltipType", "tooltip", 3, "cx", "cy", "r", "fill", "opacity", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops"], ["ngx-charts-circle", "", "ngx-tooltip", "", "tooltipType", "tooltip", 1, "circle", 3, "cx", "cy", "r", "fill", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function PolarSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, PolarSeriesComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 2);
        ɵngcc0.ɵɵtemplate(4, PolarSeriesComponent__svg_g_4_Template, 1, 11, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.active)("inactive", ctx.inactive);
        ɵngcc0.ɵɵproperty("path", ctx.path)("stroke", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("animations", ctx.animations);
        ɵngcc0.ɵɵattribute("fill-opacity", ctx.rangeFillOpacity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles);
    } }, directives: [ɵngcc1.NgIf, LineComponent, ɵngcc1.NgForOf, SvgRadialGradientComponent,
        CircleComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-polar-series]',
                template: "\n    <svg:g class=\"polar-charts-series\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-radial-gradient\n          *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [color]=\"seriesColor\"\n          [name]=\"gradientId\"\n          [startOpacity]=\"0.25\"\n          [endOpacity]=\"1\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g\n        ngx-charts-line\n        class=\"polar-series-path\"\n        [path]=\"path\"\n        [stroke]=\"hasGradient ? gradientUrl : seriesColor\"\n        [class.active]=\"active\"\n        [class.inactive]=\"inactive\"\n        [attr.fill-opacity]=\"rangeFillOpacity\"\n        [fill]=\"hasGradient ? gradientUrl : seriesColor\"\n        [animations]=\"animations\"\n      />\n      <svg:g\n        ngx-charts-circle\n        *ngFor=\"let circle of circles\"\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circleRadius\"\n        [fill]=\"circle.color\"\n        [style.opacity]=\"inactive ? 0.2 : 1\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        tooltipType=\"tooltip\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n        (select)=\"select.emit(circle.data)\"\n        (activate)=\"activate.emit({ name: circle.data.series })\"\n        (deactivate)=\"deactivate.emit({ name: circle.data.series })\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], name: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return PolarSeriesComponent;
}());

var AdvancedPieChartComponent = /** @class */ (function (_super) {
    __extends(AdvancedPieChartComponent, _super);
    function AdvancedPieChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.label = 'Total';
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [20, 20, 20, 20];
        return _this;
    }
    AdvancedPieChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: (this.width * 4) / 12.0,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.setColors();
        var xOffset = this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.legendWidth = this.width - this.dims.width - this.margin[1];
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2.5;
        this.innerRadius = this.outerRadius * 0.75;
        this.transform = "translate(" + xOffset + " , " + yOffset + ")";
    };
    AdvancedPieChartComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    AdvancedPieChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    AdvancedPieChartComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    AdvancedPieChartComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AdvancedPieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedPieChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AdvancedPieChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedPieChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedPieChartComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AdvancedPieChartComponent.prototype, "label", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AdvancedPieChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AdvancedPieChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AdvancedPieChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "nameFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "percentageFormatting", void 0);
AdvancedPieChartComponent.ɵfac = function AdvancedPieChartComponent_Factory(t) { return ɵAdvancedPieChartComponent_BaseFactory(t || AdvancedPieChartComponent); };
AdvancedPieChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AdvancedPieChartComponent, selectors: [["ngx-charts-advanced-pie-chart"]], contentQueries: function AdvancedPieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", gradient: "gradient", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", label: "label", valueFormatting: "valueFormatting", nameFormatting: "nameFormatting", percentageFormatting: "percentageFormatting" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 7, vars: 37, consts: [[1, "advanced-pie", "chart"], [3, "view", "showLegend", "animations"], [1, "pie", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "innerRadius", "activeEntries", "outerRadius", "gradient", "tooltipDisabled", "tooltipTemplate", "tooltipText", "animations", "select", "activate", "deactivate"], [1, "advanced-pie-legend-wrapper"], [3, "data", "colors", "width", "label", "animations", "valueFormatting", "labelFormatting", "percentageFormatting", "select", "activate", "deactivate"]], template: function AdvancedPieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "ngx-charts-chart", 1);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵelementStart(4, "g", 3);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function AdvancedPieChartComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "ngx-charts-advanced-legend", 5);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_select_6_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_activate_6_listener($event) { return ctx.onActivate($event, true); })("deactivate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_deactivate_6_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.dims.width, "px")("height", ctx.dims.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(34, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.results)("innerRadius", ctx.innerRadius)("activeEntries", ctx.activeEntries)("outerRadius", ctx.outerRadius)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.width - ctx.dims.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.results)("colors", ctx.colors)("width", ctx.width - ctx.dims.width - ctx.margin[1])("label", ctx.label)("animations", ctx.animations)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.nameFormatting)("percentageFormatting", ctx.percentageFormatting);
    } }, directives: function () { return [ChartComponent,
        PieSeriesComponent,
        AdvancedLegendComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}"], encapsulation: 2, changeDetection: 0 });
var ɵAdvancedPieChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AdvancedPieChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AdvancedPieChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-advanced-pie-chart',
                template: "\n    <div [style.width.px]=\"width\" [style.height.px]=\"height\">\n      <div class=\"advanced-pie chart\" [style.width.px]=\"dims.width\" [style.height.px]=\"dims.height\">\n        <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n          <svg:g [attr.transform]=\"transform\" class=\"pie chart\">\n            <svg:g\n              ngx-charts-pie-series\n              [colors]=\"colors\"\n              [series]=\"results\"\n              [innerRadius]=\"innerRadius\"\n              [activeEntries]=\"activeEntries\"\n              [outerRadius]=\"outerRadius\"\n              [gradient]=\"gradient\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              [tooltipText]=\"tooltipText\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n              [animations]=\"animations\"\n            ></svg:g>\n          </svg:g>\n        </ngx-charts-chart>\n      </div>\n      <div class=\"advanced-pie-legend-wrapper\" [style.width.px]=\"width - dims.width\" [style.height.px]=\"height\">\n        <ngx-charts-advanced-legend\n          [data]=\"results\"\n          [colors]=\"colors\"\n          [width]=\"width - dims.width - margin[1]\"\n          [label]=\"label\"\n          [animations]=\"animations\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"nameFormatting\"\n          [percentageFormatting]=\"percentageFormatting\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event, true)\"\n          (deactivate)=\"onDeactivate($event, true)\"\n        >\n        </ngx-charts-advanced-legend>\n      </div>\n    </div>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { activeEntries: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], label: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], valueFormatting: [{
            type: Input
        }], nameFormatting: [{
            type: Input
        }], percentageFormatting: [{
            type: Input
        }] }); })();
    return AdvancedPieChartComponent;
}(BaseChartComponent));

var PieLabelComponent = /** @class */ (function () {
    function PieLabelComponent() {
        this.animations = true;
        this.labelTrim = true;
        this.labelTrimSize = 10;
        this.isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
        this.trimLabel = trimLabel;
    }
    PieLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieLabelComponent.prototype.update = function () {
        var startRadius = this.radius;
        if (this.explodeSlices) {
            startRadius = this.radius * this.value / this.max;
        }
        var innerArc = arc()
            .innerRadius(startRadius)
            .outerRadius(startRadius);
        // Calculate innerPos then scale outer position to match label position
        var innerPos = innerArc.centroid(this.data);
        var scale = this.data.pos[1] / innerPos[1];
        if (this.data.pos[1] === 0 || innerPos[1] === 0) {
            scale = 1;
        }
        var outerPos = [scale * innerPos[0], scale * innerPos[1]];
        this.line = "M" + innerPos + "L" + outerPos + "L" + this.data.pos;
    };
    Object.defineProperty(PieLabelComponent.prototype, "textX", {
        get: function () {
            return this.data.pos[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "textY", {
        get: function () {
            return this.data.pos[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "styleTransform", {
        get: function () {
            return this.isIE ? null : "translate3d(" + this.textX + "px," + this.textY + "px, 0)";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "attrTransform", {
        get: function () {
            return !this.isIE ? null : "translate(" + this.textX + "," + this.textY + ")";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "textTransition", {
        get: function () {
            return this.isIE || !this.animations ? null : 'transform 0.75s';
        },
        enumerable: true,
        configurable: true
    });
    PieLabelComponent.prototype.textAnchor = function () {
        return this.midAngle(this.data) < Math.PI ? 'start' : 'end';
    };
    PieLabelComponent.prototype.midAngle = function (d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "radius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieLabelComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieLabelComponent.prototype, "labelTrim", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieLabelComponent.prototype, "labelTrimSize", void 0);
    PieLabelComponent = __decorate([ __metadata("design:paramtypes", [])
    ], PieLabelComponent);
PieLabelComponent.ɵfac = function PieLabelComponent_Factory(t) { return new (t || PieLabelComponent)(); };
PieLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieLabelComponent, selectors: [["g", "ngx-charts-pie-label", ""]], inputs: { animations: "animations", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", data: "data", radius: "radius", label: "label", color: "color", max: "max", value: "value", explodeSlices: "explodeSlices" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c38, decls: 6, vars: 17, consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]], template: function PieLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "title");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelementStart(3, "text", 0);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
        ɵngcc0.ɵɵattribute("transform", ctx.attrTransform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵattribute("d", ctx.line)("stroke", ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-label]',
                template: "\n    <title>{{label}}</title>\n    <svg:g\n      [attr.transform]=\"attrTransform\"\n      [style.transform]=\"styleTransform\"\n      [style.transition]=\"textTransition\">\n      <svg:text\n        class=\"pie-label\"\n        [class.animation]=\"animations\"\n        dy=\".35em\"\n        [style.textAnchor]=\"textAnchor()\"\n        [style.shapeRendering]=\"'crispEdges'\">\n        {{labelTrim ? trimLabel(label, labelTrimSize) : label}}\n      </svg:text>\n    </svg:g>\n    <svg:path\n      [attr.d]=\"line\"\n      [attr.stroke]=\"color\"\n      fill=\"none\"\n      class=\"pie-label-line line\"\n      [class.animation]=\"animations\">\n    </svg:path>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], data: [{
            type: Input
        }], radius: [{
            type: Input
        }], label: [{
            type: Input
        }], color: [{
            type: Input
        }], max: [{
            type: Input
        }], value: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }] }); })();
    return PieLabelComponent;
}());

var PieArcComponent = /** @class */ (function () {
    function PieArcComponent(element) {
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.cornerRadius = 0;
        this.explodeSlices = false;
        this.gradient = false;
        this.animate = true;
        this.pointerEvents = true;
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    PieArcComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieArcComponent.prototype.getGradient = function () {
        return this.gradient ? this.gradientFill : this.fill;
    };
    PieArcComponent.prototype.getPointerEvents = function () {
        return this.pointerEvents ? 'auto' : 'none';
    };
    PieArcComponent.prototype.update = function () {
        var calc = this.calculateArc();
        this.startOpacity = 0.5;
        this.radialGradientId = 'linearGrad' + id().toString();
        this.gradientFill = "url(#" + this.radialGradientId + ")";
        if (this.animate) {
            if (this.initialized) {
                this.updateAnimation();
            }
            else {
                this.loadAnimation();
                this.initialized = true;
            }
        }
        else {
            this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
        }
    };
    PieArcComponent.prototype.calculateArc = function () {
        var outerRadius = this.outerRadius;
        if (this.explodeSlices && this.innerRadius === 0) {
            outerRadius = (this.outerRadius * this.value) / this.max;
        }
        return arc()
            .innerRadius(this.innerRadius)
            .outerRadius(outerRadius)
            .cornerRadius(this.cornerRadius);
    };
    PieArcComponent.prototype.loadAnimation = function () {
        var node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        var calc = this.calculateArc();
        node
            .transition()
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var copyOfD = Object.assign({}, d);
            copyOfD.endAngle = copyOfD.startAngle;
            var interpolater = interpolate(copyOfD, copyOfD);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        })
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    };
    PieArcComponent.prototype.updateAnimation = function () {
        var node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        var calc = this.calculateArc();
        node
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    };
    PieArcComponent.prototype.onClick = function () {
        var _this = this;
        clearTimeout(this._timeout);
        this._timeout = setTimeout(function () { return _this.select.emit(_this.data); }, 200);
    };
    PieArcComponent.prototype.onDblClick = function (event$$1) {
        event$$1.preventDefault();
        event$$1.stopPropagation();
        clearTimeout(this._timeout);
        this.dblclick.emit({
            data: this.data,
            nativeEvent: event$$1
        });
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "endAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "cornerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "animate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "pointerEvents", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "isActive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "dblclick", void 0);
    PieArcComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], PieArcComponent);
PieArcComponent.ɵfac = function PieArcComponent_Factory(t) { return new (t || PieArcComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
PieArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieArcComponent, selectors: [["g", "ngx-charts-pie-arc", ""]], inputs: { startAngle: "startAngle", endAngle: "endAngle", cornerRadius: "cornerRadius", explodeSlices: "explodeSlices", gradient: "gradient", animate: "animate", pointerEvents: "pointerEvents", isActive: "isActive", fill: "fill", innerRadius: "innerRadius", outerRadius: "outerRadius", value: "value", max: "max", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c39, decls: 3, vars: 7, consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity"]], template: function PieArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "path", 2);
        ɵngcc0.ɵɵlistener("click", function PieArcComponent_Template__svg_path_click_2_listener() { return ctx.onClick(); })("dblclick", function PieArcComponent_Template__svg_path_dblclick_2_listener($event) { return ctx.onDblClick($event); })("mouseenter", function PieArcComponent_Template__svg_path_mouseenter_2_listener() { return ctx.activate.emit(ctx.data); })("mouseleave", function PieArcComponent_Template__svg_path_mouseleave_2_listener() { return ctx.deactivate.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("pointer-events", ctx.getPointerEvents());
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵattribute("d", ctx.path)("fill", ctx.getGradient());
    } }, directives: [ɵngcc1.NgIf, SvgRadialGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-arc]',
                template: "\n    <svg:g class=\"arc-group\">\n      <svg:defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-radial-gradient\n          [color]=\"fill\"\n          orientation=\"vertical\"\n          [name]=\"radialGradientId\"\n          [startOpacity]=\"startOpacity\"\n        />\n      </svg:defs>\n      <svg:path\n        [attr.d]=\"path\"\n        class=\"arc\"\n        [class.active]=\"isActive\"\n        [attr.fill]=\"getGradient()\"\n        (click)=\"onClick()\"\n        (dblclick)=\"onDblClick($event)\"\n        (mouseenter)=\"activate.emit(data)\"\n        (mouseleave)=\"deactivate.emit(data)\"\n        [style.pointer-events]=\"getPointerEvents()\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { startAngle: [{
            type: Input
        }], endAngle: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animate: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }], isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], fill: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], value: [{
            type: Input
        }], max: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return PieArcComponent;
}());

var PieChartComponent = /** @class */ (function (_super) {
    __extends(PieChartComponent, _super);
    function PieChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.labels = false;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.explodeSlices = false;
        _this.doughnut = false;
        _this.arcWidth = 0.25;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.trimLabels = true;
        _this.maxLabelLength = 10;
        _this.dblclick = new EventEmitter();
        _this.select = new EventEmitter();
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        return _this;
    }
    PieChartComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (this.labels && this.hasNoOptionalMarginsSet()) {
            this.margins = [30, 80, 30, 80];
        }
        else if (!this.labels && this.hasNoOptionalMarginsSet()) {
            this.margins = [20, 20, 20, 20];
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margins,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        var xOffset = this.margins[3] + this.dims.width / 2;
        var yOffset = this.margins[0] + this.dims.height / 2;
        this.translation = "translate(" + xOffset + ", " + yOffset + ")";
        this.outerRadius = Math.min(this.dims.width, this.dims.height);
        if (this.labels) {
            this.outerRadius /= 3;
        }
        else {
            this.outerRadius /= 2;
        }
        this.innerRadius = 0;
        if (this.doughnut) {
            this.innerRadius = this.outerRadius * (1 - this.arcWidth);
        }
        this.domain = this.getDomain();
        this.data = this.results.sort(function (a, b) {
            return _this.domain.indexOf(a.name) - _this.domain.indexOf(b.name);
        });
        this.setColors();
        this.legendOptions = this.getLegendOptions();
    };
    PieChartComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    PieChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieChartComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    PieChartComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            domain: this.domain,
            colors: this.colors,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    PieChartComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    PieChartComponent.prototype.hasNoOptionalMarginsSet = function () {
        return !this.margins || this.margins.length <= 0;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "labels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "doughnut", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "arcWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "trimLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieChartComponent.prototype, "maxLabelLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "tooltipText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "dblclick", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieChartComponent.prototype, "margins", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PieChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PieChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PieChartComponent.prototype, "tooltipTemplate", void 0);
PieChartComponent.ɵfac = function PieChartComponent_Factory(t) { return ɵPieChartComponent_BaseFactory(t || PieChartComponent); };
PieChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieChartComponent, selectors: [["ngx-charts-pie-chart"]], contentQueries: function PieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { margins: "margins", activeEntries: "activeEntries", labels: "labels", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", explodeSlices: "explodeSlices", doughnut: "doughnut", arcWidth: "arcWidth", gradient: "gradient", tooltipDisabled: "tooltipDisabled", labelFormatting: "labelFormatting", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipText: "tooltipText" }, outputs: { dblclick: "dblclick", select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 24, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "pie-chart", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "showLabels", "labelFormatting", "trimLabels", "maxLabelLength", "activeEntries", "innerRadius", "outerRadius", "explodeSlices", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "dblclick", "select", "activate", "deactivate"]], template: function PieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); })("legendLabelClick", function PieChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("dblclick", function PieChartComponent_Template__svg_g_dblclick_2_listener($event) { return ctx.dblclick.emit($event); })("select", function PieChartComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); })("activate", function PieChartComponent_Template__svg_g_activate_2_listener($event) { return ctx.onActivate($event); })("deactivate", function PieChartComponent_Template__svg_g_deactivate_2_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(21, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.translation);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.data)("showLabels", ctx.labels)("labelFormatting", ctx.labelFormatting)("trimLabels", ctx.trimLabels)("maxLabelLength", ctx.maxLabelLength)("activeEntries", ctx.activeEntries)("innerRadius", ctx.innerRadius)("outerRadius", ctx.outerRadius)("explodeSlices", ctx.explodeSlices)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: function () { return [ChartComponent,
        PieSeriesComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}"], encapsulation: 2, changeDetection: 0 });
var ɵPieChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PieChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-pie-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"translation\" class=\"pie-chart chart\">\n        <svg:g\n          ngx-charts-pie-series\n          [colors]=\"colors\"\n          [series]=\"data\"\n          [showLabels]=\"labels\"\n          [labelFormatting]=\"labelFormatting\"\n          [trimLabels]=\"trimLabels\"\n          [maxLabelLength]=\"maxLabelLength\"\n          [activeEntries]=\"activeEntries\"\n          [innerRadius]=\"innerRadius\"\n          [outerRadius]=\"outerRadius\"\n          [explodeSlices]=\"explodeSlices\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (dblclick)=\"dblclick.emit($event)\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { margins: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labels: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], doughnut: [{
            type: Input
        }], arcWidth: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], dblclick: [{
            type: Output
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PieChartComponent;
}(BaseChartComponent));

function gridSize(dims, len, minWidth) {
    var rows = 1;
    var cols = len;
    var width = dims.width;
    if (width > minWidth) {
        while (width / cols < minWidth) {
            rows += 1;
            cols = Math.ceil(len / rows);
        }
    }
    return [cols, rows];
}
function gridLayout(dims, data, minWidth, designatedTotal) {
    var xScale = scaleBand();
    var yScale = scaleBand();
    var width = dims.width;
    var height = dims.height;
    var _a = gridSize(dims, data.length, minWidth), columns = _a[0], rows = _a[1];
    var xDomain = [];
    var yDomain = [];
    for (var i = 0; i < rows; i++) {
        yDomain.push(i);
    }
    for (var i = 0; i < columns; i++) {
        xDomain.push(i);
    }
    xScale.domain(xDomain);
    yScale.domain(yDomain);
    xScale.rangeRound([0, width], 0.1);
    yScale.rangeRound([0, height], 0.1);
    var res = [];
    var total = designatedTotal ? designatedTotal : getTotal(data);
    var cardWidth = xScale.bandwidth();
    var cardHeight = yScale.bandwidth();
    for (var i = 0; i < data.length; i++) {
        res[i] = {};
        res[i].data = {
            name: data[i] ? data[i].name : '',
            value: data[i] ? data[i].value : undefined,
            extra: data[i] ? data[i].extra : undefined,
            label: data[i] ? data[i].label : ''
        };
        res[i].x = xScale(i % columns);
        res[i].y = yScale(Math.floor(i / columns));
        res[i].width = cardWidth;
        res[i].height = cardHeight;
        res[i].data.percent = total > 0 ? res[i].data.value / total : 0;
        res[i].data.total = total;
    }
    return res;
}
function getTotal(results) {
    return results.map(function (d) { return (d ? d.value : 0); }).reduce(function (sum, val) { return sum + val; }, 0);
}

var PieGridComponent = /** @class */ (function (_super) {
    __extends(PieGridComponent, _super);
    function PieGridComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tooltipDisabled = false;
        _this.label = 'Total';
        _this.minWidth = 150;
        _this.activeEntries = [];
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [20, 20, 20, 20];
        return _this;
    }
    PieGridComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.data = gridLayout(this.dims, this.results, this.minWidth, this.designatedTotal);
        this.transform = "translate(" + this.margin[3] + " , " + this.margin[0] + ")";
        this.series = this.getSeries();
        this.setColors();
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    };
    PieGridComponent.prototype.defaultTooltipText = function (_a) {
        var data = _a.data;
        var label = trimLabel(formatLabel(data.name));
        var val = data.value.toLocaleString();
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    PieGridComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    PieGridComponent.prototype.getSeries = function () {
        var _this = this;
        var total = this.designatedTotal ? this.designatedTotal : this.getTotal();
        return this.data.map(function (d) {
            var baselineLabelHeight = 20;
            var padding = 10;
            var name = d.data.name;
            var label = formatLabel(name);
            var value = d.data.value;
            var radius = min([d.width - padding, d.height - baselineLabelHeight]) / 2 - 5;
            var innerRadius = radius * 0.9;
            var count = 0;
            var colors = function () {
                count += 1;
                if (count === 1) {
                    return 'rgba(100,100,100,0.3)';
                }
                else {
                    return _this.colorScale.getColor(label);
                }
            };
            var xPos = d.x + (d.width - padding) / 2;
            var yPos = d.y + (d.height - baselineLabelHeight) / 2;
            return {
                transform: "translate(" + xPos + ", " + yPos + ")",
                colors: colors,
                innerRadius: innerRadius,
                outerRadius: radius,
                name: name,
                label: trimLabel(label),
                total: value,
                value: value,
                percent: format('.1%')(d.data.percent),
                data: [
                    d,
                    {
                        data: {
                            other: true,
                            value: total - value,
                            name: d.data.name
                        }
                    }
                ]
            };
        });
    };
    PieGridComponent.prototype.getTotal = function () {
        return this.results.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
    };
    PieGridComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieGridComponent.prototype.setColors = function () {
        this.colorScale = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    PieGridComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PieGridComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieGridComponent.prototype, "designatedTotal", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieGridComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PieGridComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieGridComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieGridComponent.prototype, "minWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieGridComponent.prototype, "activeEntries", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PieGridComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PieGridComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PieGridComponent.prototype, "tooltipTemplate", void 0);
PieGridComponent.ɵfac = function PieGridComponent_Factory(t) { return ɵPieGridComponent_BaseFactory(t || PieGridComponent); };
PieGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieGridComponent, selectors: [["ngx-charts-pie-grid"]], contentQueries: function PieGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { tooltipText: "tooltipText", activeEntries: "activeEntries", designatedTotal: "designatedTotal", tooltipDisabled: "tooltipDisabled", label: "label", minWidth: "minWidth" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [[3, "view", "showLegend", "animations"], [1, "pie-grid", "chart"], ["class", "pie-grid-item", 4, "ngFor", "ngForOf"], [1, "pie-grid-item"], ["ngx-charts-pie-grid-series", "", "ngx-tooltip", "", 3, "colors", "data", "innerRadius", "outerRadius", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 4, "ngIf"], ["dy", "0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 3, "countTo", "countPrefix", 4, "ngIf"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", 4, "ngIf"], ["dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 1, "label", "percent-label", 3, "countTo", "countSuffix"], ["dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label", "percent-label"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 1, "label", 3, "countTo", "countPrefix"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", 1, "label"]], template: function PieGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2_Template, 8, 19, "g", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(5, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.series);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, PieGridSeriesComponent,
        TooltipDirective, ɵngcc1.NgIf, CountUpDirective]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"], encapsulation: 2, changeDetection: 0 });
var ɵPieGridComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PieGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieGridComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-pie-grid',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"pie-grid chart\">\n        <svg:g *ngFor=\"let series of series\" class=\"pie-grid-item\" [attr.transform]=\"series.transform\">\n          <svg:g\n            ngx-charts-pie-grid-series\n            [colors]=\"series.colors\"\n            [data]=\"series.data\"\n            [innerRadius]=\"series.innerRadius\"\n            [outerRadius]=\"series.outerRadius\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText({ data: series })\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"series.data[0].data\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          />\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label percent-label\"\n            dy=\"-0.5em\"\n            x=\"0\"\n            y=\"5\"\n            ngx-charts-count-up\n            [countTo]=\"series.percent\"\n            [countSuffix]=\"'%'\"\n            text-anchor=\"middle\"\n          ></svg:text>\n          <svg:text *ngIf=\"!animations\" class=\"label percent-label\" dy=\"-0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.percent.toLocaleString() }}\n          </svg:text>\n          <svg:text class=\"label\" dy=\"0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.label }}\n          </svg:text>\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n            ngx-charts-count-up\n            [countTo]=\"series.total\"\n            [countPrefix]=\"label + ': '\"\n          ></svg:text>\n          <svg:text\n            *ngIf=\"!animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n          >\n            {{ label }}: {{ series.total.toLocaleString() }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { tooltipText: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], designatedTotal: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], label: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PieGridComponent;
}(BaseChartComponent));

var PieGridSeriesComponent = /** @class */ (function () {
    function PieGridSeriesComponent(element) {
        this.innerRadius = 70;
        this.outerRadius = 80;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.element = element.nativeElement;
    }
    PieGridSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieGridSeriesComponent.prototype.update = function () {
        this.layout = pie()
            .value(function (d) { return d.data.value; })
            .sort(null);
        this.arcs = this.getArcs();
    };
    PieGridSeriesComponent.prototype.getArcs = function () {
        var _this = this;
        return this.layout(this.data).map(function (arc$$1, index) {
            var label = arc$$1.data.data.name;
            var other = arc$$1.data.data.other;
            if (index === 0) {
                arc$$1.startAngle = 0;
            }
            var color = _this.colors(label);
            return {
                data: arc$$1.data.data,
                class: 'arc ' + 'arc' + index,
                fill: color,
                startAngle: other ? 0 : arc$$1.startAngle,
                endAngle: arc$$1.endAngle,
                animate: _this.animations && !other,
                pointerEvents: !other
            };
        });
    };
    PieGridSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(this.data[0].data);
    };
    PieGridSeriesComponent.prototype.trackBy = function (index, item) {
        return item.data.name;
    };
    PieGridSeriesComponent.prototype.label = function (arc$$1) {
        return arc$$1.data.name;
    };
    PieGridSeriesComponent.prototype.color = function (arc$$1) {
        return this.colors(this.label(arc$$1));
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieGridSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "deactivate", void 0);
    PieGridSeriesComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], PieGridSeriesComponent);
PieGridSeriesComponent.ɵfac = function PieGridSeriesComponent_Factory(t) { return new (t || PieGridSeriesComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
PieGridSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieGridSeriesComponent, selectors: [["g", "ngx-charts-pie-grid-series", ""]], inputs: { innerRadius: "innerRadius", outerRadius: "outerRadius", animations: "animations", colors: "colors", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c41, decls: 2, vars: 2, consts: [[1, "pie-grid-arcs"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate"]], template: function PieGridSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieGridSeriesComponent__svg_g_1_Template, 1, 11, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, PieArcComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieGridSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-grid-series]',
                template: "\n    <svg:g class=\"pie-grid-arcs\">\n      <svg:g\n        ngx-charts-pie-arc\n        *ngFor=\"let arc of arcs; trackBy: trackBy\"\n        [attr.class]=\"arc.class\"\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [data]=\"arc.data\"\n        [gradient]=\"false\"\n        [pointerEvents]=\"arc.pointerEvents\"\n        [animate]=\"arc.animate\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], colors: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return PieGridSeriesComponent;
}());

var PieSeriesComponent = /** @class */ (function () {
    function PieSeriesComponent() {
        this.series = [];
        this.innerRadius = 60;
        this.outerRadius = 80;
        this.trimLabels = true;
        this.maxLabelLength = 10;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
    }
    PieSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieSeriesComponent.prototype.update = function () {
        var pieGenerator = pie()
            .value(function (d) { return d.value; })
            .sort(null);
        var arcData = pieGenerator(this.series);
        this.max = max(arcData, function (d) {
            return d.value;
        });
        this.data = this.calculateLabelPositions(arcData);
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    };
    PieSeriesComponent.prototype.midAngle = function (d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };
    PieSeriesComponent.prototype.outerArc = function () {
        var factor = 1.5;
        return arc()
            .innerRadius(this.outerRadius * factor)
            .outerRadius(this.outerRadius * factor);
    };
    PieSeriesComponent.prototype.calculateLabelPositions = function (pieData) {
        var _this = this;
        var factor = 1.5;
        var minDistance = 10;
        var labelPositions = pieData;
        labelPositions.forEach(function (d) {
            d.pos = _this.outerArc().centroid(d);
            d.pos[0] = factor * _this.outerRadius * (_this.midAngle(d) < Math.PI ? 1 : -1);
        });
        for (var i = 0; i < labelPositions.length - 1; i++) {
            var a = labelPositions[i];
            if (!this.labelVisible(a)) {
                continue;
            }
            for (var j = i + 1; j < labelPositions.length; j++) {
                var b = labelPositions[j];
                if (!this.labelVisible(b)) {
                    continue;
                }
                // if they're on the same side
                if (b.pos[0] * a.pos[0] > 0) {
                    // if they're overlapping
                    var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        // push the second up or down
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        return labelPositions;
    };
    PieSeriesComponent.prototype.labelVisible = function (myArc) {
        return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
    };
    PieSeriesComponent.prototype.getTooltipTitle = function (a) {
        return this.tooltipTemplate ? undefined : this.tooltipText(a);
    };
    PieSeriesComponent.prototype.labelText = function (myArc) {
        if (this.labelFormatting) {
            return this.labelFormatting(myArc.data.name);
        }
        return this.label(myArc);
    };
    PieSeriesComponent.prototype.label = function (myArc) {
        return formatLabel(myArc.data.name);
    };
    PieSeriesComponent.prototype.defaultTooltipText = function (myArc) {
        var label = this.label(myArc);
        var val = formatLabel(myArc.data.value);
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    PieSeriesComponent.prototype.color = function (myArc) {
        return this.colors.getColor(this.label(myArc));
    };
    PieSeriesComponent.prototype.trackBy = function (index, item) {
        return item.data.name;
    };
    PieSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "showLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "trimLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieSeriesComponent.prototype, "maxLabelLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PieSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], PieSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "dblclick", void 0);
PieSeriesComponent.ɵfac = function PieSeriesComponent_Factory(t) { return new (t || PieSeriesComponent)(); };
PieSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieSeriesComponent, selectors: [["g", "ngx-charts-pie-series", ""]], inputs: { series: "series", innerRadius: "innerRadius", outerRadius: "outerRadius", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", colors: "colors", dims: "dims", explodeSlices: "explodeSlices", showLabels: "showLabels", gradient: "gradient", activeEntries: "activeEntries", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c42, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", "dblclick"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]], template: function PieSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, PieArcComponent,
        TooltipDirective,
        PieLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-series]',
                template: "\n    <svg:g *ngFor=\"let arc of data; trackBy: trackBy\">\n      <svg:g\n        ngx-charts-pie-label\n        *ngIf=\"labelVisible(arc)\"\n        [data]=\"arc\"\n        [radius]=\"outerRadius\"\n        [color]=\"color(arc)\"\n        [label]=\"labelText(arc)\"\n        [labelTrim]=\"trimLabels\"\n        [labelTrimSize]=\"maxLabelLength\"\n        [max]=\"max\"\n        [value]=\"arc.value\"\n        [explodeSlices]=\"explodeSlices\"\n        [animations]=\"animations\"\n      ></svg:g>\n      <svg:g\n        ngx-charts-pie-arc\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [gradient]=\"gradient\"\n        [data]=\"arc.data\"\n        [max]=\"max\"\n        [explodeSlices]=\"explodeSlices\"\n        [isActive]=\"isActive(arc.data)\"\n        [animate]=\"animations\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n        (dblclick)=\"dblclick.emit($event)\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"getTooltipTitle(arc)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"arc.data\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { series: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], colors: [{
            type: Input
        }], dims: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], showLabels: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return PieSeriesComponent;
}());

var PieChartModule = /** @class */ (function () {
    function PieChartModule() {
    }
PieChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PieChartModule });
PieChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PieChartModule_Factory(t) { return new (t || PieChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PieChartModule, { declarations: [AdvancedPieChartComponent,
        PieLabelComponent,
        PieArcComponent,
        PieChartComponent,
        PieGridComponent,
        PieGridSeriesComponent,
        PieSeriesComponent], imports: [ChartCommonModule], exports: [AdvancedPieChartComponent,
        PieLabelComponent,
        PieArcComponent,
        PieChartComponent,
        PieGridComponent,
        PieGridSeriesComponent,
        PieSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ],
                exports: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return PieChartModule;
}());

var PolarChartModule = /** @class */ (function () {
    function PolarChartModule() {
    }
PolarChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PolarChartModule });
PolarChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PolarChartModule_Factory(t) { return new (t || PolarChartModule)(); }, imports: [[ChartCommonModule, PieChartModule, LineChartModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PolarChartModule, { declarations: [PolarChartComponent,
        PolarSeriesComponent], imports: [ChartCommonModule,
        PieChartModule,
        LineChartModule], exports: [PolarChartComponent,
        PolarSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, LineChartModule],
                declarations: [
                    PolarChartComponent,
                    PolarSeriesComponent
                ],
                exports: [
                    PolarChartComponent,
                    PolarSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return PolarChartModule;
}());

var CardComponent = /** @class */ (function () {
    function CardComponent(element, cd, zone) {
        this.cd = cd;
        this.zone = zone;
        this.animations = true;
        this.select = new EventEmitter();
        this.value = '';
        this.textFontSize = 12;
        this.textTransform = '';
        this.initialized = false;
        this.bandHeight = 10;
        this.textPadding = [10, 20, 5, 20];
        this.labelFontSize = 15;
        this.element = element.nativeElement;
    }
    CardComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CardComponent.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationReq);
    };
    CardComponent.prototype.update = function () {
        var _this = this;
        this.zone.run(function () {
            var hasValue = _this.data && typeof _this.data.value !== 'undefined';
            var valueFormatting = _this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var labelFormatting = _this.labelFormatting || (function (card) { return escapeLabel(trimLabel(card.label, 55)); });
            _this.transform = "translate(" + _this.x + " , " + _this.y + ")";
            _this.textWidth = Math.max(0, _this.width) - _this.textPadding[1] - _this.textPadding[3];
            _this.cardWidth = Math.max(0, _this.width);
            _this.cardHeight = Math.max(0, _this.height);
            _this.label = _this.label ? _this.label : _this.data.name;
            var cardData = {
                label: _this.label,
                data: _this.data,
                value: _this.data.value
            };
            _this.formattedLabel = labelFormatting(cardData);
            _this.transformBand = "translate(0 , " + (_this.cardHeight - _this.bandHeight) + ")";
            var value = hasValue ? valueFormatting(cardData) : '';
            _this.value = _this.paddedValue(value);
            _this.setPadding();
            _this.bandPath = roundedRect(0, 0, _this.cardWidth, _this.bandHeight, 3, [false, false, true, true]);
            setTimeout(function () {
                _this.scaleText();
                _this.value = value;
                if (hasValue && !_this.initialized) {
                    setTimeout(function () { return _this.startCount(); }, 20);
                }
            }, 8);
        });
    };
    CardComponent.prototype.paddedValue = function (value) {
        if (this.medianSize && this.medianSize > value.length) {
            value += '\u2007'.repeat(this.medianSize - value.length);
        }
        return value;
    };
    CardComponent.prototype.startCount = function () {
        var _this = this;
        if (!this.initialized && this.animations) {
            cancelAnimationFrame(this.animationReq);
            var val_1 = this.data.value;
            var decs = decimalChecker(val_1);
            var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var callback = function (_a) {
                var value = _a.value, finished = _a.finished;
                _this.zone.run(function () {
                    value = finished ? val_1 : value;
                    _this.value = valueFormatting_1({ label: _this.label, data: _this.data, value: value });
                    if (!finished) {
                        _this.value = _this.paddedValue(_this.value);
                    }
                    _this.cd.markForCheck();
                });
            };
            this.animationReq = count(0, val_1, decs, 1, callback);
            this.initialized = true;
        }
    };
    CardComponent.prototype.scaleText = function () {
        var _this = this;
        this.zone.run(function () {
            var _a = _this.textEl.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
            if (width === 0 || height === 0) {
                return;
            }
            var textPadding = (_this.textPadding[1] = _this.textPadding[3] = _this.cardWidth / 8);
            var availableWidth = _this.cardWidth - 2 * textPadding;
            var availableHeight = _this.cardHeight / 3;
            var resizeScale = Math.min(availableWidth / width, availableHeight / height);
            _this.textFontSize = Math.floor(_this.textFontSize * resizeScale);
            _this.labelFontSize = Math.min(_this.textFontSize, 15);
            _this.setPadding();
            _this.cd.markForCheck();
        });
    };
    CardComponent.prototype.setPadding = function () {
        this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
        var padding = this.cardHeight / 2;
        this.textPadding[0] = padding - this.textFontSize - this.labelFontSize / 2;
        this.textPadding[2] = padding - this.labelFontSize;
    };
    CardComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CardComponent.prototype, "medianSize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CardComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "select", void 0);
    __decorate([
        ViewChild('textEl', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], CardComponent.prototype, "textEl", void 0);
    CardComponent = __decorate([ __metadata("design:paramtypes", [typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object, typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object, typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object])
    ], CardComponent);
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object)); };
CardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["g", "ngx-charts-card", ""]], viewQuery: function CardComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { animations: "animations", color: "color", bandColor: "bandColor", textColor: "textColor", x: "x", y: "y", width: "width", height: "height", label: "label", data: "data", medianSize: "medianSize", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c44, decls: 10, vars: 25, consts: [[1, "cell", 3, "click"], ["rx", "3", "ry", "3", 1, "card"], ["class", "card-band", "stroke", "none", 4, "ngIf"], ["x", "5", "alignment-baseline", "hanging", 1, "trimmed-label"], [3, "innerHTML"], ["text-anchor", "start", "alignment-baseline", "hanging", 1, "value-text"], ["textEl", ""], ["stroke", "none", 1, "card-band"]], template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵlistener("click", function CardComponent_Template__svg_g_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelement(1, "rect", 1);
        ɵngcc0.ɵɵtemplate(2, CardComponent__svg_path_2_Template, 1, 3, "path", 2);
        ɵngcc0.ɵɵelementStart(3, "title");
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "foreignObject", 3);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(6, "p", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(7, "text", 5, 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.color);
        ɵngcc0.ɵɵattribute("width", ctx.cardWidth)("height", ctx.cardHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.bandColor && ctx.bandColor !== ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.cardHeight - ctx.textPadding[2])("width", ctx.textWidth)("height", ctx.labelFontSize + ctx.textPadding[2]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("color", ctx.textColor)("font-size", ctx.labelFontSize, "px")("line-height", ctx.labelFontSize, "px");
        ɵngcc0.ɵɵproperty("innerHTML", ctx.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.textColor)("font-size", ctx.textFontSize, "pt");
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.textPadding[0]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.value, " ");
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\" (click)=\"onClick()\">\n      <svg:rect class=\"card\" [style.fill]=\"color\" [attr.width]=\"cardWidth\" [attr.height]=\"cardHeight\" rx=\"3\" ry=\"3\" />\n      <svg:path\n        *ngIf=\"bandColor && bandColor !== color\"\n        class=\"card-band\"\n        [attr.fill]=\"bandColor\"\n        [attr.transform]=\"transformBand\"\n        stroke=\"none\"\n        [attr.d]=\"bandPath\"\n      />\n      <title>{{ label }}</title>\n      <svg:foreignObject\n        class=\"trimmed-label\"\n        x=\"5\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"cardHeight - textPadding[2]\"\n        [attr.width]=\"textWidth\"\n        [attr.height]=\"labelFontSize + textPadding[2]\"\n        alignment-baseline=\"hanging\"\n      >\n        <xhtml:p\n          [style.color]=\"textColor\"\n          [style.fontSize.px]=\"labelFontSize\"\n          [style.lineHeight.px]=\"labelFontSize\"\n          [innerHTML]=\"formattedLabel\"\n        >\n        </xhtml:p>\n      </svg:foreignObject>\n      <svg:text\n        #textEl\n        class=\"value-text\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"textPadding[0]\"\n        [style.fill]=\"textColor\"\n        text-anchor=\"start\"\n        alignment-baseline=\"hanging\"\n        [style.font-size.pt]=\"textFontSize\"\n      >\n        {{ value }}\n      </svg:text>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }, { type: typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object }, { type: typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object }]; }, { animations: [{
            type: Input
        }], select: [{
            type: Output
        }], color: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], data: [{
            type: Input
        }], medianSize: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], textEl: [{
            type: ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
    return CardComponent;
}());

var CardSeriesComponent = /** @class */ (function () {
    function CardSeriesComponent() {
        this.innerPadding = 15;
        this.emptyColor = 'rgba(0, 0, 0, 0)';
        this.animations = true;
        this.select = new EventEmitter();
    }
    CardSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CardSeriesComponent.prototype.update = function () {
        if (this.data.length > 2) {
            var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var sortedLengths = this.data
                .map(function (d) {
                var hasValue = d && d.data && typeof d.data.value !== 'undefined' && d.data.value !== null;
                return hasValue
                    ? valueFormatting_1({
                        data: d.data,
                        label: d ? d.data.name : '',
                        value: d && d.data ? d.data.value : ''
                    }).length
                    : 0;
            })
                .sort(function (a, b) { return b - a; });
            var idx = Math.ceil(this.data.length / 2);
            this.medianSize = sortedLengths[idx];
        }
        var cards = this.getCards();
        this.cards = cards.filter(function (d) { return d.data.value !== null; });
        this.emptySlots = cards.filter(function (d) { return d.data.value === null; });
    };
    CardSeriesComponent.prototype.getCards = function () {
        var _this = this;
        var yPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
        var xPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
        return this.data.map(function (d, index) {
            var label = d.data.name;
            if (label && label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label ? label.toLocaleString() : label;
            }
            var value = d.data.value;
            var valueColor = label ? _this.colors.getColor(label) : _this.emptyColor;
            var color = _this.cardColor || valueColor || '#000';
            return {
                x: d.x,
                y: d.y,
                width: d.width - xPadding,
                height: d.height - yPadding,
                color: color,
                bandColor: _this.bandColor || valueColor,
                textColor: _this.textColor || invertColor(color),
                label: label,
                data: d.data,
                tooltipText: label + ": " + value
            };
        });
    };
    CardSeriesComponent.prototype.trackBy = function (index, card) {
        return card.label;
    };
    CardSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CardSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CardSeriesComponent.prototype, "slots", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "cardColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "emptyColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CardSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "select", void 0);
CardSeriesComponent.ɵfac = function CardSeriesComponent_Factory(t) { return new (t || CardSeriesComponent)(); };
CardSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardSeriesComponent, selectors: [["g", "ngx-charts-card-series", ""]], inputs: { innerPadding: "innerPadding", emptyColor: "emptyColor", animations: "animations", data: "data", slots: "slots", dims: "dims", colors: "colors", cardColor: "cardColor", bandColor: "bandColor", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c45, decls: 2, vars: 4, consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select"]], template: function CardSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0);
        ɵngcc0.ɵɵtemplate(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CardComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card-series]',
                template: "\n    <svg:rect\n      *ngFor=\"let c of emptySlots; trackBy: trackBy\"\n      class=\"card-empty\"\n      [attr.x]=\"c.x\"\n      [attr.y]=\"c.y\"\n      [style.fill]=\"emptyColor\"\n      [attr.width]=\"c.width\"\n      [attr.height]=\"c.height\"\n      rx=\"3\"\n      ry=\"3\"\n    />\n    <svg:g\n      ngx-charts-card\n      *ngFor=\"let c of cards; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [color]=\"c.color\"\n      [bandColor]=\"c.bandColor\"\n      [textColor]=\"c.textColor\"\n      [data]=\"c.data\"\n      [label]=\"c.label\"\n      [medianSize]=\"medianSize\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { innerPadding: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], slots: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
    return CardSeriesComponent;
}());

var NumberCardComponent = /** @class */ (function (_super) {
    __extends(NumberCardComponent, _super);
    function NumberCardComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.emptyColor = 'rgba(0, 0, 0, 0)';
        _this.innerPadding = 15;
        _this.margin = [10, 10, 10, 10];
        return _this;
    }
    Object.defineProperty(NumberCardComponent.prototype, "clickable", {
        get: function () {
            return !!this.select.observers.length;
        },
        enumerable: true,
        configurable: true
    });
    NumberCardComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.setColors();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        var size = gridSize(this.dims, this.results.length, 150);
        var N = size[0] * size[1];
        var data = this.results.slice();
        while (data.length < N) {
            data.push({ value: null });
        }
        this.data = gridLayout(this.dims, data, 150, this.designatedTotal);
    };
    NumberCardComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    NumberCardComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    NumberCardComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "cardColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "emptyColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NumberCardComponent.prototype, "designatedTotal", void 0);
NumberCardComponent.ɵfac = function NumberCardComponent_Factory(t) { return ɵNumberCardComponent_BaseFactory(t || NumberCardComponent); };
NumberCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumberCardComponent, selectors: [["ngx-charts-number-card"]], inputs: { cardColor: "cardColor", bandColor: "bandColor", emptyColor: "emptyColor", innerPadding: "innerPadding", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", designatedTotal: "designatedTotal" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 20, consts: [[3, "view", "showLegend", "animations"], [1, "number-card", "chart"], ["ngx-charts-card-series", "", 3, "colors", "cardColor", "bandColor", "textColor", "emptyColor", "data", "dims", "innerPadding", "valueFormatting", "labelFormatting", "animations", "select"]], template: function NumberCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function NumberCardComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("clickable", ctx.clickable);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("cardColor", ctx.cardColor)("bandColor", ctx.bandColor)("textColor", ctx.textColor)("emptyColor", ctx.emptyColor)("data", ctx.data)("dims", ctx.dims)("innerPadding", ctx.innerPadding)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("animations", ctx.animations);
    } }, directives: [ChartComponent,
        CardSeriesComponent], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"], encapsulation: 2, changeDetection: 0 });
var ɵNumberCardComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NumberCardComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberCardComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-number-card',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"number-card chart\" [class.clickable]=\"clickable\">\n        <svg:g\n          ngx-charts-card-series\n          [colors]=\"colors\"\n          [cardColor]=\"cardColor\"\n          [bandColor]=\"bandColor\"\n          [textColor]=\"textColor\"\n          [emptyColor]=\"emptyColor\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [innerPadding]=\"innerPadding\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], innerPadding: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], designatedTotal: [{
            type: Input
        }] }); })();
    return NumberCardComponent;
}(BaseChartComponent));

var NumberCardModule = /** @class */ (function () {
    function NumberCardModule() {
    }
NumberCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NumberCardModule });
NumberCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NumberCardModule_Factory(t) { return new (t || NumberCardModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NumberCardModule, { declarations: [CardComponent,
        CardSeriesComponent,
        NumberCardComponent], imports: [ChartCommonModule], exports: [CardComponent,
        CardSeriesComponent,
        NumberCardComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberCardModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    CardComponent,
                    CardSeriesComponent,
                    NumberCardComponent
                ],
                exports: [
                    CardComponent,
                    CardSeriesComponent,
                    NumberCardComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return NumberCardModule;
}());

var TreeMapCellComponent = /** @class */ (function () {
    function TreeMapCellComponent(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    TreeMapCellComponent.prototype.ngOnChanges = function () {
        this.update();
        this.valueFormatting = this.valueFormatting || (function (value) { return value.toLocaleString(); });
        var labelFormatting = this.labelFormatting || (function (cell) { return escapeLabel(trimLabel(cell.label, 55)); });
        var cellData = {
            data: this.data,
            label: this.label,
            value: this.value
        };
        this.formattedValue = this.valueFormatting(cellData.value);
        this.formattedLabel = labelFormatting(cellData);
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        this.gradientStops = this.getGradientStops();
    };
    TreeMapCellComponent.prototype.update = function () {
        if (this.initialized) {
            this.animateToCurrentForm();
        }
        else {
            if (this.animations) {
                this.loadAnimation();
            }
            this.initialized = true;
        }
    };
    TreeMapCellComponent.prototype.loadAnimation = function () {
        var node = select(this.element).select('.cell');
        node
            .attr('opacity', 0)
            .attr('x', this.x)
            .attr('y', this.y);
        this.animateToCurrentForm();
    };
    TreeMapCellComponent.prototype.getTextColor = function () {
        return invertColor(this.fill);
    };
    TreeMapCellComponent.prototype.animateToCurrentForm = function () {
        var node = select(this.element).select('.cell');
        if (this.animations) {
            node
                .transition()
                .duration(750)
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
        else {
            node
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
    };
    TreeMapCellComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    TreeMapCellComponent.prototype.getGradientStops = function () {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: 0.3
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "valueType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "select", void 0);
    TreeMapCellComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], TreeMapCellComponent);
TreeMapCellComponent.ɵfac = function TreeMapCellComponent_Factory(t) { return new (t || TreeMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
TreeMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellComponent, selectors: [["g", "ngx-charts-tree-map-cell", ""]], inputs: { gradient: "gradient", animations: "animations", valueFormatting: "valueFormatting", data: "data", fill: "fill", x: "x", y: "y", width: "width", height: "height", label: "label", value: "value", valueType: "valueType", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c46, decls: 4, vars: 9, consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]], template: function TreeMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, TreeMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵelementStart(2, "rect", 1);
        ɵngcc0.ɵɵlistener("click", function TreeMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("cursor", "pointer");
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.width >= 70 && ctx.height >= 35);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent,
        CountUpDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell]',
                template: "\n    <svg:g>\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [style.cursor]=\"'pointer'\"\n        class=\"cell\"\n        (click)=\"onClick()\"\n      />\n      <svg:foreignObject\n        *ngIf=\"width >= 70 && height >= 35\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"treemap-label\"\n        [style.pointer-events]=\"'none'\"\n      >\n        <xhtml:p [style.color]=\"getTextColor()\" [style.height]=\"height + 'px'\" [style.width]=\"width + 'px'\">\n          <xhtml:span class=\"treemap-label\" [innerHTML]=\"formattedLabel\"> </xhtml:span>\n          <xhtml:br />\n          <xhtml:span\n            *ngIf=\"animations\"\n            class=\"treemap-val\"\n            ngx-charts-count-up\n            [countTo]=\"value\"\n            [valueFormatting]=\"valueFormatting\"\n          >\n          </xhtml:span>\n          <xhtml:span *ngIf=\"!animations\" class=\"treemap-val\">\n            {{ formattedValue }}\n          </xhtml:span>\n        </xhtml:p>\n      </svg:foreignObject>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], valueFormatting: [{
            type: Input
        }], data: [{
            type: Input
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], valueType: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
    return TreeMapCellComponent;
}());

var TreeMapCellSeriesComponent = /** @class */ (function () {
    function TreeMapCellSeriesComponent() {
        this.gradient = false;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    TreeMapCellSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.cells = this.getCells();
    };
    TreeMapCellSeriesComponent.prototype.getCells = function () {
        var _this = this;
        return this.data.children
            .filter(function (d) {
            return d.depth === 1;
        })
            .map(function (d, index) {
            var label = d.id;
            return {
                data: d.data,
                x: d.x0,
                y: d.y0,
                width: d.x1 - d.x0,
                height: d.y1 - d.y0,
                fill: _this.colors.getColor(label),
                label: label,
                value: d.value,
                valueType: d.valueType
            };
        });
    };
    TreeMapCellSeriesComponent.prototype.getTooltipText = function (_a) {
        var label = _a.label, value = _a.value;
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
    };
    TreeMapCellSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    TreeMapCellSeriesComponent.prototype.trackBy = function (index, item) {
        return item.label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TreeMapCellSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "select", void 0);
TreeMapCellSeriesComponent.ɵfac = function TreeMapCellSeriesComponent_Factory(t) { return new (t || TreeMapCellSeriesComponent)(); };
TreeMapCellSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellSeriesComponent, selectors: [["g", "ngx-charts-tree-map-cell-series", ""]], inputs: { gradient: "gradient", tooltipDisabled: "tooltipDisabled", animations: "animations", data: "data", dims: "dims", colors: "colors", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c47, decls: 1, vars: 2, consts: [["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select"]], template: function TreeMapCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeMapCellSeriesComponent__svg_g_0_Template, 1, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, TreeMapCellComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapCellSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-tree-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [data]=\"c.data\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [label]=\"c.label\"\n      [value]=\"c.value\"\n      [valueType]=\"c.valueType\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"c.data\"\n    ></svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return TreeMapCellSeriesComponent;
}());

var TreeMapComponent = /** @class */ (function (_super) {
    __extends(TreeMapComponent, _super);
    function TreeMapComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tooltipDisabled = false;
        _this.gradient = false;
        _this.select = new EventEmitter();
        _this.margin = [10, 10, 10, 10];
        return _this;
    }
    TreeMapComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.domain = this.getDomain();
        this.treemap = treemap().size([this.dims.width, this.dims.height]);
        var rootNode = {
            name: 'root',
            value: 0,
            isRoot: true
        };
        var root = stratify()
            .id(function (d) {
            var label = d.name;
            if (label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label.toLocaleString();
            }
            return label;
        })
            .parentId(function (d) { return (d.isRoot ? null : 'root'); })([rootNode].concat(this.results))
            .sum(function (d) { return d.value; });
        this.data = this.treemap(root);
        this.setColors();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    TreeMapComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    TreeMapComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    TreeMapComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapComponent.prototype, "gradient", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "select", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TreeMapComponent.prototype, "tooltipTemplate", void 0);
TreeMapComponent.ɵfac = function TreeMapComponent_Factory(t) { return ɵTreeMapComponent_BaseFactory(t || TreeMapComponent); };
TreeMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapComponent, selectors: [["ngx-charts-tree-map"]], contentQueries: function TreeMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { results: "results", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", gradient: "gradient" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 16, consts: [[3, "view", "showLegend", "animations"], [1, "tree-map", "chart"], ["ngx-charts-tree-map-cell-series", "", 3, "colors", "data", "dims", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "labelFormatting", "gradient", "animations", "select"]], template: function TreeMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function TreeMapComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(13, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("data", ctx.data)("dims", ctx.dims)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("gradient", ctx.gradient)("animations", ctx.animations);
    } }, directives: [ChartComponent,
        TreeMapCellSeriesComponent], styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}"], encapsulation: 2, changeDetection: 0 });
var ɵTreeMapComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TreeMapComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-tree-map',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"tree-map chart\">\n        <svg:g\n          ngx-charts-tree-map-cell-series\n          [colors]=\"colors\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { results: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], gradient: [{
            type: Input
        }], select: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return TreeMapComponent;
}(BaseChartComponent));

var TreeMapModule = /** @class */ (function () {
    function TreeMapModule() {
    }
TreeMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TreeMapModule });
TreeMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TreeMapModule_Factory(t) { return new (t || TreeMapModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeMapModule, { declarations: [TreeMapCellComponent,
        TreeMapCellSeriesComponent,
        TreeMapComponent], imports: [ChartCommonModule], exports: [TreeMapCellComponent,
        TreeMapCellSeriesComponent,
        TreeMapComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    TreeMapCellComponent,
                    TreeMapCellSeriesComponent,
                    TreeMapComponent
                ],
                exports: [
                    TreeMapCellComponent,
                    TreeMapCellSeriesComponent,
                    TreeMapComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return TreeMapModule;
}());

var LinearGaugeComponent = /** @class */ (function (_super) {
    __extends(LinearGaugeComponent, _super);
    function LinearGaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.min = 0;
        _this.max = 100;
        _this.value = 0;
        _this.margin = [10, 20, 10, 20];
        _this.valueResizeScale = 1;
        _this.unitsResizeScale = 1;
        _this.valueTextTransform = '';
        _this.valueTranslate = '';
        _this.unitsTextTransform = '';
        _this.unitsTranslate = '';
        return _this;
    }
    LinearGaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () {
            _this.scaleText('value');
            _this.scaleText('units');
        });
    };
    LinearGaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.hasPreviousValue = this.previousValue !== undefined;
        this.max = Math.max(this.max, this.value);
        this.min = Math.min(this.min, this.value);
        if (this.hasPreviousValue) {
            this.max = Math.max(this.max, this.previousValue);
            this.min = Math.min(this.min, this.previousValue);
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.setColors();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.transformLine = "translate(" + (this.margin[3] + this.valueScale(this.previousValue)) + ", " + yOffset + ")";
        this.valueTranslate = "translate(0, -15)";
        this.unitsTranslate = "translate(0, 15)";
        setTimeout(function () { return _this.scaleText('value'); }, 50);
        setTimeout(function () { return _this.scaleText('units'); }, 50);
    };
    LinearGaugeComponent.prototype.getValueDomain = function () {
        return [this.min, this.max];
    };
    LinearGaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
    };
    LinearGaugeComponent.prototype.getDisplayValue = function () {
        if (this.valueFormatting) {
            return this.valueFormatting(this.value);
        }
        return this.value.toLocaleString();
    };
    LinearGaugeComponent.prototype.scaleText = function (element, repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        var el;
        var resizeScale;
        if (element === 'value') {
            el = this.valueTextEl;
            resizeScale = this.valueResizeScale;
        }
        else {
            el = this.unitsTextEl;
            resizeScale = this.unitsResizeScale;
        }
        var _a = el.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
        if (width === 0 || height === 0)
            return;
        var oldScale = resizeScale;
        var availableWidth = this.dims.width;
        var availableHeight = Math.max(this.dims.height / 2 - 15, 0);
        var resizeScaleWidth = Math.floor((availableWidth / (width / resizeScale)) * 100) / 100;
        var resizeScaleHeight = Math.floor((availableHeight / (height / resizeScale)) * 100) / 100;
        resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
        if (resizeScale !== oldScale) {
            if (element === 'value') {
                this.valueResizeScale = resizeScale;
                this.valueTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            else {
                this.unitsResizeScale = resizeScale;
                this.unitsTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () {
                    _this.scaleText(element, false);
                }, 50);
            }
        }
    };
    LinearGaugeComponent.prototype.onClick = function () {
        this.select.emit({
            name: 'Value',
            value: this.value
        });
    };
    LinearGaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', [this.value], this.customColors);
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LinearGaugeComponent.prototype, "units", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinearGaugeComponent.prototype, "previousValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinearGaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        ViewChild('valueTextEl', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], LinearGaugeComponent.prototype, "valueTextEl", void 0);
    __decorate([
        ViewChild('unitsTextEl', { static: false }),
        __metadata("design:type", typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)
    ], LinearGaugeComponent.prototype, "unitsTextEl", void 0);
LinearGaugeComponent.ɵfac = function LinearGaugeComponent_Factory(t) { return ɵLinearGaugeComponent_BaseFactory(t || LinearGaugeComponent); };
LinearGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeComponent, selectors: [["ngx-charts-linear-gauge"]], viewQuery: function LinearGaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c48, true);
        ɵngcc0.ɵɵviewQuery(_c49, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTextEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.unitsTextEl = _t.first);
    } }, inputs: { max: "max", min: "min", value: "value", units: "units", previousValue: "previousValue", valueFormatting: "valueFormatting" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 15, vars: 38, consts: [[3, "view", "showLegend", "animations", "click"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["valueTextEl", ""], ["alignment-baseline", "before-edge", 1, "units"], ["unitsTextEl", ""], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]], template: function LinearGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵelement(3, "g", 3);
        ɵngcc0.ɵɵtemplate(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 4);
        ɵngcc0.ɵɵtemplate(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 5);
        ɵngcc0.ɵɵelementStart(6, "g");
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵelementStart(8, "text", 6, 7);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "g");
        ɵngcc0.ɵɵelementStart(12, "text", 8, 9);
        ɵngcc0.ɵɵtext(14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(33, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", ɵngcc0.ɵɵpureFunction0(36, _c50))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", ɵngcc0.ɵɵpureFunction0(37, _c50))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.valueTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.valueTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayValue, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.units, " ");
    } }, directives: [ChartComponent,
        BarComponent, ɵngcc1.NgIf], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"], encapsulation: 2, changeDetection: 0 });
var ɵLinearGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LinearGaugeComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinearGaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-linear-gauge',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\" (click)=\"onClick()\">\n      <svg:g class=\"linear-gauge chart\">\n        <svg:g\n          ngx-charts-bar\n          class=\"background-bar\"\n          [width]=\"dims.width\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-bar\n          [width]=\"valueScale(value)\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [fill]=\"colors.getColor(units)\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"5\"\n          x2=\"0\"\n          y2=\"15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"-5\"\n          x2=\"0\"\n          y2=\"-15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:g [attr.transform]=\"transform\">\n          <svg:g [attr.transform]=\"valueTranslate\">\n            <svg:text\n              #valueTextEl\n              class=\"value\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"valueTextTransform\"\n              alignment-baseline=\"after-edge\"\n            >\n              {{ displayValue }}\n            </svg:text>\n          </svg:g>\n\n          <svg:g [attr.transform]=\"unitsTranslate\">\n            <svg:text\n              #unitsTextEl\n              class=\"units\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"unitsTextTransform\"\n              alignment-baseline=\"before-edge\"\n            >\n              {{ units }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { max: [{
            type: Input
        }], min: [{
            type: Input
        }], value: [{
            type: Input
        }], units: [{
            type: Input
        }], previousValue: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], valueTextEl: [{
            type: ViewChild,
            args: ['valueTextEl', { static: false }]
        }], unitsTextEl: [{
            type: ViewChild,
            args: ['unitsTextEl', { static: false }]
        }] }); })();
    return LinearGaugeComponent;
}(BaseChartComponent));

var GaugeComponent = /** @class */ (function (_super) {
    __extends(GaugeComponent, _super);
    function GaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.min = 0;
        _this.max = 100;
        _this.bigSegments = 10;
        _this.smallSegments = 5;
        _this.showAxis = true;
        _this.startAngle = -120;
        _this.angleSpan = 240;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.showText = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.resizeScale = 1;
        _this.rotation = '';
        _this.textTransform = 'scale(1, 1)';
        _this.cornerRadius = 10;
        return _this;
    }
    GaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () { return _this.scaleText(); });
    };
    GaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (!this.showAxis) {
            if (!this.margin) {
                this.margin = [10, 20, 10, 20];
            }
        }
        else {
            if (!this.margin) {
                this.margin = [60, 100, 60, 100];
            }
        }
        if (this.startAngle < 0) {
            this.startAngle = (this.startAngle % 360) + 360;
        }
        this.angleSpan = Math.min(this.angleSpan, 360);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.domain = this.getDomain();
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
        this.arcs = this.getArcs();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.rotation = "rotate(" + this.startAngle + ")";
        setTimeout(function () { return _this.scaleText(); }, 50);
    };
    GaugeComponent.prototype.getArcs = function () {
        var arcs = [];
        var availableRadius = this.outerRadius * 0.7;
        var radiusPerArc = Math.min(availableRadius / this.results.length, 10);
        var arcWidth = radiusPerArc * 0.7;
        this.textRadius = this.outerRadius - this.results.length * radiusPerArc;
        this.cornerRadius = Math.floor(arcWidth / 2);
        var i = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var d = _a[_i];
            var outerRadius = this.outerRadius - i * radiusPerArc;
            var innerRadius = outerRadius - arcWidth;
            var backgroundArc = {
                endAngle: (this.angleSpan * Math.PI) / 180,
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                data: {
                    value: this.max,
                    name: d.name
                }
            };
            var valueArc = {
                endAngle: (Math.min(this.valueScale(d.value), this.angleSpan) * Math.PI) / 180,
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                data: {
                    value: d.value,
                    name: d.name
                }
            };
            var arc$$1 = {
                backgroundArc: backgroundArc,
                valueArc: valueArc
            };
            arcs.push(arc$$1);
            i++;
        }
        return arcs;
    };
    GaugeComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    GaugeComponent.prototype.getValueDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var dataMin = Math.min.apply(Math, values);
        var dataMax = Math.max.apply(Math, values);
        if (this.min !== undefined) {
            this.min = Math.min(this.min, dataMin);
        }
        else {
            this.min = dataMin;
        }
        if (this.max !== undefined) {
            this.max = Math.max(this.max, dataMax);
        }
        else {
            this.max = dataMax;
        }
        return [this.min, this.max];
    };
    GaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.angleSpan])
            .nice()
            .domain(this.valueDomain);
    };
    GaugeComponent.prototype.getDisplayValue = function () {
        var value = this.results.map(function (d) { return d.value; }).reduce(function (a, b) { return a + b; }, 0);
        if (this.textValue && 0 !== this.textValue.length) {
            return this.textValue.toLocaleString();
        }
        if (this.valueFormatting) {
            return this.valueFormatting(value);
        }
        return value.toLocaleString();
    };
    GaugeComponent.prototype.scaleText = function (repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        if (!this.showText) {
            return;
        }
        var width = this.textEl.nativeElement.getBoundingClientRect().width;
        var oldScale = this.resizeScale;
        if (width === 0) {
            this.resizeScale = 1;
        }
        else {
            var availableSpace = this.textRadius;
            this.resizeScale = Math.floor((availableSpace / (width / this.resizeScale)) * 100) / 100;
        }
        if (this.resizeScale !== oldScale) {
            this.textTransform = "scale(" + this.resizeScale + ", " + this.resizeScale + ")";
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () { return _this.scaleText(false); }, 50);
            }
        }
    };
    GaugeComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    GaugeComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            colors: this.colors,
            domain: this.domain,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    GaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    GaugeComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    GaugeComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    GaugeComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    GaugeComponent.prototype.trackBy = function (index, item) {
        return item.valueArc.data.name;
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "textValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "units", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "showAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeComponent.prototype, "axisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], GaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "showText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "margin", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], GaugeComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], GaugeComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], GaugeComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ViewChild('textEl', { static: false }),
        __metadata("design:type", typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object)
    ], GaugeComponent.prototype, "textEl", void 0);
GaugeComponent.ɵfac = function GaugeComponent_Factory(t) { return ɵGaugeComponent_BaseFactory(t || GaugeComponent); };
GaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeComponent, selectors: [["ngx-charts-gauge"]], contentQueries: function GaugeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function GaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { margin: "margin", startAngle: "startAngle", angleSpan: "angleSpan", min: "min", max: "max", activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", textValue: "textValue", units: "units", bigSegments: "bigSegments", smallSegments: "smallSegments", results: "results", showAxis: "showAxis", axisTickFormatting: "axisTickFormatting", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", showText: "showText" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "gauge", "chart"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting", 4, "ngIf"], ["alignment-baseline", "central", 3, "textAnchor", 4, "ngIf"], ["ngx-charts-gauge-arc", "", 3, "backgroundArc", "valueArc", "cornerRadius", "colors", "isActive", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "animations", "select", "activate", "deactivate"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting"], ["alignment-baseline", "central"], ["textEl", ""], ["x", "0", "dy", "0"], ["x", "0", "dy", "1.2em"]], template: function GaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function GaugeComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, GaugeComponent__svg_g_2_Template, 2, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, GaugeComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, GaugeComponent__svg_text_4_Template, 6, 5, "text", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showText);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, GaugeArcComponent,
        GaugeAxisComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"], encapsulation: 2, changeDetection: 0 });
var ɵGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(GaugeComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-gauge',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"gauge chart\">\n        <svg:g *ngFor=\"let arc of arcs; trackBy: trackBy\" [attr.transform]=\"rotation\">\n          <svg:g\n            ngx-charts-gauge-arc\n            [backgroundArc]=\"arc.backgroundArc\"\n            [valueArc]=\"arc.valueArc\"\n            [cornerRadius]=\"cornerRadius\"\n            [colors]=\"colors\"\n            [isActive]=\"isActive(arc.valueArc.data)\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [valueFormatting]=\"valueFormatting\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          ></svg:g>\n        </svg:g>\n\n        <svg:g\n          ngx-charts-gauge-axis\n          *ngIf=\"showAxis\"\n          [bigSegments]=\"bigSegments\"\n          [smallSegments]=\"smallSegments\"\n          [min]=\"min\"\n          [max]=\"max\"\n          [radius]=\"outerRadius\"\n          [angleSpan]=\"angleSpan\"\n          [valueScale]=\"valueScale\"\n          [startAngle]=\"startAngle\"\n          [tickFormatting]=\"axisTickFormatting\"\n        ></svg:g>\n\n        <svg:text\n          #textEl\n          *ngIf=\"showText\"\n          [style.textAnchor]=\"'middle'\"\n          [attr.transform]=\"textTransform\"\n          alignment-baseline=\"central\"\n        >\n          <tspan x=\"0\" dy=\"0\">{{ displayValue }}</tspan>\n          <tspan x=\"0\" dy=\"1.2em\">{{ units }}</tspan>\n        </svg:text>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { margin: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], textValue: [{
            type: Input
        }], units: [{
            type: Input
        }], bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], results: [{
            type: Input
        }], showAxis: [{
            type: Input
        }], axisTickFormatting: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], showText: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], textEl: [{
            type: ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
    return GaugeComponent;
}(BaseChartComponent));

var GaugeArcComponent = /** @class */ (function () {
    function GaugeArcComponent() {
        this.isActive = false;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    GaugeArcComponent.prototype.tooltipText = function (arc$$1) {
        var label = formatLabel(arc$$1.data.name);
        var val;
        if (this.valueFormatting) {
            val = this.valueFormatting(arc$$1.data.value);
        }
        else {
            val = formatLabel(arc$$1.data.value);
        }
        return "\n      <span class=\"tooltip-label\">" + escapeLabel(label) + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "backgroundArc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "valueArc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "cornerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof ColorHelper !== "undefined" && ColorHelper) === "function" ? _a : Object)
    ], GaugeArcComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "isActive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], GaugeArcComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _b : Object)
    ], GaugeArcComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "deactivate", void 0);
GaugeArcComponent.ɵfac = function GaugeArcComponent_Factory(t) { return new (t || GaugeArcComponent)(); };
GaugeArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeArcComponent, selectors: [["g", "ngx-charts-gauge-arc", ""]], inputs: { isActive: "isActive", tooltipDisabled: "tooltipDisabled", animations: "animations", backgroundArc: "backgroundArc", valueArc: "valueArc", cornerRadius: "cornerRadius", colors: "colors", valueFormatting: "valueFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, attrs: _c51, decls: 2, vars: 23, consts: [["ngx-charts-pie-arc", "", 1, "background-arc", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "data", "animate", "pointerEvents"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "fill", "data", "animate", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function GaugeArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵlistener("select", function GaugeArcComponent_Template__svg_g_select_1_listener($event) { return ctx.select.emit($event); })("activate", function GaugeArcComponent_Template__svg_g_activate_1_listener($event) { return ctx.activate.emit($event); })("deactivate", function GaugeArcComponent_Template__svg_g_deactivate_1_listener($event) { return ctx.deactivate.emit($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.backgroundArc.endAngle)("innerRadius", ctx.backgroundArc.innerRadius)("outerRadius", ctx.backgroundArc.outerRadius)("cornerRadius", ctx.cornerRadius)("data", ctx.backgroundArc.data)("animate", false)("pointerEvents", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.valueArc.endAngle)("innerRadius", ctx.valueArc.innerRadius)("outerRadius", ctx.valueArc.outerRadius)("cornerRadius", ctx.cornerRadius)("fill", ctx.colors.getColor(ctx.valueArc.data.name))("data", ctx.valueArc.data)("animate", ctx.animations)("isActive", ctx.isActive)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx.tooltipTemplate ? undefined : ctx.tooltipText(ctx.valueArc))("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.valueArc.data);
    } }, directives: [PieArcComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-arc]',
                template: "\n    <svg:g ngx-charts-pie-arc\n      class=\"background-arc\"\n      [startAngle]=\"0\"\n      [endAngle]=\"backgroundArc.endAngle\"\n      [innerRadius]=\"backgroundArc.innerRadius\"\n      [outerRadius]=\"backgroundArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [data]=\"backgroundArc.data\"\n      [animate]=\"false\"\n      [pointerEvents]=\"false\">\n    </svg:g>\n    <svg:g ngx-charts-pie-arc\n      [startAngle]=\"0\"\n      [endAngle]=\"valueArc.endAngle\"\n      [innerRadius]=\"valueArc.innerRadius\"\n      [outerRadius]=\"valueArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [fill]=\"colors.getColor(valueArc.data.name)\"\n      [data]=\"valueArc.data\"\n      [animate]=\"animations\"\n      [isActive]=\"isActive\"\n      (select)=\"select.emit($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(valueArc)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"valueArc.data\">\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], backgroundArc: [{
            type: Input
        }], valueArc: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return GaugeArcComponent;
}());

var GaugeAxisComponent = /** @class */ (function () {
    function GaugeAxisComponent() {
        this.rotate = '';
    }
    GaugeAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GaugeAxisComponent.prototype.update = function () {
        this.rotationAngle = -90 + this.startAngle;
        this.rotate = "rotate(" + this.rotationAngle + ")";
        this.ticks = this.getTicks();
    };
    GaugeAxisComponent.prototype.getTicks = function () {
        var bigTickSegment = this.angleSpan / this.bigSegments;
        var smallTickSegment = bigTickSegment / (this.smallSegments);
        var tickLength = 20;
        var ticks = {
            big: [],
            small: []
        };
        var startDistance = this.radius + 10;
        var textDist = startDistance + tickLength + 10;
        for (var i = 0; i <= this.bigSegments; i++) {
            var angleDeg = i * bigTickSegment;
            var angle = angleDeg * Math.PI / 180;
            var textAnchor = this.getTextAnchor(angleDeg);
            var skip = false;
            if (i === 0 && this.angleSpan === 360) {
                skip = true;
            }
            if (!skip) {
                var text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                if (this.tickFormatting) {
                    text = this.tickFormatting(text);
                }
                ticks.big.push({
                    line: this.getTickPath(startDistance, tickLength, angle),
                    textAnchor: textAnchor,
                    text: text,
                    textTransform: "\n            translate(" + textDist * Math.cos(angle) + ", " + textDist * Math.sin(angle) + ") rotate(" + -this.rotationAngle + ")\n          "
                });
            }
            if (i === this.bigSegments) {
                continue;
            }
            for (var j = 1; j <= this.smallSegments; j++) {
                var smallAngleDeg = angleDeg + j * smallTickSegment;
                var smallAngle = smallAngleDeg * Math.PI / 180;
                ticks.small.push({
                    line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                });
            }
        }
        return ticks;
    };
    GaugeAxisComponent.prototype.getTextAnchor = function (angle) {
        // [0, 45] = 'middle';
        // [46, 135] = 'start';
        // [136, 225] = 'middle';
        // [226, 315] = 'end';
        angle = (this.startAngle + angle) % 360;
        var textAnchor = 'middle';
        if (angle > 45 && angle <= 135) {
            textAnchor = 'start';
        }
        else if (angle > 225 && angle <= 315) {
            textAnchor = 'end';
        }
        return textAnchor;
    };
    GaugeAxisComponent.prototype.getTickPath = function (startDistance, tickLength, angle) {
        var y1 = startDistance * Math.sin(angle);
        var y2 = (startDistance + tickLength) * Math.sin(angle);
        var x1 = startDistance * Math.cos(angle);
        var x2 = (startDistance + tickLength) * Math.cos(angle);
        var points = [{ x: x1, y: y1 }, { x: x2, y: y2 }];
        var lineGenerator = line().x(function (d) { return d.x; }).y(function (d) { return d.y; });
        return lineGenerator(points);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeAxisComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeAxisComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "radius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "valueScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "tickFormatting", void 0);
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c52, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: "\n    <svg:g [attr.transform]=\"rotate\">\n        <svg:g *ngFor=\"let tick of ticks.big\"\n            class=\"gauge-tick gauge-tick-large\">\n            <svg:path [attr.d]=\"tick.line\" />\n        </svg:g>\n        <svg:g *ngFor=\"let tick of ticks.big\"\n            class=\"gauge-tick gauge-tick-large\">\n            <svg:text\n                [style.textAnchor]=\"tick.textAnchor\"\n                [attr.transform]=\"tick.textTransform\"\n                alignment-baseline=\"central\">\n                {{tick.text}}\n            </svg:text>\n        </svg:g>\n        <svg:g *ngFor=\"let tick of ticks.small\"\n            class=\"gauge-tick gauge-tick-small\">\n            <svg:path [attr.d]=\"tick.line\" />\n        </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], radius: [{
            type: Input
        }], valueScale: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }] }); })();
    return GaugeAxisComponent;
}());

var GaugeModule = /** @class */ (function () {
    function GaugeModule() {
    }
GaugeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: GaugeModule });
GaugeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function GaugeModule_Factory(t) { return new (t || GaugeModule)(); }, imports: [[ChartCommonModule, PieChartModule, BarChartModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GaugeModule, { declarations: [LinearGaugeComponent,
        GaugeComponent,
        GaugeArcComponent,
        GaugeAxisComponent], imports: [ChartCommonModule,
        PieChartModule,
        BarChartModule], exports: [LinearGaugeComponent,
        GaugeComponent,
        GaugeArcComponent,
        GaugeAxisComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, BarChartModule],
                declarations: [
                    LinearGaugeComponent,
                    GaugeComponent,
                    GaugeArcComponent,
                    GaugeAxisComponent
                ],
                exports: [
                    LinearGaugeComponent,
                    GaugeComponent,
                    GaugeArcComponent,
                    GaugeAxisComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return GaugeModule;
}());

var NgxChartsModule = /** @class */ (function () {
    function NgxChartsModule() {
    }
NgxChartsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxChartsModule });
NgxChartsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxChartsModule_Factory(t) { return new (t || NgxChartsModule)(); }, imports: [ChartCommonModule,
        AreaChartModule,
        BarChartModule,
        BubbleChartModule,
        ForceDirectedGraphModule,
        HeatMapModule,
        LineChartModule,
        PolarChartModule,
        NumberCardModule,
        PieChartModule,
        TreeMapModule,
        GaugeModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxChartsModule, { exports: [ChartCommonModule,
        AreaChartModule,
        BarChartModule,
        BubbleChartModule,
        ForceDirectedGraphModule,
        HeatMapModule,
        LineChartModule,
        PolarChartModule,
        NumberCardModule,
        PieChartModule,
        TreeMapModule,
        GaugeModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxChartsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    ChartCommonModule,
                    AreaChartModule,
                    BarChartModule,
                    BubbleChartModule,
                    ForceDirectedGraphModule,
                    HeatMapModule,
                    LineChartModule,
                    PolarChartModule,
                    NumberCardModule,
                    PieChartModule,
                    TreeMapModule,
                    GaugeModule
                ]
            }]
    }], function () { return []; }, null); })();
    return NgxChartsModule;
}());

function tickFormat(fieldType, groupByType) {
    return function (label) {
        if (label === 'No Value' || label === 'Other') {
            return label;
        }
        if (fieldType === 'date' && groupByType === 'groupBy') {
            var formatter = timeFormat('MM/DD/YYYY');
            return formatter(label);
        }
        return label.toString();
    };
}

export { NgxChartsModule, ChartCommonModule, LegendComponent, ScaleLegendComponent, LegendEntryComponent, AdvancedLegendComponent, TooltipModule, TooltipService, TooltipContentComponent, TooltipDirective, StyleTypes, AlignmentTypes, ShowTypes, AxesModule, AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent, reduceTicks, CountUpDirective, count, decimalChecker, Timeline, ColorHelper, ChartComponent, AreaComponent, BaseChartComponent, CircleComponent, CircleSeriesComponent, gridSize, gridLayout, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, TooltipArea, tickFormat, trimLabel, calculateViewDimensions, formatLabel, escapeLabel, getUniqueXDomainValues, getScaleType, AreaChartModule, AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent, BarChartModule, BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, SeriesHorizontal, BarLabelComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, D0Types, SeriesVerticalComponent, BubbleChartModule, BubbleChartComponent, getDomain, getScale, BubbleSeriesComponent, ForceDirectedGraphModule, ForceDirectedGraphComponent, HeatMapModule, HeatMapComponent, HeatMapCellComponent, HeatCellSeriesComponent, LineChartModule, LineChartComponent, LineComponent, LineSeriesComponent, PolarChartModule, PolarChartComponent, PolarSeriesComponent, NumberCardModule, NumberCardComponent, CardComponent, CardSeriesComponent, PieChartModule, AdvancedPieChartComponent, PieChartComponent, PieArcComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent, PieLabelComponent, TreeMapModule, TreeMapComponent, TreeMapCellComponent, TreeMapCellSeriesComponent, GaugeModule, GaugeArcComponent, GaugeAxisComponent, GaugeComponent, LinearGaugeComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNtLmpzIiwic291cmNlcyI6WyJlc20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUVPO0FBQ1A7Ozs7O2dZQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQU9PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FFTztBQUNQOzs7OztnS0FBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztnREFTc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBZU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBUU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQVFPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FLTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU91QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFPbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFpQjhCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT3dCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU9pQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT21DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU9tQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFRTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkF1Qm9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUtPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFlMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVNrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFpQndCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFNTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUytCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBb0J5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9Cc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBb0J1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9Cb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUJnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWlCeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBT087QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWlDdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXFCNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBa0I4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBYTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVNvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztnREFXaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FNTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU9nQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVN5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWVzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBbUJPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXFCMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWV3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkF5QjRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU82QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVNrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUzBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBdUJ1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFheUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFleUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT21DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVN5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWVzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU8yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWlCb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFrQndCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBsaWNhdGlvblJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBJbmplY3RhYmxlLCBJbmplY3RvciwgSW5wdXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgVmlld0VuY2Fwc3VsYXRpb24sIEhvc3RMaXN0ZW5lciwgVmlld0NoaWxkLCBIb3N0QmluZGluZywgUmVuZGVyZXIyLCBEaXJlY3RpdmUsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBWaWV3Q29udGFpbmVyUmVmLCBOZ01vZHVsZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBOZ1pvbmUsIFRlbXBsYXRlUmVmLCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyB0cmlnZ2VyLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgRG9tU2FuaXRpemVyIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyByZ2IgfSBmcm9tICdkMy1jb2xvcic7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHJhbmdlLCBtaW4sIG1heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVMaW5lYXIsIHNjYWxlT3JkaW5hbCwgc2NhbGVRdWFudGlsZSwgc2NhbGVUaW1lLCBzY2FsZVBvaW50IH0gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHsgYnJ1c2hYIH0gZnJvbSAnZDMtYnJ1c2gnO1xuaW1wb3J0IHsgc2VsZWN0LCBldmVudCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBjdXJ2ZUxpbmVhciwgYXJlYSwgbGluZSwgY3VydmVDYXJkaW5hbENsb3NlZCwgbGluZVJhZGlhbCwgYXJjLCBwaWUgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyBmb3JjZUNvbGxpZGUsIGZvcmNlTGluaywgZm9yY2VNYW55Qm9keSwgZm9yY2VTaW11bGF0aW9uLCBmb3JjZVgsIGZvcmNlWSB9IGZyb20gJ2QzLWZvcmNlJztcbmltcG9ydCB7IGludGVycG9sYXRlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0JztcbmltcG9ydCB7IHRyZWVtYXAsIHN0cmF0aWZ5IH0gZnJvbSAnZDMtaGllcmFyY2h5JztcbmltcG9ydCB7IHRpbWVGb3JtYXQgfSBmcm9tICdkMy10aW1lLWZvcm1hdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XG5cbi8vIFRoZSBleHBvcnQgaXMgbmVlZGVkIGhlcmUgdG8gZ2VuZXJhdGUgYSB2YWxpZCBwb2x5ZmlsbHMubWV0YWRhdGEuanNvbiBmaWxlXG5mdW5jdGlvbiBuZ3hDaGFydHNQb2x5ZmlsbHMoKSB7XG4gICAgLy8gSUUxMSBmaXhcbiAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zd2ltbGFuZS9uZ3gtY2hhcnRzL2lzc3Vlcy8zODZcbiAgICBpZiAodHlwZW9mIChTVkdFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFNWR0VsZW1lbnQucHJvdG90eXBlLmNvbnRhaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBTVkdFbGVtZW50LnByb3RvdHlwZS5jb250YWlucyA9IEhUTUxEaXZFbGVtZW50LnByb3RvdHlwZS5jb250YWlucztcbiAgICB9XG59XG5uZ3hDaGFydHNQb2x5ZmlsbHMoKTtcblxudmFyIFBsYWNlbWVudFR5cGVzO1xuKGZ1bmN0aW9uIChQbGFjZW1lbnRUeXBlcykge1xuICAgIFBsYWNlbWVudFR5cGVzW1BsYWNlbWVudFR5cGVzW1widG9wXCJdID0gJ3RvcCddID0gXCJ0b3BcIjtcbiAgICBQbGFjZW1lbnRUeXBlc1tQbGFjZW1lbnRUeXBlc1tcImJvdHRvbVwiXSA9ICdib3R0b20nXSA9IFwiYm90dG9tXCI7XG4gICAgUGxhY2VtZW50VHlwZXNbUGxhY2VtZW50VHlwZXNbXCJsZWZ0XCJdID0gJ2xlZnQnXSA9IFwibGVmdFwiO1xuICAgIFBsYWNlbWVudFR5cGVzW1BsYWNlbWVudFR5cGVzW1wicmlnaHRcIl0gPSAncmlnaHQnXSA9IFwicmlnaHRcIjtcbn0pKFBsYWNlbWVudFR5cGVzIHx8IChQbGFjZW1lbnRUeXBlcyA9IHt9KSk7XG5cbnZhciBjYXJldE9mZnNldCA9IDc7XG5mdW5jdGlvbiB2ZXJ0aWNhbFBvc2l0aW9uKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCkge1xuICAgIGlmIChhbGlnbm1lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiBlbERpbWVuc2lvbnMudG9wIC0gY2FyZXRPZmZzZXQ7XG4gICAgfVxuICAgIGlmIChhbGlnbm1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiBlbERpbWVuc2lvbnMudG9wICsgZWxEaW1lbnNpb25zLmhlaWdodCAtIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCArIGNhcmV0T2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoYWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gZWxEaW1lbnNpb25zLnRvcCArIGVsRGltZW5zaW9ucy5oZWlnaHQgLyAyIC0gcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGhvcml6b250YWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpIHtcbiAgICBpZiAoYWxpZ25tZW50ID09PSAnbGVmdCcpIHtcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy5sZWZ0IC0gY2FyZXRPZmZzZXQ7XG4gICAgfVxuICAgIGlmIChhbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy5sZWZ0ICsgZWxEaW1lbnNpb25zLndpZHRoIC0gcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggKyBjYXJldE9mZnNldDtcbiAgICB9XG4gICAgaWYgKGFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy5sZWZ0ICsgZWxEaW1lbnNpb25zLndpZHRoIC8gMiAtIHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUG9zaXRpb24gaGVscGVyIGZvciB0aGUgcG9wb3ZlciBkaXJlY3RpdmUuXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIFBvc2l0aW9uSGVscGVyXG4gKi9cbnZhciBQb3NpdGlvbkhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3NpdGlvbkhlbHBlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHZlcnRpY2FsIGFsaWdubWVudCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge2FueX0gcG9wb3ZlckRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge2FueX0gYWxpZ25tZW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBQb3NpdGlvbkhlbHBlclxuICAgICAqL1xuICAgIFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQWxpZ25tZW50ID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdmVydGljYWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xuICAgICAgICBpZiAocmVzdWx0ICsgcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB2ZXJ0aWNhbCBjYXJldCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge2FueX0gcG9wb3ZlckRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge2FueX0gY2FyZXREaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcbiAgICAgKi9cbiAgICBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVWZXJ0aWNhbENhcmV0ID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBlbERpbWVuc2lvbnMuaGVpZ2h0IC8gMiAtIGNhcmV0RGltZW5zaW9ucy5oZWlnaHQgLyAyICsgY2FyZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCAtIGVsRGltZW5zaW9ucy5oZWlnaHQgLyAyIC0gY2FyZXREaW1lbnNpb25zLmhlaWdodCAvIDIgLSBjYXJldE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC8gMiAtIGNhcmV0RGltZW5zaW9ucy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3BvdmVyUG9zaXRpb24gPSB2ZXJ0aWNhbFBvc2l0aW9uKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCk7XG4gICAgICAgIGlmIChwb3BvdmVyUG9zaXRpb24gKyBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAocG9wb3ZlclBvc2l0aW9uICsgcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhvcnogYWxpZ25tZW50IHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHthbnl9IGVsRGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7YW55fSBwb3BvdmVyRGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXG4gICAgICovXG4gICAgUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbEFsaWdubWVudCA9IGZ1bmN0aW9uIChlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGhvcml6b250YWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xuICAgICAgICBpZiAocmVzdWx0ICsgcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93LmlubmVyV2lkdGggLSBwb3BvdmVyRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhvcnogY2FyZXQgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxEaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHthbnl9IHBvcG92ZXJEaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHthbnl9IGNhcmV0RGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXG4gICAgICovXG4gICAgUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbENhcmV0ID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZWxEaW1lbnNpb25zLndpZHRoIC8gMiAtIGNhcmV0RGltZW5zaW9ucy53aWR0aCAvIDIgKyBjYXJldE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCAtIGVsRGltZW5zaW9ucy53aWR0aCAvIDIgLSBjYXJldERpbWVuc2lvbnMud2lkdGggLyAyIC0gY2FyZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC8gMiAtIGNhcmV0RGltZW5zaW9ucy53aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcG92ZXJQb3NpdGlvbiA9IGhvcml6b250YWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xuICAgICAgICBpZiAocG9wb3ZlclBvc2l0aW9uICsgcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IChwb3BvdmVyUG9zaXRpb24gKyBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCAtIHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBlbGVtZW50J3MgcG9zaXRpb24gc2hvdWxkIGJlIGZsaXBwZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxEaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHthbnl9IHBvcG92ZXJEaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxuICAgICAqIEBwYXJhbSB7YW55fSBzcGFjaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcbiAgICAgKi9cbiAgICBQb3NpdGlvbkhlbHBlci5zaG91bGRGbGlwID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIHBsYWNlbWVudCwgc3BhY2luZykge1xuICAgICAgICB2YXIgZmxpcCA9IGZhbHNlO1xuICAgICAgICBpZiAocGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBpZiAoZWxEaW1lbnNpb25zLmxlZnQgKyBlbERpbWVuc2lvbnMud2lkdGggKyBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCArIHNwYWNpbmcgPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgaWYgKGVsRGltZW5zaW9ucy5sZWZ0IC0gcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggLSBzcGFjaW5nIDwgMCkge1xuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICBpZiAoZWxEaW1lbnNpb25zLnRvcCAtIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCAtIHNwYWNpbmcgPCAwKSB7XG4gICAgICAgICAgICAgICAgZmxpcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIGlmIChlbERpbWVuc2lvbnMudG9wICsgZWxEaW1lbnNpb25zLmhlaWdodCArIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCArIHNwYWNpbmcgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBmbGlwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxpcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIGNhcmV0XG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxuICAgICAqIEBwYXJhbSB7YW55fSBlbG1EaW1cbiAgICAgKiBAcGFyYW0ge2FueX0gaG9zdERpbVxuICAgICAqIEBwYXJhbSB7YW55fSBjYXJldERpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge2FueX0gYWxpZ25tZW50XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcbiAgICAgKi9cbiAgICBQb3NpdGlvbkhlbHBlci5wb3NpdGlvbkNhcmV0ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCBjYXJldERpbWVuc2lvbnMsIGFsaWdubWVudCkge1xuICAgICAgICB2YXIgdG9wID0gMDtcbiAgICAgICAgdmFyIGxlZnQgPSAwO1xuICAgICAgICBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5yaWdodCkge1xuICAgICAgICAgICAgbGVmdCA9IC03O1xuICAgICAgICAgICAgdG9wID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlVmVydGljYWxDYXJldChob3N0RGltLCBlbG1EaW0sIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmxlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSBlbG1EaW0ud2lkdGg7XG4gICAgICAgICAgICB0b3AgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVWZXJ0aWNhbENhcmV0KGhvc3REaW0sIGVsbURpbSwgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMudG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBlbG1EaW0uaGVpZ2h0O1xuICAgICAgICAgICAgbGVmdCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZUhvcml6b250YWxDYXJldChob3N0RGltLCBlbG1EaW0sIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmJvdHRvbSkge1xuICAgICAgICAgICAgdG9wID0gLTc7XG4gICAgICAgICAgICBsZWZ0ID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbENhcmV0KGhvc3REaW0sIGVsbURpbSwgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBjb250ZW50XG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxuICAgICAqIEBwYXJhbSB7YW55fSBlbG1EaW1cbiAgICAgKiBAcGFyYW0ge2FueX0gaG9zdERpbVxuICAgICAqIEBwYXJhbSB7YW55fSBzcGFjaW5nXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXG4gICAgICovXG4gICAgUG9zaXRpb25IZWxwZXIucG9zaXRpb25Db250ZW50ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCBzcGFjaW5nLCBhbGlnbm1lbnQpIHtcbiAgICAgICAgdmFyIHRvcCA9IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMucmlnaHQpIHtcbiAgICAgICAgICAgIGxlZnQgPSBob3N0RGltLmxlZnQgKyBob3N0RGltLndpZHRoICsgc3BhY2luZztcbiAgICAgICAgICAgIHRvcCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQWxpZ25tZW50KGhvc3REaW0sIGVsbURpbSwgYWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmxlZnQpIHtcbiAgICAgICAgICAgIGxlZnQgPSBob3N0RGltLmxlZnQgLSBlbG1EaW0ud2lkdGggLSBzcGFjaW5nO1xuICAgICAgICAgICAgdG9wID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlVmVydGljYWxBbGlnbm1lbnQoaG9zdERpbSwgZWxtRGltLCBhbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMudG9wKSB7XG4gICAgICAgICAgICB0b3AgPSBob3N0RGltLnRvcCAtIGVsbURpbS5oZWlnaHQgLSBzcGFjaW5nO1xuICAgICAgICAgICAgbGVmdCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZUhvcml6b250YWxBbGlnbm1lbnQoaG9zdERpbSwgZWxtRGltLCBhbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMuYm90dG9tKSB7XG4gICAgICAgICAgICB0b3AgPSBob3N0RGltLnRvcCArIGhvc3REaW0uaGVpZ2h0ICsgc3BhY2luZztcbiAgICAgICAgICAgIGxlZnQgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVIb3Jpem9udGFsQWxpZ25tZW50KGhvc3REaW0sIGVsbURpbSwgYWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHBsYWNlbWVudCBiYXNlZCBvbiBmbGlwXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxuICAgICAqIEBwYXJhbSB7YW55fSBlbG1EaW1cbiAgICAgKiBAcGFyYW0ge2FueX0gaG9zdERpbVxuICAgICAqIEBwYXJhbSB7YW55fSBzcGFjaW5nXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcbiAgICAgKi9cbiAgICBQb3NpdGlvbkhlbHBlci5kZXRlcm1pbmVQbGFjZW1lbnQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBlbG1EaW0sIGhvc3REaW0sIHNwYWNpbmcpIHtcbiAgICAgICAgdmFyIHNob3VsZEZsaXAgPSBQb3NpdGlvbkhlbHBlci5zaG91bGRGbGlwKGhvc3REaW0sIGVsbURpbSwgcGxhY2VtZW50LCBzcGFjaW5nKTtcbiAgICAgICAgaWYgKHNob3VsZEZsaXApIHtcbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsYWNlbWVudFR5cGVzLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGxhY2VtZW50VHlwZXMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLnRvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQbGFjZW1lbnRUeXBlcy5ib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQbGFjZW1lbnRUeXBlcy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgICB9O1xuICAgIHJldHVybiBQb3NpdGlvbkhlbHBlcjtcbn0oKSk7XG5cbnZhciBTdHlsZVR5cGVzO1xuKGZ1bmN0aW9uIChTdHlsZVR5cGVzKSB7XG4gICAgU3R5bGVUeXBlc1tTdHlsZVR5cGVzW1wicG9wb3ZlclwiXSA9ICdwb3BvdmVyJ10gPSBcInBvcG92ZXJcIjtcbiAgICBTdHlsZVR5cGVzW1N0eWxlVHlwZXNbXCJ0b29sdGlwXCJdID0gJ3Rvb2x0aXAnXSA9IFwidG9vbHRpcFwiO1xufSkoU3R5bGVUeXBlcyB8fCAoU3R5bGVUeXBlcyA9IHt9KSk7XG5cbnZhciBBbGlnbm1lbnRUeXBlcztcbihmdW5jdGlvbiAoQWxpZ25tZW50VHlwZXMpIHtcbiAgICBBbGlnbm1lbnRUeXBlc1tBbGlnbm1lbnRUeXBlc1tcImxlZnRcIl0gPSAnbGVmdCddID0gXCJsZWZ0XCI7XG4gICAgQWxpZ25tZW50VHlwZXNbQWxpZ25tZW50VHlwZXNbXCJjZW50ZXJcIl0gPSAnY2VudGVyJ10gPSBcImNlbnRlclwiO1xuICAgIEFsaWdubWVudFR5cGVzW0FsaWdubWVudFR5cGVzW1wicmlnaHRcIl0gPSAncmlnaHQnXSA9IFwicmlnaHRcIjtcbn0pKEFsaWdubWVudFR5cGVzIHx8IChBbGlnbm1lbnRUeXBlcyA9IHt9KSk7XG5cbnZhciBTaG93VHlwZXM7XG4oZnVuY3Rpb24gKFNob3dUeXBlcykge1xuICAgIFNob3dUeXBlc1tTaG93VHlwZXNbXCJhbGxcIl0gPSAnYWxsJ10gPSBcImFsbFwiO1xuICAgIFNob3dUeXBlc1tTaG93VHlwZXNbXCJmb2N1c1wiXSA9ICdmb2N1cyddID0gXCJmb2N1c1wiO1xuICAgIFNob3dUeXBlc1tTaG93VHlwZXNbXCJtb3VzZW92ZXJcIl0gPSAnbW91c2VvdmVyJ10gPSBcIm1vdXNlb3ZlclwiO1xufSkoU2hvd1R5cGVzIHx8IChTaG93VHlwZXMgPSB7fSkpO1xuXG4vKipcbiAqIEluamVjdGlvbiBzZXJ2aWNlIGlzIGEgaGVscGVyIHRvIGFwcGVuZCBjb21wb25lbnRzXG4gKiBkeW5hbWljYWxseSB0byBhIGtub3duIGxvY2F0aW9uIGluIHRoZSBET00sIG1vc3RcbiAqIG5vdGVhYmx5IGZvciBkaWFsb2dzL3Rvb2x0aXBzIGFwcGVuZGluZyB0byBib2R5LlxuICpcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBJbmplY3Rpb25TZXJ2aWNlXG4gKi9cbnZhciBJbmplY3Rpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluamVjdGlvblNlcnZpY2UoYXBwbGljYXRpb25SZWYsIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgaW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvblJlZiA9IGFwcGxpY2F0aW9uUmVmO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgIH1cbiAgICBJbmplY3Rpb25TZXJ2aWNlXzEgPSBJbmplY3Rpb25TZXJ2aWNlO1xuICAgIC8qKlxuICAgICAqIFNldHMgYSBkZWZhdWx0IGdsb2JhbCByb290IHZpZXcgY29udGFpbmVyLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiB0aGluZ3MgbGlrZSBuZ1VwZ3JhZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBBcHBsaWNhdGlvblJlZiByb290LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRhaW5lclxuICAgICAqL1xuICAgIEluamVjdGlvblNlcnZpY2Uuc2V0R2xvYmFsUm9vdFZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIEluamVjdGlvblNlcnZpY2VfMS5nbG9iYWxSb290Vmlld0NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvb3QgdmlldyBjb250YWluZXIgdG8gaW5qZWN0IHRoZSBjb21wb25lbnQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgSW5qZWN0aW9uU2VydmljZVxuICAgICAqL1xuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLmdldFJvb3RWaWV3Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdENvbXBvbmVudHMgPSB0aGlzLmFwcGxpY2F0aW9uUmVmLmNvbXBvbmVudHM7XG4gICAgICAgIC8vIGZpeCBjYW5ub3QgcmVhZCBsZW5ndGggb2YgdW5kZWZpbmVkXG4gICAgICAgIGlmIChyb290Q29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKHJvb3RDb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdENvbXBvbmVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIGlmIChJbmplY3Rpb25TZXJ2aWNlXzEuZ2xvYmFsUm9vdFZpZXdDb250YWluZXIpXG4gICAgICAgICAgICByZXR1cm4gSW5qZWN0aW9uU2VydmljZV8xLmdsb2JhbFJvb3RWaWV3Q29udGFpbmVyO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZXcgQ29udGFpbmVyIG5vdCBmb3VuZCEgbmdVcGdyYWRlIG5lZWRzIHRvIG1hbnVhbGx5IHNldCB0aGlzIHZpYSBzZXRSb290Vmlld0NvbnRhaW5lci4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCByb290IHZpZXcgY29udGFpbmVyLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICAgKiB0aGluZ3MgbGlrZSBuZ1VwZ3JhZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBBcHBsaWNhdGlvblJlZiByb290LlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcbiAgICAgKi9cbiAgICBJbmplY3Rpb25TZXJ2aWNlLnByb3RvdHlwZS5zZXRSb290Vmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaHRtbCBlbGVtZW50IGZvciBhIGNvbXBvbmVudCByZWYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudFJlZjxhbnk+fSBjb21wb25lbnRSZWZcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgSW5qZWN0aW9uU2VydmljZVxuICAgICAqL1xuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLmdldENvbXBvbmVudFJvb3ROb2RlID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xuICAgICAgICAvLyB0aGUgdG9wIG1vc3QgY29tcG9uZW50IHJvb3Qgbm9kZSBoYXMgbm8gYGhvc3RWaWV3YFxuICAgICAgICBpZiAoIWNvbXBvbmVudFJlZi5ob3N0VmlldylcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmLmhvc3RWaWV3LnJvb3ROb2Rlc1swXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvb3QgY29tcG9uZW50IGNvbnRhaW5lciBodG1sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgSW5qZWN0aW9uU2VydmljZVxuICAgICAqL1xuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLmdldFJvb3RWaWV3Q29udGFpbmVyTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUodGhpcy5nZXRSb290Vmlld0NvbnRhaW5lcigpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2plY3RzIHRoZSBiaW5kaW5ncyBvbnRvIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50UmVmPGFueT59IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBJbmplY3Rpb25TZXJ2aWNlXG4gICAgICovXG4gICAgSW5qZWN0aW9uU2VydmljZS5wcm90b3R5cGUucHJvamVjdENvbXBvbmVudEJpbmRpbmdzID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgYmluZGluZ3MpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoYmluZGluZ3MuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZ0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiaW5kaW5ncy5pbnB1dHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYmluZGluZ0tleXNfMSA9IGJpbmRpbmdLZXlzOyBfaSA8IGJpbmRpbmdLZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nTmFtZSA9IGJpbmRpbmdLZXlzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaW5zdGFuY2VbYmluZGluZ05hbWVdID0gYmluZGluZ3MuaW5wdXRzW2JpbmRpbmdOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmluZGluZ3Mub3V0cHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJpbmRpbmdzLm91dHB1dHMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgZXZlbnRLZXlzXzEgPSBldmVudEtleXM7IF9hIDwgZXZlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudEtleXNfMVtfYV07XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtldmVudE5hbWVdID0gYmluZGluZ3Mub3V0cHV0c1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIGNvbXBvbmVudCB0byBhIGFkamFjZW50IGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7VHlwZTxUPn0gY29tcG9uZW50Q2xhc3NcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zPXt9XVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gW2xvY2F0aW9uPXRoaXMuZ2V0Um9vdFZpZXdDb250YWluZXJOb2RlKCldXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcbiAgICAgKi9cbiAgICBJbmplY3Rpb25TZXJ2aWNlLnByb3RvdHlwZS5hcHBlbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MsIGJpbmRpbmdzLCBsb2NhdGlvbikge1xuICAgICAgICBpZiAoYmluZGluZ3MgPT09IHZvaWQgMCkgeyBiaW5kaW5ncyA9IHt9OyB9XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdm9pZCAwKSB7IGxvY2F0aW9uID0gdGhpcy5nZXRSb290Vmlld0NvbnRhaW5lck5vZGUoKTsgfVxuICAgICAgICB2YXIgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudENsYXNzKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpO1xuICAgICAgICB2YXIgYXBwUmVmID0gdGhpcy5hcHBsaWNhdGlvblJlZjtcbiAgICAgICAgdmFyIGNvbXBvbmVudFJvb3ROb2RlID0gdGhpcy5nZXRDb21wb25lbnRSb290Tm9kZShjb21wb25lbnRSZWYpO1xuICAgICAgICAvLyBwcm9qZWN0IHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIHRoaXMucHJvamVjdENvbXBvbmVudEJpbmRpbmdzKGNvbXBvbmVudFJlZiwgYmluZGluZ3MpO1xuICAgICAgICBhcHBSZWYuYXR0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgICBjb21wb25lbnRSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFwcFJlZi5kZXRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1c2UgdGhlIHJlbmRlcmVyIHRvIGFwcGVuZCB0aGUgZWxlbWVudCBmb3IgdW5pdnNlcmFsIHN1cHBvcnRcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gY29tcG9uZW50UmVmLmluc3RhbmNlLnJlbmRlcmVyO1xuICAgICAgICByZW5kZXJlci5hcHBlbmRDaGlsZChsb2NhdGlvbiwgY29tcG9uZW50Um9vdE5vZGUpO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICAgIH07XG4gICAgdmFyIEluamVjdGlvblNlcnZpY2VfMSwgX2EsIF9iLCBfYztcbiAgICBJbmplY3Rpb25TZXJ2aWNlLmdsb2JhbFJvb3RWaWV3Q29udGFpbmVyID0gbnVsbDtcbiAgICBJbmplY3Rpb25TZXJ2aWNlID0gSW5qZWN0aW9uU2VydmljZV8xID0gX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEFwcGxpY2F0aW9uUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEFwcGxpY2F0aW9uUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QsIHR5cGVvZiAoX2IgPSB0eXBlb2YgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyICE9PSBcInVuZGVmaW5lZFwiICYmIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0LCB0eXBlb2YgKF9jID0gdHlwZW9mIEluamVjdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIEluamVjdG9yKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3RdKVxuICAgIF0sIEluamVjdGlvblNlcnZpY2UpO1xuICAgIHJldHVybiBJbmplY3Rpb25TZXJ2aWNlO1xufSgpKTtcblxudmFyIEluamVjdGlvblJlZ2lzdGVyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3Rpb25SZWdpc3RlcnkoaW5qZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmluamVjdGlvblNlcnZpY2UgPSBpbmplY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0ge307XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5nZXRCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSB0aGlzLnR5cGU7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5nZXQodHlwZSk7XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChiaW5kaW5ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVCeVR5cGUodGhpcy50eXBlLCBiaW5kaW5ncyk7XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmNyZWF0ZUJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBiaW5kaW5ncykge1xuICAgICAgICBiaW5kaW5ncyA9IHRoaXMuYXNzaWduRGVmYXVsdHMoYmluZGluZ3MpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5pbmplY3RDb21wb25lbnQodHlwZSwgYmluZGluZ3MpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHR5cGUsIGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIGNvbXBzQnlUeXBlID0gdGhpcy5jb21wb25lbnRzLmdldChpbnN0YW5jZS5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgaWYgKGNvbXBzQnlUeXBlKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gY29tcHNCeVR5cGUuaW5kZXhPZihpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcHNCeVR5cGVbaWR4XTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGNvbXBzQnlUeXBlLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmRlc3Ryb3lBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUJ5VHlwZSh0aGlzLnR5cGUpO1xuICAgIH07XG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5kZXN0cm95QnlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGNvbXBzID0gdGhpcy5jb21wb25lbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGNvbXBzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbXBzXzEgPSBjb21wczsgX2kgPCBjb21wc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjb21wID0gY29tcHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KGNvbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmFzc2lnbkRlZmF1bHRzID0gZnVuY3Rpb24gKGJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZGVmYXVsdHMsIGlucHV0cyA9IF9hLmlucHV0cywgb3V0cHV0cyA9IF9hLm91dHB1dHM7XG4gICAgICAgIGlmICghYmluZGluZ3MuaW5wdXRzICYmICFiaW5kaW5ncy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBiaW5kaW5ncyA9IHsgaW5wdXRzOiBiaW5kaW5ncyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dHMpIHtcbiAgICAgICAgICAgIGJpbmRpbmdzLmlucHV0cyA9IE9iamVjdC5hc3NpZ24oaW5wdXRzLCBiaW5kaW5ncy5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRzKSB7XG4gICAgICAgICAgICBiaW5kaW5ncy5vdXRwdXRzID0gT2JqZWN0LmFzc2lnbihvdXRwdXRzLCBiaW5kaW5ncy5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3M7XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmluamVjdENvbXBvbmVudCA9IGZ1bmN0aW9uICh0eXBlLCBiaW5kaW5ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rpb25TZXJ2aWNlLmFwcGVuZENvbXBvbmVudCh0eXBlLCBiaW5kaW5ncyk7XG4gICAgfTtcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50cy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5zZXQodHlwZSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlcyA9IHRoaXMuY29tcG9uZW50cy5nZXQodHlwZSk7XG4gICAgICAgIHR5cGVzLnB1c2goY29tcG9uZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBJbmplY3Rpb25SZWdpc3Rlcnk7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlIGEgZnVuY3Rpb25cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0geyp9ICAgICAgZnVuY1xuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcbiAqIEBwYXJhbSB7Kn0gICAgICBbb3B0aW9uc11cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dDtcbiAgICB2YXIgYXJncztcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogK25ldyBEYXRlKCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuLyoqXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcbiAqXG4gKiAgY2xhc3MgTXlDbGFzcyB7XG4gKiAgICB0aHJvdHRsZWFibGUoMTApXG4gKiAgICBteUZuKCkgeyAuLi4gfVxuICogIH1cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZWFibGUoZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5uZXJEZWNvcmF0b3IodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aHJvdHRsZShkZXNjcmlwdG9yLnZhbHVlLCBkdXJhdGlvbiwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbnZhciBUb29sdGlwQ29udGVudENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwQ29udGVudENvbXBvbmVudChlbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3NzQ2xhc3Nlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNseiA9ICduZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudCc7XG4gICAgICAgICAgICBjbHogKz0gXCIgcG9zaXRpb24tXCIgKyB0aGlzLnBsYWNlbWVudDtcbiAgICAgICAgICAgIGNseiArPSBcIiB0eXBlLVwiICsgdGhpcy50eXBlO1xuICAgICAgICAgICAgY2x6ICs9IFwiIFwiICsgdGhpcy5jc3NDbGFzcztcbiAgICAgICAgICAgIHJldHVybiBjbHo7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5wb3NpdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5hdGl2ZUVsbSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgaG9zdERpbSA9IHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWhvc3REaW0uaGVpZ2h0ICYmICFob3N0RGltLndpZHRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZWxtRGltID0gbmF0aXZlRWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmNoZWNrRmxpcChob3N0RGltLCBlbG1EaW0pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ29udGVudChuYXRpdmVFbG0sIGhvc3REaW0sIGVsbURpbSk7XG4gICAgICAgIGlmICh0aGlzLnNob3dDYXJldCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkNhcmV0KGhvc3REaW0sIGVsbURpbSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhuYXRpdmVFbG0sICdhbmltYXRlJyk7IH0sIDEpO1xuICAgIH07XG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLnBvc2l0aW9uQ29udGVudCA9IGZ1bmN0aW9uIChuYXRpdmVFbG0sIGhvc3REaW0sIGVsbURpbSkge1xuICAgICAgICB2YXIgX2EgPSBQb3NpdGlvbkhlbHBlci5wb3NpdGlvbkNvbnRlbnQodGhpcy5wbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgdGhpcy5zcGFjaW5nLCB0aGlzLmFsaWdubWVudCksIHRvcCA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUobmF0aXZlRWxtLCAndG9wJywgdG9wICsgXCJweFwiKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShuYXRpdmVFbG0sICdsZWZ0JywgbGVmdCArIFwicHhcIik7XG4gICAgfTtcbiAgICBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUucG9zaXRpb25DYXJldCA9IGZ1bmN0aW9uIChob3N0RGltLCBlbG1EaW0pIHtcbiAgICAgICAgdmFyIGNhcmV0RWxtID0gdGhpcy5jYXJldEVsbS5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgY2FyZXREaW1lbnNpb25zID0gY2FyZXRFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBfYSA9IFBvc2l0aW9uSGVscGVyLnBvc2l0aW9uQ2FyZXQodGhpcy5wbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgY2FyZXREaW1lbnNpb25zLCB0aGlzLmFsaWdubWVudCksIHRvcCA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY2FyZXRFbG0sICd0b3AnLCB0b3AgKyBcInB4XCIpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGNhcmV0RWxtLCAnbGVmdCcsIGxlZnQgKyBcInB4XCIpO1xuICAgIH07XG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLmNoZWNrRmxpcCA9IGZ1bmN0aW9uIChob3N0RGltLCBlbG1EaW0pIHtcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSBQb3NpdGlvbkhlbHBlci5kZXRlcm1pbmVQbGFjZW1lbnQodGhpcy5wbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgdGhpcy5zcGFjaW5nKTtcbiAgICB9O1xuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0NhcmV0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFN0eWxlVHlwZXMgIT09IFwidW5kZWZpbmVkXCIgJiYgU3R5bGVUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIFBsYWNlbWVudFR5cGVzICE9PSBcInVuZGVmaW5lZFwiICYmIFBsYWNlbWVudFR5cGVzKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBBbGlnbm1lbnRUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBBbGlnbm1lbnRUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhbGlnbm1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NDbGFzc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIFZpZXdDaGlsZCgnY2FyZXRFbG0nLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImNhcmV0RWxtXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RCaW5kaW5nKCdjbGFzcycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NDbGFzc2VzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnKSxcbiAgICAgICAgdGhyb3R0bGVhYmxlKDEwMCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm9uV2luZG93UmVzaXplXCIsIG51bGwpO1xuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC10b29sdGlwLWNvbnRlbnQnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXY+XFxuICAgICAgPHNwYW4gI2NhcmV0RWxtIFtoaWRkZW5dPVxcXCIhc2hvd0NhcmV0XFxcIiBjbGFzcz1cXFwidG9vbHRpcC1jYXJldCBwb3NpdGlvbi17eyB0aGlzLnBsYWNlbWVudCB9fVxcXCI+IDwvc3Bhbj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiF0aXRsZVxcXCI+XFxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XFxcInRlbXBsYXRlXFxcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVxcXCJ7IG1vZGVsOiBjb250ZXh0IH1cXFwiPiA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcInRpdGxlXFxcIiBbaW5uZXJIVE1MXT1cXFwidGl0bGVcXFwiPiA8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCIsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnR7cG9zaXRpb246Zml4ZWQ7Ym9yZGVyLXJhZGl1czozcHg7ei1pbmRleDo1MDAwO2Rpc3BsYXk6YmxvY2s7Zm9udC13ZWlnaHQ6NDAwO29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lIWltcG9ydGFudH0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS1wb3BvdmVye2JhY2tncm91bmQ6I2ZmZjtjb2xvcjojMDYwNzA5O2JvcmRlcjoxcHggc29saWQgIzcyODA5Yjtib3gtc2hhZG93OjAgMXB4IDNweCAwIHJnYmEoMCwwLDAsLjIpLDAgMXB4IDFweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDJweCAxcHggLTFweCByZ2JhKDAsMCwwLC4xMik7Zm9udC1zaXplOjEzcHg7cGFkZGluZzo0cHh9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtcG9wb3ZlciAudG9vbHRpcC1jYXJldHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjUwMDE7d2lkdGg6MDtoZWlnaHQ6MH0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS1wb3BvdmVyIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLWxlZnR7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkICNmZmZ9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtcG9wb3ZlciAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi10b3B7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcDo3cHggc29saWQgI2ZmZn0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS1wb3BvdmVyIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLXJpZ2h0e2JvcmRlci10b3A6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo3cHggc29saWQgI2ZmZn0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS1wb3BvdmVyIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLWJvdHRvbXtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCAjZmZmfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXRvb2x0aXB7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjc1KTtmb250LXNpemU6MTJweDtwYWRkaW5nOjAgMTBweDt0ZXh0LWFsaWduOmNlbnRlcjtwb2ludGVyLWV2ZW50czphdXRvfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXRvb2x0aXAgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tbGVmdHtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDo3cHggc29saWQgcmdiYSgwLDAsMCwuNzUpfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXRvb2x0aXAgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tdG9we2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci10b3A6N3B4IHNvbGlkIHJnYmEoMCwwLDAsLjc1KX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS10b29sdGlwIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLXJpZ2h0e2JvcmRlci10b3A6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo3cHggc29saWQgcmdiYSgwLDAsMCwuNzUpfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXRvb2x0aXAgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tYm90dG9te2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHJnYmEoMCwwLDAsLjc1KX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQgLnRvb2x0aXAtbGFiZWx7ZGlzcGxheTpibG9jaztsaW5lLWhlaWdodDoxZW07cGFkZGluZzo4cHggNXB4IDVweCA1cHg7Zm9udC1zaXplOjFlbX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQgLnRvb2x0aXAtdmFse2Rpc3BsYXk6YmxvY2s7Zm9udC1zaXplOjEuM2VtO2xpbmUtaGVpZ2h0OjFlbTtwYWRkaW5nOjAgNXB4IDhweCA1cHh9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50IC50b29sdGlwLWNhcmV0e3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NTAwMTt3aWR0aDowO2hlaWdodDowfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC5wb3NpdGlvbi1yaWdodHt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTBweCwwLDApfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC5wb3NpdGlvbi1sZWZ0e3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTBweCwwLDApfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC5wb3NpdGlvbi10b3B7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsLTEwcHgsMCl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnBvc2l0aW9uLWJvdHRvbXt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwxMHB4LDApfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC5hbmltYXRle29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzLHRyYW5zZm9ybSAuM3M7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTtwb2ludGVyLWV2ZW50czphdXRvfS5hcmVhLXRvb2x0aXAtY29udGFpbmVye3BhZGRpbmc6NXB4IDA7cG9pbnRlci1ldmVudHM6bm9uZX0udG9vbHRpcC1pdGVte3RleHQtYWxpZ246bGVmdDtsaW5lLWhlaWdodDoxLjJlbTtwYWRkaW5nOjVweCAwfS50b29sdGlwLWl0ZW0gLnRvb2x0aXAtaXRlbS1jb2xvcntkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MTJweDt3aWR0aDoxMnB4O21hcmdpbi1yaWdodDo1cHg7Y29sb3I6IzViNjQ2Yjtib3JkZXItcmFkaXVzOjNweH1cIl1cbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfZCA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdCwgdHlwZW9mIChfZSA9IHR5cGVvZiBSZW5kZXJlcjIgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVuZGVyZXIyKSA9PT0gXCJmdW5jdGlvblwiID8gX2UgOiBPYmplY3RdKVxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50KTtcbiAgICByZXR1cm4gVG9vbHRpcENvbnRlbnRDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgVG9vbHRpcFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvb2x0aXBTZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2x0aXBTZXJ2aWNlKGluamVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0aW9uU2VydmljZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5qZWN0aW9uU2VydmljZSA9IGluamVjdGlvblNlcnZpY2U7XG4gICAgICAgIF90aGlzLnR5cGUgPSBUb29sdGlwQ29udGVudENvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX2E7XG4gICAgVG9vbHRpcFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgSW5qZWN0aW9uU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBJbmplY3Rpb25TZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIFRvb2x0aXBTZXJ2aWNlKTtcbiAgICByZXR1cm4gVG9vbHRpcFNlcnZpY2U7XG59KEluamVjdGlvblJlZ2lzdGVyeSkpO1xuXG52YXIgVG9vbHRpcERpcmVjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwRGlyZWN0aXZlKHRvb2x0aXBTZXJ2aWNlLCB2aWV3Q29udGFpbmVyUmVmLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLnRvb2x0aXBTZXJ2aWNlID0gdG9vbHRpcFNlcnZpY2U7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy50b29sdGlwQ3NzQ2xhc3MgPSAnJztcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUgPSAnJztcbiAgICAgICAgdGhpcy50b29sdGlwQXBwZW5kVG9Cb2R5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b29sdGlwU3BhY2luZyA9IDEwO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvb2x0aXBTaG93Q2FyZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRvb2x0aXBQbGFjZW1lbnQgPSBQbGFjZW1lbnRUeXBlcy50b3A7XG4gICAgICAgIHRoaXMudG9vbHRpcEFsaWdubWVudCA9IEFsaWdubWVudFR5cGVzLmNlbnRlcjtcbiAgICAgICAgdGhpcy50b29sdGlwVHlwZSA9IFN0eWxlVHlwZXMucG9wb3ZlcjtcbiAgICAgICAgdGhpcy50b29sdGlwQ2xvc2VPbkNsaWNrT3V0c2lkZSA9IHRydWU7XG4gICAgICAgIHRoaXMudG9vbHRpcENsb3NlT25Nb3VzZUxlYXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50b29sdGlwSGlkZVRpbWVvdXQgPSAzMDA7XG4gICAgICAgIHRoaXMudG9vbHRpcFNob3dUaW1lb3V0ID0gMTAwO1xuICAgICAgICB0aGlzLnRvb2x0aXBTaG93RXZlbnQgPSBTaG93VHlwZXMuYWxsO1xuICAgICAgICB0aGlzLnRvb2x0aXBJbW1lZGlhdGVFeGl0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5oaWRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGlzdGVuc0ZvckZvY3VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwU2hvd0V2ZW50ID09PSBTaG93VHlwZXMuYWxsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwU2hvd0V2ZW50ID09PSBTaG93VHlwZXMuZm9jdXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsaXN0ZW5zRm9ySG92ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBTaG93RXZlbnQgPT09IFNob3dUeXBlcy5hbGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXBTaG93RXZlbnQgPT09IFNob3dUeXBlcy5tb3VzZW92ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhpZGVUb29sdGlwKHRydWUpO1xuICAgIH07XG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc0ZvckZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc0ZvckZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVUb29sdGlwKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnNGb3JIb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnNGb3JIb3ZlciAmJiB0aGlzLnRvb2x0aXBDbG9zZU9uTW91c2VMZWF2ZSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudERvbSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbnMgPSBjb250ZW50RG9tLmNvbnRhaW5zKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhpZGVUb29sdGlwKHRoaXMudG9vbHRpcEltbWVkaWF0ZUV4aXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbk1vdXNlQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnNGb3JIb3Zlcikge1xuICAgICAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCB8fCB0aGlzLnRvb2x0aXBEaXNhYmxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHRpbWUgPSBpbW1lZGlhdGUgPyAwIDogdGhpcy50b29sdGlwU2hvd1RpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnRvb2x0aXBTZXJ2aWNlLmRlc3Ryb3lBbGwoKTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMuY3JlYXRlQm91bmRPcHRpb25zKCk7XG4gICAgICAgICAgICBfdGhpcy5jb21wb25lbnQgPSBfdGhpcy50b29sdGlwU2VydmljZS5jcmVhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBhZGQgYSB0aW55IHRpbWVvdXQgdG8gYXZvaWQgZXZlbnQgcmUtdHJpZ2dlcnNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkSGlkZUxpc3RlbmVycyhfdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICBfdGhpcy5zaG93LmVtaXQodHJ1ZSk7XG4gICAgICAgIH0sIHRpbWUpO1xuICAgIH07XG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkSGlkZUxpc3RlbmVycyA9IGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIG9uIG1vdXNlIGVudGVyLCBjYW5jZWwgdGhlIGhpZGUgdHJpZ2dlcmVkIGJ5IHRoZSBsZWF2ZVxuICAgICAgICB0aGlzLm1vdXNlRW50ZXJDb250ZW50RXZlbnQgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0b29sdGlwLCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbnRlbnQgbW91c2UgbGVhdmUgbGlzdGVuZXJcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcENsb3NlT25Nb3VzZUxlYXZlKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlTGVhdmVDb250ZW50RXZlbnQgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0b29sdGlwLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcChfdGhpcy50b29sdGlwSW1tZWRpYXRlRXhpdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb250ZW50IGNsb3NlIG9uIGNsaWNrIG91dHNpZGVcbiAgICAgICAgaWYgKHRoaXMudG9vbHRpcENsb3NlT25DbGlja091dHNpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0V2ZW50ID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCQkMSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWlucyA9IHRvb2x0aXAuY29udGFpbnMoZXZlbnQkJDEudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLmhpZGVUb29sdGlwID0gZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGRlc3Ryb3lGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudHNcbiAgICAgICAgICAgIGlmIChfdGhpcy5tb3VzZUxlYXZlQ29udGVudEV2ZW50KVxuICAgICAgICAgICAgICAgIF90aGlzLm1vdXNlTGVhdmVDb250ZW50RXZlbnQoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5tb3VzZUVudGVyQ29udGVudEV2ZW50KVxuICAgICAgICAgICAgICAgIF90aGlzLm1vdXNlRW50ZXJDb250ZW50RXZlbnQoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kb2N1bWVudENsaWNrRXZlbnQpXG4gICAgICAgICAgICAgICAgX3RoaXMuZG9jdW1lbnRDbGlja0V2ZW50KCk7XG4gICAgICAgICAgICAvLyBlbWl0IGV2ZW50c1xuICAgICAgICAgICAgX3RoaXMuaGlkZS5lbWl0KHRydWUpO1xuICAgICAgICAgICAgLy8gZGVzdHJveSBjb21wb25lbnRcbiAgICAgICAgICAgIF90aGlzLnRvb2x0aXBTZXJ2aWNlLmRlc3Ryb3koX3RoaXMuY29tcG9uZW50KTtcbiAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlc3Ryb3lGbiwgdGhpcy50b29sdGlwSGlkZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdHJveUZuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLmNyZWF0ZUJvdW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnRvb2x0aXBUaXRsZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLnRvb2x0aXBUZW1wbGF0ZSxcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMudmlld0NvbnRhaW5lclJlZi5lbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50OiB0aGlzLnRvb2x0aXBQbGFjZW1lbnQsXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IHRoaXMudG9vbHRpcEFsaWdubWVudCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudG9vbHRpcFR5cGUsXG4gICAgICAgICAgICBzaG93Q2FyZXQ6IHRoaXMudG9vbHRpcFNob3dDYXJldCxcbiAgICAgICAgICAgIGNzc0NsYXNzOiB0aGlzLnRvb2x0aXBDc3NDbGFzcyxcbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMudG9vbHRpcFNwYWNpbmcsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLnRvb2x0aXBDb250ZXh0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcENzc0NsYXNzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBBcHBlbmRUb0JvZHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwU3BhY2luZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFNob3dDYXJldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBQbGFjZW1lbnRUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBQbGFjZW1lbnRUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBQbGFjZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgQWxpZ25tZW50VHlwZXMgIT09IFwidW5kZWZpbmVkXCIgJiYgQWxpZ25tZW50VHlwZXMpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwQWxpZ25tZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFN0eWxlVHlwZXMgIT09IFwidW5kZWZpbmVkXCIgJiYgU3R5bGVUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBUeXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBDbG9zZU9uQ2xpY2tPdXRzaWRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBDbG9zZU9uTW91c2VMZWF2ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBIaWRlVGltZW91dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBTaG93VGltZW91dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBTaG93VHlwZXMgIT09IFwidW5kZWZpbmVkXCIgJiYgU2hvd1R5cGVzKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QpXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFNob3dFdmVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBDb250ZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBJbW1lZGlhdGVFeGl0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGlkZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ2ZvY3VzaW4nKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ2JsdXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uTW91c2VFbnRlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJywgWyckZXZlbnQudGFyZ2V0J10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uTW91c2VMZWF2ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdjbGljaycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uTW91c2VDbGlja1wiLCBudWxsKTtcbiAgICBUb29sdGlwRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25neC10b29sdGlwXScgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfZSA9IHR5cGVvZiBUb29sdGlwU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUb29sdGlwU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9lIDogT2JqZWN0LCB0eXBlb2YgKF9mID0gdHlwZW9mIFZpZXdDb250YWluZXJSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVmlld0NvbnRhaW5lclJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9mIDogT2JqZWN0LCB0eXBlb2YgKF9nID0gdHlwZW9mIFJlbmRlcmVyMiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZW5kZXJlcjIpID09PSBcImZ1bmN0aW9uXCIgPyBfZyA6IE9iamVjdF0pXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIFRvb2x0aXBEaXJlY3RpdmU7XG59KCkpO1xuXG52YXIgVG9vbHRpcE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwTW9kdWxlKCkge1xuICAgIH1cbiAgICBUb29sdGlwTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1Rvb2x0aXBDb250ZW50Q29tcG9uZW50LCBUb29sdGlwRGlyZWN0aXZlXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW0luamVjdGlvblNlcnZpY2UsIFRvb2x0aXBTZXJ2aWNlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtUb29sdGlwQ29udGVudENvbXBvbmVudCwgVG9vbHRpcERpcmVjdGl2ZV0sXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1Rvb2x0aXBDb250ZW50Q29tcG9uZW50XVxuICAgICAgICB9KVxuICAgIF0sIFRvb2x0aXBNb2R1bGUpO1xuICAgIHJldHVybiBUb29sdGlwTW9kdWxlO1xufSgpKTtcblxudmFyIENoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJ0Q29tcG9uZW50KHZjciwgdG9vbHRpcFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy52Y3IgPSB2Y3I7XG4gICAgICAgIHRoaXMudG9vbHRpcFNlcnZpY2UgPSB0b29sdGlwU2VydmljZTtcbiAgICAgICAgdGhpcy5zaG93TGVnZW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMubGVnZW5kTGFiZWxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMYWJlbEFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmxlZ2VuZExhYmVsRGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy50b29sdGlwU2VydmljZS5pbmplY3Rpb25TZXJ2aWNlLnNldFJvb3RWaWV3Q29udGFpbmVyKHRoaXMudmNyKTtcbiAgICB9XG4gICAgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWdlbmRDb2x1bW5zID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRUeXBlID0gdGhpcy5nZXRMZWdlbmRUeXBlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGVnZW5kT3B0aW9ucyB8fCB0aGlzLmxlZ2VuZE9wdGlvbnMucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWdlbmRUeXBlID09PSAnc2NhbGVMZWdlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZENvbHVtbnMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1ucyA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFydENvbHVtbnMgPSAxMiAtIGxlZ2VuZENvbHVtbnM7XG4gICAgICAgIHRoaXMuY2hhcnRXaWR0aCA9IE1hdGguZmxvb3IoKHRoaXMudmlld1swXSAqIGNoYXJ0Q29sdW1ucyAvIDEyLjApKTtcbiAgICAgICAgdGhpcy5sZWdlbmRXaWR0aCA9ICghdGhpcy5sZWdlbmRPcHRpb25zIHx8IHRoaXMubGVnZW5kT3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JylcbiAgICAgICAgICAgID8gTWF0aC5mbG9vcigodGhpcy52aWV3WzBdICogbGVnZW5kQ29sdW1ucyAvIDEyLjApKVxuICAgICAgICAgICAgOiB0aGlzLmNoYXJ0V2lkdGg7XG4gICAgfTtcbiAgICBDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVnZW5kT3B0aW9ucy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NjYWxlTGVnZW5kJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVnZW5kJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93TGVnZW5kXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZE9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmREYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRMYWJlbENsaWNrXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZExhYmVsQWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kTGFiZWxEZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1Rvb2x0aXBTZXJ2aWNlXSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1jaGFydCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdlxcbiAgICAgIGNsYXNzPVxcXCJuZ3gtY2hhcnRzLW91dGVyXFxcIlxcbiAgICAgIFtzdHlsZS53aWR0aC5weF09XFxcInZpZXdbMF1cXFwiXFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgIFtALmRpc2FibGVkXT1cXFwiIWFuaW1hdGlvbnNcXFwiPlxcbiAgICAgIDxzdmdcXG4gICAgICAgIGNsYXNzPVxcXCJuZ3gtY2hhcnRzXFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJjaGFydFdpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwidmlld1sxXVxcXCI+XFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgPC9zdmc+XFxuICAgICAgPG5neC1jaGFydHMtc2NhbGUtbGVnZW5kXFxuICAgICAgICAqbmdJZj1cXFwic2hvd0xlZ2VuZCAmJiBsZWdlbmRUeXBlID09PSAnc2NhbGVMZWdlbmQnXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNoYXJ0LWxlZ2VuZFxcXCJcXG4gICAgICAgIFtob3Jpem9udGFsXT1cXFwibGVnZW5kT3B0aW9ucyAmJiBsZWdlbmRPcHRpb25zLnBvc2l0aW9uID09PSAnYmVsb3cnXFxcIlxcbiAgICAgICAgW3ZhbHVlUmFuZ2VdPVxcXCJsZWdlbmRPcHRpb25zLmRvbWFpblxcXCJcXG4gICAgICAgIFtjb2xvcnNdPVxcXCJsZWdlbmRPcHRpb25zLmNvbG9yc1xcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJ2aWV3WzFdXFxcIlxcbiAgICAgICAgW3dpZHRoXT1cXFwibGVnZW5kV2lkdGhcXFwiPlxcbiAgICAgIDwvbmd4LWNoYXJ0cy1zY2FsZS1sZWdlbmQ+XFxuICAgICAgPG5neC1jaGFydHMtbGVnZW5kXFxuICAgICAgICAqbmdJZj1cXFwic2hvd0xlZ2VuZCAmJiBsZWdlbmRUeXBlID09PSAnbGVnZW5kJ1xcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJjaGFydC1sZWdlbmRcXFwiXFxuICAgICAgICBbaG9yaXpvbnRhbF09XFxcImxlZ2VuZE9wdGlvbnMgJiYgbGVnZW5kT3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JlbG93J1xcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwibGVnZW5kT3B0aW9ucy5kb21haW5cXFwiXFxuICAgICAgICBbdGl0bGVdPVxcXCJsZWdlbmRPcHRpb25zLnRpdGxlXFxcIlxcbiAgICAgICAgW2NvbG9yc109XFxcImxlZ2VuZE9wdGlvbnMuY29sb3JzXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInZpZXdbMV1cXFwiXFxuICAgICAgICBbd2lkdGhdPVxcXCJsZWdlbmRXaWR0aFxcXCJcXG4gICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgIChsYWJlbENsaWNrKT1cXFwibGVnZW5kTGFiZWxDbGljay5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAobGFiZWxBY3RpdmF0ZSk9XFxcImxlZ2VuZExhYmVsQWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgKGxhYmVsRGVhY3RpdmF0ZSk9XFxcImxlZ2VuZExhYmVsRGVhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiPlxcbiAgICAgIDwvbmd4LWNoYXJ0cy1sZWdlbmQ+XFxuICAgIDwvZGl2PlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnNTAwbXMgMTAwbXMnLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfZCA9IHR5cGVvZiBWaWV3Q29udGFpbmVyUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFZpZXdDb250YWluZXJSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdCwgdHlwZW9mIChfZSA9IHR5cGVvZiBUb29sdGlwU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUb29sdGlwU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9lIDogT2JqZWN0XSlcbiAgICBdLCBDaGFydENvbXBvbmVudCk7XG4gICAgcmV0dXJuIENoYXJ0Q29tcG9uZW50O1xufSgpKTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbGFiZWwgZ2l2ZW4gYSBkYXRlLCBudW1iZXIgb3Igc3RyaW5nLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7Kn0gbGFiZWxcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdExhYmVsKGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFiZWwgPSBsYWJlbC50b0xvY2FsZVN0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG59XG4vKipcbiAqIEVzY2FwZXMgYSBsYWJlbC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0geyp9IGxhYmVsXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVMYWJlbChsYWJlbCkge1xuICAgIHJldHVybiBsYWJlbC50b0xvY2FsZVN0cmluZygpLnJlcGxhY2UoL1smJ2BcIjw+XS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICAgICAgICdcXCcnOiAnJiN4Mjc7JyxcbiAgICAgICAgICAgICdgJzogJyYjeDYwOycsXG4gICAgICAgICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAgIH1bbWF0Y2hdO1xuICAgIH0pO1xufVxuXG52YXIgTGVnZW5kQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExlZ2VuZENvbXBvbmVudChjZCkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhYmVsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWxBY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbERlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubGVnZW5kRW50cmllcyA9IFtdO1xuICAgIH1cbiAgICBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmxlZ2VuZEVudHJpZXMgPSB0aGlzLmdldExlZ2VuZEVudHJpZXMoKTtcbiAgICB9O1xuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gaXRlbXMuZmluZEluZGV4KGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGZvcm1hdHRlZExhYmVsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZExhYmVsOiBmb3JtYXR0ZWRMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXNfMS5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kYXRhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gX2FbX2ldO1xuICAgICAgICAgICAgX2xvb3BfMShsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH07XG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmxhYmVsID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMubGFiZWxBY3RpdmF0ZS5lbWl0KGl0ZW0pO1xuICAgIH07XG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5sYWJlbERlYWN0aXZhdGUuZW1pdChpdGVtKTtcbiAgICB9O1xuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhvcml6b250YWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsQ2xpY2tcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsQWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIExlZ2VuZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWxlZ2VuZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBbc3R5bGUud2lkdGgucHhdPVxcXCJ3aWR0aFxcXCI+XFxuICAgICAgPGhlYWRlciBjbGFzcz1cXFwibGVnZW5kLXRpdGxlXFxcIiAqbmdJZj1cXFwidGl0bGU/Lmxlbmd0aCA+IDBcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxlZ2VuZC10aXRsZS10ZXh0XFxcIj57e3RpdGxlfX08L3NwYW4+XFxuICAgICAgPC9oZWFkZXI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGVnZW5kLXdyYXBcXFwiPlxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJsZWdlbmQtbGFiZWxzXFxcIlxcbiAgICAgICAgICAgIFtjbGFzcy5ob3Jpem9udGFsLWxlZ2VuZF09XFxcImhvcml6b250YWxcXFwiXFxuICAgICAgICAgIFtzdHlsZS5tYXgtaGVpZ2h0LnB4XT1cXFwiaGVpZ2h0IC0gNDVcXFwiPlxcbiAgICAgICAgICA8bGlcXG4gICAgICAgICAgICAqbmdGb3I9XFxcImxldCBlbnRyeSBvZiBsZWdlbmRFbnRyaWVzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJsZWdlbmQtbGFiZWxcXFwiPlxcbiAgICAgICAgICAgIDxuZ3gtY2hhcnRzLWxlZ2VuZC1lbnRyeVxcbiAgICAgICAgICAgICAgW2xhYmVsXT1cXFwiZW50cnkubGFiZWxcXFwiXFxuICAgICAgICAgICAgICBbZm9ybWF0dGVkTGFiZWxdPVxcXCJlbnRyeS5mb3JtYXR0ZWRMYWJlbFxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcl09XFxcImVudHJ5LmNvbG9yXFxcIlxcbiAgICAgICAgICAgICAgW2lzQWN0aXZlXT1cXFwiaXNBY3RpdmUoZW50cnkpXFxcIlxcbiAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcImxhYmVsQ2xpY2suZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZSgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICA8L25neC1jaGFydHMtbGVnZW5kLWVudHJ5PlxcbiAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLmNoYXJ0LWxlZ2VuZHtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjA7d2lkdGg6YXV0byFpbXBvcnRhbnR9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLXRpdGxle3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47bWFyZ2luLWxlZnQ6MTBweDttYXJnaW4tYm90dG9tOjVweDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo3MDB9LmNoYXJ0LWxlZ2VuZCBsaSwuY2hhcnQtbGVnZW5kIHVse3BhZGRpbmc6MDttYXJnaW46MDtsaXN0LXN0eWxlOm5vbmV9LmNoYXJ0LWxlZ2VuZCAuaG9yaXpvbnRhbC1sZWdlbmQgbGl7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLXdyYXB7d2lkdGg6Y2FsYygxMDAlIC0gMTBweCl9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLWxhYmVsc3tsaW5lLWhlaWdodDo4NSU7bGlzdC1zdHlsZTpub25lO3RleHQtYWxpZ246bGVmdDtmbG9hdDpsZWZ0O3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czozcHg7b3ZlcmZsb3cteTphdXRvO292ZXJmbG93LXg6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjA1KX0uY2hhcnQtbGVnZW5kIC5sZWdlbmQtbGFiZWx7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjkwJTttYXJnaW46OHB4O2NvbG9yOiNhZmI3Yzh9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLWxhYmVsOmhvdmVye2NvbG9yOiMwMDA7LXdlYmtpdC10cmFuc2l0aW9uOi4yczstbW96LXRyYW5zaXRpb246LjJzO3RyYW5zaXRpb246LjJzfS5jaGFydC1sZWdlbmQgLmxlZ2VuZC1sYWJlbCAuYWN0aXZlIC5sZWdlbmQtbGFiZWwtdGV4dHtjb2xvcjojMDAwfS5jaGFydC1sZWdlbmQgLmxlZ2VuZC1sYWJlbC1jb2xvcntkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MTVweDt3aWR0aDoxNXB4O21hcmdpbi1yaWdodDo1cHg7Y29sb3I6IzViNjQ2Yjtib3JkZXItcmFkaXVzOjNweH0uY2hhcnQtbGVnZW5kIC5sZWdlbmQtbGFiZWwtdGV4dHtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7bGluZS1oZWlnaHQ6MTVweDtmb250LXNpemU6MTJweDt3aWR0aDpjYWxjKDEwMCUgLSAyMHB4KTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW59LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLXRpdGxlLXRleHR7dmVydGljYWwtYWxpZ246Ym90dG9tO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjE2cHg7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9kID0gdHlwZW9mIENoYW5nZURldGVjdG9yUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIENoYW5nZURldGVjdG9yUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3RdKVxuICAgIF0sIExlZ2VuZENvbXBvbmVudCk7XG4gICAgcmV0dXJuIExlZ2VuZENvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBTY2FsZUxlZ2VuZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2FsZUxlZ2VuZENvbXBvbmVudChzYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgIH1cbiAgICBTY2FsZUxlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgZ3JhZGllbnRWYWx1ZXMgPSB0aGlzLmdyYWRpZW50U3RyaW5nKHRoaXMuY29sb3JzLnJhbmdlKCksIHRoaXMuY29sb3JzLmRvbWFpbigpKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9ICh0aGlzLmhvcml6b250YWwpID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICAgICAgICB0aGlzLmdyYWRpZW50ID0gdGhpcy5zYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdFN0eWxlKFwibGluZWFyLWdyYWRpZW50KHRvIFwiICsgZGlyZWN0aW9uICsgXCIsIFwiICsgZ3JhZGllbnRWYWx1ZXMgKyBcIilcIik7XG4gICAgfTtcbiAgICBTY2FsZUxlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuZ3JhZGllbnRTdHJpbmcgPSBmdW5jdGlvbiAoY29sb3JzLCBzcGxpdHMpIHtcbiAgICAgICAgc3BsaXRzLnB1c2goMSk7XG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgICBjb2xvcnMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goYyArIFwiIFwiICsgTWF0aC5yb3VuZChzcGxpdHNbaV0gKiAxMDApICsgXCIlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhaXJzLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlUmFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTY2FsZUxlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3Jpem9udGFsXCIsIHZvaWQgMCk7XG4gICAgU2NhbGVMZWdlbmRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1zY2FsZS1sZWdlbmQnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXZcXG4gICAgICBjbGFzcz1cXFwic2NhbGUtbGVnZW5kXFxcIlxcbiAgICAgIFtjbGFzcy5ob3Jpem9udGFsLWxlZ2VuZF09XFxcImhvcml6b250YWxcXFwiXFxuICAgICAgW3N0eWxlLmhlaWdodC5weF09XFxcImhvcml6b250YWwgPyB1bmRlZmluZWQgOiBoZWlnaHRcXFwiXFxuICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGhcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWxlZ2VuZC1sYWJlbFxcXCI+XFxuICAgICAgICA8c3Bhbj57eyB2YWx1ZVJhbmdlWzFdLnRvTG9jYWxlU3RyaW5nKCkgfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInNjYWxlLWxlZ2VuZC13cmFwXFxcIlxcbiAgICAgICAgW3N0eWxlLmJhY2tncm91bmRdPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic2NhbGUtbGVnZW5kLWxhYmVsXFxcIj5cXG4gICAgICAgIDxzcGFuPnt7IHZhbHVlUmFuZ2VbMF0udG9Mb2NhbGVTdHJpbmcoKSB9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLmNoYXJ0LWxlZ2VuZHtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjA7d2lkdGg6YXV0byFpbXBvcnRhbnR9LmNoYXJ0LWxlZ2VuZCAuc2NhbGUtbGVnZW5ke3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmNoYXJ0LWxlZ2VuZCAuc2NhbGUtbGVnZW5kLXdyYXB7ZGlzcGxheTppbmxpbmUtYmxvY2s7ZmxleDoxO3dpZHRoOjMwcHg7Ym9yZGVyLXJhZGl1czo1cHg7bWFyZ2luOjAgYXV0b30uY2hhcnQtbGVnZW5kIC5zY2FsZS1sZWdlbmQtbGFiZWx7Zm9udC1zaXplOjEycHh9LmNoYXJ0LWxlZ2VuZCAuaG9yaXpvbnRhbC1sZWdlbmQuc2NhbGUtbGVnZW5ke2ZsZXgtZGlyZWN0aW9uOnJvd30uY2hhcnQtbGVnZW5kIC5ob3Jpem9udGFsLWxlZ2VuZCAuc2NhbGUtbGVnZW5kLXdyYXB7d2lkdGg6YXV0bztoZWlnaHQ6MzBweDttYXJnaW46MCAxNnB4fVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIERvbVNhbml0aXplciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBEb21TYW5pdGl6ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQpO1xuICAgIHJldHVybiBTY2FsZUxlZ2VuZENvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBMZWdlbmRFbnRyeUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZWdlbmRFbnRyeUNvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnRvZ2dsZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltbWVkTGFiZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZExhYmVsIHx8ICcoZW1wdHkpJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5sYWJlbCB9KTtcbiAgICB9O1xuICAgIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5sYWJlbCB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0dGVkTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QpXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcInRvZ2dsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xuICAgIExlZ2VuZEVudHJ5Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtbGVnZW5kLWVudHJ5JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3BhbiBcXG4gICAgICBbdGl0bGVdPVxcXCJmb3JtYXR0ZWRMYWJlbFxcXCJcXG4gICAgICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlXFxcIlxcbiAgICAgIChjbGljayk9XFxcInNlbGVjdC5lbWl0KGZvcm1hdHRlZExhYmVsKVxcXCI+XFxuICAgICAgPHNwYW5cXG4gICAgICAgIGNsYXNzPVxcXCJsZWdlbmQtbGFiZWwtY29sb3JcXFwiXFxuICAgICAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XFxcImNvbG9yXFxcIlxcbiAgICAgICAgKGNsaWNrKT1cXFwidG9nZ2xlLmVtaXQoZm9ybWF0dGVkTGFiZWwpXFxcIj5cXG4gICAgICA8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImxlZ2VuZC1sYWJlbC10ZXh0XFxcIj5cXG4gICAgICAgIHt7dHJpbW1lZExhYmVsfX1cXG4gICAgICA8L3NwYW4+XFxuICAgIDwvc3Bhbj5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIExlZ2VuZEVudHJ5Q29tcG9uZW50O1xufSgpKTtcblxuZnVuY3Rpb24gdHJpbUxhYmVsKHMsIG1heCQkMSkge1xuICAgIGlmIChtYXgkJDEgPT09IHZvaWQgMCkgeyBtYXgkJDEgPSAxNjsgfVxuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHMgKyAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzID0gcy50cmltKCk7XG4gICAgaWYgKHMubGVuZ3RoIDw9IG1heCQkMSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzLnNsaWNlKDAsIG1heCQkMSkgKyBcIi4uLlwiO1xuICAgIH1cbn1cblxudmFyIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLmxhYmVsID0gJ1RvdGFsJztcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0dGluZyA9IGZ1bmN0aW9uIChsYWJlbCkgeyByZXR1cm4gbGFiZWw7IH07XG4gICAgICAgIHRoaXMucGVyY2VudGFnZUZvcm1hdHRpbmcgPSBmdW5jdGlvbiAocGVyY2VudGFnZSkgeyByZXR1cm4gcGVyY2VudGFnZTsgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWVGb3JtYXR0aW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS50b0xvY2FsZVN0cmluZygpOyB9O1xuICAgIH1cbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLmdldFRvdGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIHN1bSArIGQ7IH0sIDApO1xuICAgIH07XG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRoaXMuZ2V0VG90YWwoKTtcbiAgICAgICAgdGhpcy5yb3VuZGVkVG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdGhpcy5nZXRMZWdlbmRJdGVtcygpO1xuICAgIH07XG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZm9ybWF0TGFiZWwoZC5uYW1lKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGQudmFsdWU7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBfdGhpcy50b3RhbCA+IDAgPyAodmFsdWUgLyBfdGhpcy50b3RhbCkgKiAxMDAgOiAwO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZExhYmVsID0gdHlwZW9mIF90aGlzLmxhYmVsRm9ybWF0dGluZyA9PT0gJ2Z1bmN0aW9uJyA/IF90aGlzLmxhYmVsRm9ybWF0dGluZyhsYWJlbCkgOiBsYWJlbDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlZExhYmVsLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlMYWJlbDogdHJpbUxhYmVsKGZvcm1hdHRlZExhYmVsLCAyMCksXG4gICAgICAgICAgICAgICAgb3JpZ2lhbExhYmVsOiBkLm5hbWUsXG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZTogX3RoaXMucGVyY2VudGFnZUZvcm1hdHRpbmcgPyBfdGhpcy5wZXJjZW50YWdlRm9ybWF0dGluZyhwZXJjZW50YWdlKSA6IHBlcmNlbnRhZ2UudG9Mb2NhbGVTdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmZvcm1hdHRlZExhYmVsO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwicGVyY2VudGFnZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWFkdmFuY2VkLWxlZ2VuZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYWR2YW5jZWQtcGllLWxlZ2VuZFxcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGhcXFwiPlxcbiAgICAgIDxkaXZcXG4gICAgICAgICpuZ0lmPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRvdGFsLXZhbHVlXFxcIlxcbiAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgW2NvdW50VG9dPVxcXCJyb3VuZGVkVG90YWxcXFwiXFxuICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgID48L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0b3RhbC12YWx1ZVxcXCIgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIj5cXG4gICAgICAgIHt7IHZhbHVlRm9ybWF0dGluZyA/IHZhbHVlRm9ybWF0dGluZyhyb3VuZGVkVG90YWwpIDogZGVmYXVsdFZhbHVlRm9ybWF0dGluZyhyb3VuZGVkVG90YWwpIH19XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidG90YWwtbGFiZWxcXFwiPlxcbiAgICAgICAge3sgbGFiZWwgfX1cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsZWdlbmQtaXRlbXMtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxlZ2VuZC1pdGVtc1xcXCI+XFxuICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAqbmdGb3I9XFxcImxldCBsZWdlbmRJdGVtIG9mIGxlZ2VuZEl0ZW1zOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwibGVnZW5kLWl0ZW1cXFwiXFxuICAgICAgICAgICAgKG1vdXNlZW50ZXIpPVxcXCJhY3RpdmF0ZS5lbWl0KGxlZ2VuZEl0ZW0uZGF0YSlcXFwiXFxuICAgICAgICAgICAgKG1vdXNlbGVhdmUpPVxcXCJkZWFjdGl2YXRlLmVtaXQobGVnZW5kSXRlbS5kYXRhKVxcXCJcXG4gICAgICAgICAgICAoY2xpY2spPVxcXCJzZWxlY3QuZW1pdChsZWdlbmRJdGVtLmRhdGEpXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbS1jb2xvclxcXCIgW3N0eWxlLmJvcmRlci1sZWZ0LWNvbG9yXT1cXFwibGVnZW5kSXRlbS5jb2xvclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiaXRlbS12YWx1ZVxcXCJcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtY291bnQtdXBcXG4gICAgICAgICAgICAgIFtjb3VudFRvXT1cXFwibGVnZW5kSXRlbS5fdmFsdWVcXFwiXFxuICAgICAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgID48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhYW5pbWF0aW9uc1xcXCIgY2xhc3M9XFxcIml0ZW0tdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAge3sgdmFsdWVGb3JtYXR0aW5nID8gdmFsdWVGb3JtYXR0aW5nKGxlZ2VuZEl0ZW0udmFsdWUpIDogZGVmYXVsdFZhbHVlRm9ybWF0dGluZyhsZWdlbmRJdGVtLnZhbHVlKSB9fVxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0tbGFiZWxcXFwiPnt7IGxlZ2VuZEl0ZW0uZGlzcGxheUxhYmVsIH19PC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiaXRlbS1wZXJjZW50XFxcIlxcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJsZWdlbmRJdGVtLnBlcmNlbnRhZ2VcXFwiXFxuICAgICAgICAgICAgICBbY291bnRTdWZmaXhdPVxcXCInJSdcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIiBjbGFzcz1cXFwiaXRlbS1wZXJjZW50XFxcIj57eyBsZWdlbmRJdGVtLnBlcmNlbnRhZ2UudG9Mb2NhbGVTdHJpbmcoKSB9fSU8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLmFkdmFuY2VkLXBpZS1sZWdlbmR7ZmxvYXQ6bGVmdDtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoMCwtNTAlKX0uYWR2YW5jZWQtcGllLWxlZ2VuZCAudG90YWwtdmFsdWV7Zm9udC1zaXplOjM2cHh9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLnRvdGFsLWxhYmVse2ZvbnQtc2l6ZToyNHB4O21hcmdpbi1ib3R0b206MTlweH0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lcnt3aWR0aDoxMDAlfS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXN7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93OmF1dG99LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW17bWFyZ2luLXJpZ2h0OjIwcHg7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y3Vyc29yOnBvaW50ZXJ9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW06Zm9jdXN7b3V0bGluZTowfS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVtOmhvdmVye2NvbG9yOiMwMDA7LXdlYmtpdC10cmFuc2l0aW9uOi4yczstbW96LXRyYW5zaXRpb246LjJzO3RyYW5zaXRpb246LjJzfS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVtIC5pdGVtLXZhbHVle2ZvbnQtc2l6ZToyNHB4O21hcmdpbi10b3A6LTZweDttYXJnaW4tbGVmdDoxMXB4fS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVtIC5pdGVtLWxhYmVse2ZvbnQtc2l6ZToxNHB4O29wYWNpdHk6Ljc7bWFyZ2luLWxlZnQ6MTFweDttYXJnaW4tdG9wOi02cHh9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW0gLml0ZW0tcGVyY2VudHtmb250LXNpemU6MjRweDtvcGFjaXR5Oi43O21hcmdpbi1sZWZ0OjExcHh9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW0gLml0ZW0tY29sb3J7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkO3dpZHRoOjRweDtoZWlnaHQ6NDJweDtmbG9hdDpsZWZ0O21hcmdpbi1yaWdodDo3cHh9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQpO1xuICAgIHJldHVybiBBZHZhbmNlZExlZ2VuZENvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBjYWNoZSA9IHt9O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzaG9ydCBpZC5cbiAqXG4gKiBEZXNjcmlwdGlvbjpcbiAqICAgQSA0LWNoYXJhY3RlciBhbHBoYW51bWVyaWMgc2VxdWVuY2UgKDM2NCA9IDEuNiBtaWxsaW9uKVxuICogICBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIEphdmFTY3JpcHQgc3BlY2lmaWMgbW9kZWxzLlxuICogICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYyNDg2NjYvaG93LXRvLWdlbmVyYXRlLXNob3J0LXVpZC1saWtlLWF4NGo5ei1pbi1qc1xuICpcbiAqICAgRXhhbXBsZTogYGViZ2ZgXG4gKi9cbmZ1bmN0aW9uIGlkKCkge1xuICAgIHZhciBuZXdJZCA9ICgnMDAwMCcgKyAoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCA0KSA8PCAwKS50b1N0cmluZygzNikpLnNsaWNlKC00KTtcbiAgICAvLyBhcHBlbmQgYSAnYScgYmVjYXVzZSBuZW8gZ2V0cyBtYWRcbiAgICBuZXdJZCA9IFwiYVwiICsgbmV3SWQ7XG4gICAgLy8gZW5zdXJlIG5vdCBhbHJlYWR5IHVzZWRcbiAgICBpZiAoIWNhY2hlW25ld0lkXSkge1xuICAgICAgICBjYWNoZVtuZXdJZF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3SWQ7XG4gICAgfVxuICAgIHJldHVybiBpZCgpO1xufVxuXG52YXIgY29sb3JTZXRzID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTogJ3ZpdmlkJyxcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiBbXG4gICAgICAgICAgICAnIzY0N2M4YScsICcjM2Y1MWI1JywgJyMyMTk2ZjMnLCAnIzAwYjg2MicsICcjYWZkZjBhJywgJyNhN2I2MWEnLCAnI2YzZTU2MicsICcjZmY5ODAwJywgJyNmZjU3MjInLCAnI2ZmNDUxNCdcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbmF0dXJhbCcsXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGdyb3VwOiAnT3JkaW5hbCcsXG4gICAgICAgIGRvbWFpbjogW1xuICAgICAgICAgICAgJyNiZjlkNzYnLCAnI2U5OTQ1MCcsICcjZDg5ZjU5JywgJyNmMmRmYTcnLCAnI2E1ZDdjNicsICcjNzc5NGIxJywgJyNhZmFmYWYnLCAnIzcwNzE2MCcsICcjYmE5MzgzJywgJyNkOWQ1YzMnXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2Nvb2wnLFxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjYTgzODVkJywgJyM3YWEzZTUnLCAnI2EyN2VhOCcsICcjYWFlM2Y1JywgJyNhZGNkZWQnLCAnI2E5NTk2MycsICcjODc5NmMwJywgJyM3ZWQzZWQnLCAnIzUwYWJjYycsICcjYWQ2ODg2J1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmaXJlJyxcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiBbXG4gICAgICAgICAgICAnI2ZmM2QwMCcsICcjYmYzNjBjJywgJyNmZjhmMDAnLCAnI2ZmNmYwMCcsICcjZmY1NzIyJywgJyNlNjUxMDAnLCAnI2ZmY2EyOCcsICcjZmZhYjAwJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdzb2xhcicsXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGdyb3VwOiAnQ29udGludW91cycsXG4gICAgICAgIGRvbWFpbjogW1xuICAgICAgICAgICAgJyNmZmY4ZTEnLCAnI2ZmZWNiMycsICcjZmZlMDgyJywgJyNmZmQ1NGYnLCAnI2ZmY2EyOCcsICcjZmZjMTA3JywgJyNmZmIzMDAnLCAnI2ZmYTAwMCcsICcjZmY4ZjAwJywgJyNmZjZmMDAnXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2FpcicsXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGdyb3VwOiAnQ29udGludW91cycsXG4gICAgICAgIGRvbWFpbjogW1xuICAgICAgICAgICAgJyNlMWY1ZmUnLCAnI2IzZTVmYycsICcjODFkNGZhJywgJyM0ZmMzZjcnLCAnIzI5YjZmNicsICcjMDNhOWY0JywgJyMwMzliZTUnLCAnIzAyODhkMScsICcjMDI3N2JkJywgJyMwMTU3OWInXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2FxdWEnLFxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgICBncm91cDogJ0NvbnRpbnVvdXMnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjZTBmN2ZhJywgJyNiMmViZjInLCAnIzgwZGVlYScsICcjNGRkMGUxJywgJyMyNmM2ZGEnLCAnIzAwYmNkNCcsICcjMDBhY2MxJywgJyMwMDk3YTcnLCAnIzAwODM4ZicsICcjMDA2MDY0J1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmbGFtZScsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjQTEwQTI4JywgJyNEMzM0MkQnLCAnI0VGNkQ0OScsICcjRkFBRDY3JywgJyNGRERFOTAnLCAnI0RCRUQ5MScsICcjQTlENzcwJywgJyM2Q0JBNjcnLCAnIzJDOTY1MycsICcjMTQ2NzM4J1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdvY2VhbicsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjMUQ2OEZCJywgJyMzM0MwRkMnLCAnIzRBRkZGRScsICcjQUZGRkZGJywgJyNGRkZDNjMnLCAnI0ZEQkQyRCcsICcjRkM4QTI1JywgJyNGQTRGMUUnLCAnI0ZBMTQxQicsICcjQkEzOEQxJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmb3Jlc3QnLFxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiBbXG4gICAgICAgICAgICAnIzU1QzIyRCcsICcjQzFGMzNEJywgJyMzQ0MwOTknLCAnI0FGRkZGRicsICcjOENGQzlEJywgJyM3NkNGRkEnLCAnI0JBNjBGQicsICcjRUU2NDkwJywgJyNDNDJBMUMnLCAnI0ZDOUYzMidcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaG9yaXpvbicsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjMjU5N0ZCJywgJyM2NUVCRkQnLCAnIzk5RkREMCcsICcjRkNFRTRCJywgJyNGRUZDRkEnLCAnI0ZERDZFMycsICcjRkNCMUE4JywgJyNFRjZGN0InLCAnI0NCOTZFOCcsICcjRUZERUUwJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICduZW9ucycsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjRkYzMzMzJywgJyNGRjMzRkYnLCAnI0NDMzNGRicsICcjMDAwMEZGJywgJyMzM0NDRkYnLCAnIzMzRkZGRicsICcjMzNGRjY2JywgJyNDQ0ZGMzMnLCAnI0ZGQ0MwMCcsICcjRkY2NjAwJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwaWNuaWMnLFxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiBbXG4gICAgICAgICAgICAnI0ZBQzUxRCcsICcjNjZCRDZEJywgJyNGQUEwMjYnLCAnIzI5QkI5QycsICcjRTk2QjU2JywgJyM1NUFDRDInLCAnI0I3MzMyRicsICcjMkM4M0M5JywgJyM5MTY2QjgnLCAnIzkyRTdFOCdcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbmlnaHQnLFxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiBbXG4gICAgICAgICAgICAnIzJCMUI1QScsICcjNTAxMzU2JywgJyMxODMzNTYnLCAnIzI4MjAzRicsICcjMzkxQjNDJywgJyMxRTJCM0MnLCAnIzEyMDYzNCcsXG4gICAgICAgICAgICAnIzJEMDQzMicsICcjMDUxOTMyJywgJyM0NTMwODAnLCAnIzc1MjY3RCcsICcjMkM1MDdEJywgJyM0QjM4ODAnLCAnIzc1MkY3RCcsICcjMzU1NDdEJ1xuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICduaWdodExpZ2h0cycsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxuICAgICAgICBkb21haW46IFtcbiAgICAgICAgICAgICcjNGUzMWE1JywgJyM5YzI1YTcnLCAnIzMwNjVhYicsICcjNTc0NjhiJywgJyM5MDQ0OTcnLCAnIzQ2NjQ4YicsXG4gICAgICAgICAgICAnIzMyMTE4ZCcsICcjYTAwZmIzJywgJyMxMDUyYTInLCAnIzZlNTFiZCcsICcjYjYzY2MzJywgJyM2Yzk3Y2InLCAnIzg2NzFjMScsICcjYjQ1NWJlJywgJyM3NDk2YzMnXG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG5mdW5jdGlvbiBzb3J0TGluZWFyKGRhdGEsIHByb3BlcnR5LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHsgZGlyZWN0aW9uID0gJ2FzYyc7IH1cbiAgICByZXR1cm4gZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdhc2MnKSB7XG4gICAgICAgICAgICByZXR1cm4gYVtwcm9wZXJ0eV0gLSBiW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiW3Byb3BlcnR5XSAtIGFbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzb3J0QnlEb21haW4oZGF0YSwgcHJvcGVydHksIGRpcmVjdGlvbiwgZG9tYWluKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IGRpcmVjdGlvbiA9ICdhc2MnOyB9XG4gICAgcmV0dXJuIGRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYVZhbCA9IGFbcHJvcGVydHldO1xuICAgICAgICB2YXIgYlZhbCA9IGJbcHJvcGVydHldO1xuICAgICAgICB2YXIgYUlkeCA9IGRvbWFpbi5pbmRleE9mKGFWYWwpO1xuICAgICAgICB2YXIgYklkeCA9IGRvbWFpbi5pbmRleE9mKGJWYWwpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYXNjJykge1xuICAgICAgICAgICAgcmV0dXJuIGFJZHggLSBiSWR4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJJZHggLSBhSWR4O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzb3J0QnlUaW1lKGRhdGEsIHByb3BlcnR5LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHsgZGlyZWN0aW9uID0gJ2FzYyc7IH1cbiAgICByZXR1cm4gZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhRGF0ZSA9IGFbcHJvcGVydHldLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGJEYXRlID0gYltwcm9wZXJ0eV0uZ2V0VGltZSgpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYXNjJykge1xuICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhRGF0ZSA+IGJEYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChiRGF0ZSA+IGFEYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBY2NlcHRzIGEgY29sb3IgKHN0cmluZykgYW5kIHJldHVybnMgYSBpbnZlcnRlZCBoZXggY29sb3IgKHN0cmluZylcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTYwMDI5NS9hdXRvbWF0aWNhbGx5LWNoYW5nZS10ZXh0LWNvbG9yLXRvLWFzc3VyZS1yZWFkYWJpbGl0eVxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW52ZXJ0Q29sb3IodmFsdWUpIHtcbiAgICB2YXIgY29sb3IgPSByZ2IodmFsdWUpO1xuICAgIHZhciByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBvcGFjaXR5ID0gY29sb3Iub3BhY2l0eTtcbiAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29sb3IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIHlpcSA9ICgociAqIDI5OSkgKyAoZyAqIDU4NykgKyAoYiAqIDExNCkpIC8gMTAwMDtcbiAgICB2YXIgZGVwdGggPSAoeWlxID49IDEyOCkgPyAtLjggOiAuODtcbiAgICByZXR1cm4gc2hhZGVSR0JDb2xvcihjb2xvciwgZGVwdGgpO1xufVxuLyoqXG4gKiBHaXZlbiBhIHJnYiwgaXQgd2lsbCBkYXJrZW4vbGlnaHRlblxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTYwMjQ4L3Byb2dyYW1tYXRpY2FsbHktbGlnaHRlbi1vci1kYXJrZW4tYS1oZXgtY29sb3Itb3ItcmdiLWFuZC1ibGVuZC1jb2xvcnNcbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0ge2FueX0geyByLCBnLCBiIH1cbiAqIEBwYXJhbSB7YW55fSBwZXJjZW50XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBzaGFkZVJHQkNvbG9yKF9hLCBwZXJjZW50KSB7XG4gICAgdmFyIHIgPSBfYS5yLCBnID0gX2EuZywgYiA9IF9hLmI7XG4gICAgdmFyIHQgPSBwZXJjZW50IDwgMCA/IDAgOiAyNTU7XG4gICAgdmFyIHAgPSBwZXJjZW50IDwgMCA/IHBlcmNlbnQgKiAtMSA6IHBlcmNlbnQ7XG4gICAgciA9IChNYXRoLnJvdW5kKCh0IC0gcikgKiBwKSArIHIpO1xuICAgIGcgPSAoTWF0aC5yb3VuZCgodCAtIGcpICogcCkgKyBnKTtcbiAgICBiID0gKE1hdGgucm91bmQoKHQgLSBiKSAqIHApICsgYik7XG4gICAgcmV0dXJuIFwicmdiKFwiICsgciArIFwiLCBcIiArIGcgKyBcIiwgXCIgKyBiICsgXCIpXCI7XG59XG5cbi8qKlxuICogVmlzaWJpbGl0eSBPYnNlcnZlclxuICovXG52YXIgVmlzaWJpbGl0eU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpc2liaWxpdHlPYnNlcnZlcihlbGVtZW50LCB6b25lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydW5DaGVjaygpO1xuICAgIH1cbiAgICBWaXNpYmlsaXR5T2JzZXJ2ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH07XG4gICAgVmlzaWJpbGl0eU9ic2VydmVyLnByb3RvdHlwZS5vblZpc2liaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIHRyaWdnZXIgem9uZSByZWNhbGMgZm9yIGNvbHVtbnNcbiAgICAgICAgdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMudmlzaWJsZS5lbWl0KHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZpc2liaWxpdHlPYnNlcnZlci5wcm90b3R5cGUucnVuQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL29mZnNldGhlaWdodC12aXNpYmlsaXR5XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG9mZnNldEhlaWdodCA9IF9hLm9mZnNldEhlaWdodCwgb2Zmc2V0V2lkdGggPSBfYS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXRIZWlnaHQgJiYgb2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25WaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrKCk7IH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVjaygpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgVmlzaWJpbGl0eU9ic2VydmVyLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFZpc2liaWxpdHlPYnNlcnZlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG52YXIgQmFzZUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VDaGFydENvbXBvbmVudChjaGFydEVsZW1lbnQsIHpvbmUsIGNkKSB7XG4gICAgICAgIHRoaXMuY2hhcnRFbGVtZW50ID0gY2hhcnRFbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuc2NoZW1lID0gJ2Nvb2wnO1xuICAgICAgICB0aGlzLnNjaGVtZVR5cGUgPSAnb3JkaW5hbCc7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iaW5kV2luZG93UmVzaXplRXZlbnQoKTtcbiAgICAgICAgLy8gbGlzdGVuIGZvciB2aXNpYmlsaXR5IG9mIHRoZSBlbGVtZW50IGZvciBoaWRkZW4gYnkgZGVmYXVsdCBzY2VuYXJpb1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlPYnNlcnZlciA9IG5ldyBWaXNpYmlsaXR5T2JzZXJ2ZXIodGhpcy5jaGFydEVsZW1lbnQsIHRoaXMuem9uZSk7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eU9ic2VydmVyLnZpc2libGUuc3Vic2NyaWJlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJpbGl0eU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlPYnNlcnZlci52aXNpYmxlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlPYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuY2xvbmVEYXRhKHRoaXMucmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy52aWV3WzBdO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnZpZXdbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IHRoaXMuZ2V0Q29udGFpbmVyRGltcygpO1xuICAgICAgICAgICAgaWYgKGRpbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGRpbXMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzIGlmIHdpZHRoIG9yIGhlaWdodCBhcmUgMCBvciB1bmRlZmluZWRcbiAgICAgICAgaWYgKCF0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gNjAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gNDAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmZsb29yKHRoaXMud2lkdGgpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5jZCkge1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRDb250YWluZXJEaW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgIHZhciBob3N0RWxlbSA9IHRoaXMuY2hhcnRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChob3N0RWxlbS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgZGltcyA9IGhvc3RFbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBkaW1zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZGF0ZSBvYmplY3RzIHRoYXQgYXBwZWFyIGFzIG5hbWVcbiAgICAgKiBpbnRvIGZvcm1hdHRlZCBkYXRlIHN0cmluZ3NcbiAgICAgKi9cbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmZvcm1hdERhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLnJlc3VsdHNbaV07XG4gICAgICAgICAgICBnLmxhYmVsID0gZy5uYW1lO1xuICAgICAgICAgICAgaWYgKGcubGFiZWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgZy5sYWJlbCA9IGcubGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZy5zZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGcuc2VyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZy5zZXJpZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGQubGFiZWwgPSBkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkLmxhYmVsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5sYWJlbCA9IGQubGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUuYmluZFdpbmRvd1Jlc2l6ZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc291cmNlID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnBpcGUoZGVib3VuY2VUaW1lKDIwMCkpLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY2QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBkYXRhIGludG8gYSBuZXcgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSBkYXRhXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQmFzZUNoYXJ0XG4gICAgICovXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5jbG9uZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRhdGFfMSA9IGRhdGE7IF9pIDwgZGF0YV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBkYXRhXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGNvcHkgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbVsnbmFtZSddXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGl0ZW1bJ3ZhbHVlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvcHlbJ3ZhbHVlJ10gPSBpdGVtWyd2YWx1ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1bJ3NlcmllcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb3B5WydzZXJpZXMnXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBpdGVtWydzZXJpZXMnXTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0l0ZW0gPSBfYltfYV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJdGVtQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0l0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBjb3B5WydzZXJpZXMnXS5wdXNoKHNlcmllc0l0ZW1Db3B5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbVsnZXh0cmEnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29weVsnZXh0cmEnXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaXRlbVsnZXh0cmEnXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvcHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXN1bHRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VzdG9tQ29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIEJhc2VDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdiYXNlLWNoYXJ0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2PjwvZGl2PlxcbiAgXCJcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdCwgdHlwZW9mIChfYiA9IHR5cGVvZiBOZ1pvbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgTmdab25lKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QsIHR5cGVvZiAoX2MgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdF0pXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFzZUNoYXJ0Q29tcG9uZW50O1xufSgpKTtcblxudmFyIEF4aXNMYWJlbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBeGlzTGFiZWxDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSAyNTtcbiAgICAgICAgdGhpcy5tYXJnaW4gPSA1O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAnMC4wMSc7XG4gICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICBzd2l0Y2ggKHRoaXMub3JpZW50KSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHRoaXMueSA9IC0odGhpcy5vZmZzZXQgKyB0aGlzLnRleHRIZWlnaHQgKyB0aGlzLm1hcmdpbik7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICdyb3RhdGUoMjcwKSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5vZmZzZXQgKyB0aGlzLm1hcmdpbjtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gJ3JvdGF0ZSgyNzApJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIm9mZnNldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuICAgIEF4aXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXhpcy1sYWJlbF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6dGV4dFxcbiAgICAgIFthdHRyLnN0cm9rZS13aWR0aF09XFxcInN0cm9rZVdpZHRoXFxcIlxcbiAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIlxcbiAgICAgIFthdHRyLnldPVxcXCJ5XFxcIlxcbiAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiPlxcbiAgICAgIHt7bGFiZWx9fVxcbiAgICA8L3N2Zzp0ZXh0PlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQpO1xuICAgIHJldHVybiBBeGlzTGFiZWxDb21wb25lbnQ7XG59KCkpO1xuXG5mdW5jdGlvbiByZWR1Y2VUaWNrcyh0aWNrcywgbWF4VGlja3MpIHtcbiAgICBpZiAodGlja3MubGVuZ3RoID4gbWF4VGlja3MpIHtcbiAgICAgICAgdmFyIHJlZHVjZWQgPSBbXTtcbiAgICAgICAgdmFyIG1vZHVsdXMgPSBNYXRoLmZsb29yKHRpY2tzLmxlbmd0aCAvIG1heFRpY2tzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgJSBtb2R1bHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVkdWNlZC5wdXNoKHRpY2tzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aWNrcyA9IHJlZHVjZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbn1cblxudmFyIFhBeGlzVGlja3NDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWEF4aXNUaWNrc0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy50aWNrQXJndW1lbnRzID0gWzVdO1xuICAgICAgICB0aGlzLnRpY2tTdHJva2UgPSAnI2NjYyc7XG4gICAgICAgIHRoaXMudHJpbVRpY2tzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXhUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdGF0ZVRpY2tzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAyMDtcbiAgICAgICAgdGhpcy5yb3RhdGVMYWJlbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbm5lclRpY2tTaXplID0gNjtcbiAgICAgICAgdGhpcy5vdXRlclRpY2tTaXplID0gNjtcbiAgICAgICAgdGhpcy50aWNrUGFkZGluZyA9IDM7XG4gICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICB0aGlzLm1heFRpY2tzTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5tYXhBbGxvd2VkTGVuZ3RoID0gMTY7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XG4gICAgfTtcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVEaW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQodGhpcy50aWNrc0VsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsIDEwKTtcbiAgICAgICAgaWYgKGhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy50aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcbiAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IHRoaXMudGlja0Zvcm1hdHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NhbGUudGlja0Zvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGhpcy50aWNrQXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuY29uc3RydWN0b3IubmFtZSA9PT0gJ0RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLnJvdGF0ZVRpY2tzID8gdGhpcy5nZXRSb3RhdGlvbkFuZ2xlKHRoaXMudGlja3MpIDogbnVsbDtcbiAgICAgICAgdGhpcy5hZGp1c3RlZFNjYWxlID0gdGhpcy5zY2FsZS5iYW5kd2lkdGhcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShkKSArIHRoaXMuc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMudGV4dFRyYW5zZm9ybSA9ICcnO1xuICAgICAgICBpZiAoYW5nbGUgJiYgYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgYW5nbGUgKyBcIilcIjtcbiAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcbiAgICB9O1xuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldFJvdGF0aW9uQW5nbGUgPSBmdW5jdGlvbiAodGlja3MpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgdGhpcy5tYXhUaWNrc0xlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aWNrID0gdGhpcy50aWNrRm9ybWF0KHRpY2tzW2ldKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIHRpY2tMZW5ndGggPSB0aWNrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaW1UaWNrcykge1xuICAgICAgICAgICAgICAgIHRpY2tMZW5ndGggPSB0aGlzLnRpY2tUcmltKHRpY2spLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWNrTGVuZ3RoID4gdGhpcy5tYXhUaWNrc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4VGlja3NMZW5ndGggPSB0aWNrTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLm1heFRpY2tzTGVuZ3RoLCB0aGlzLm1heEFsbG93ZWRMZW5ndGgpO1xuICAgICAgICB2YXIgY2hhcldpZHRoID0gODsgLy8gbmVlZCB0byBtZWFzdXJlIHRoaXNcbiAgICAgICAgdmFyIHdvcmRXaWR0aCA9IGxlbiAqIGNoYXJXaWR0aDtcbiAgICAgICAgdmFyIGJhc2VXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgdmFyIG1heEJhc2VXaWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIHRpY2tzLmxlbmd0aCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBvcHRpbWFsIGFuZ2xlXG4gICAgICAgIHdoaWxlIChiYXNlV2lkdGggPiBtYXhCYXNlV2lkdGggJiYgYW5nbGUgPiAtOTApIHtcbiAgICAgICAgICAgIGFuZ2xlIC09IDMwO1xuICAgICAgICAgICAgYmFzZVdpZHRoID0gTWF0aC5jb3MoYW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpICogd29yZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICB9O1xuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGlja3M7XG4gICAgICAgIHZhciBtYXhUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoMjApO1xuICAgICAgICB2YXIgbWF4U2NhbGVUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoMTAwKTtcbiAgICAgICAgaWYgKHRoaXMudGlja1ZhbHVlcykge1xuICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tWYWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZS50aWNrcykge1xuICAgICAgICAgICAgdGlja3MgPSB0aGlzLnNjYWxlLnRpY2tzLmFwcGx5KHRoaXMuc2NhbGUsIFttYXhTY2FsZVRpY2tzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUuZG9tYWluKCk7XG4gICAgICAgICAgICB0aWNrcyA9IHJlZHVjZVRpY2tzKHRpY2tzLCBtYXhUaWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0TWF4VGlja3MgPSBmdW5jdGlvbiAodGlja1dpZHRoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMud2lkdGggLyB0aWNrV2lkdGgpO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudGlja1RyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB0aGlzLmFkanVzdGVkU2NhbGUodGljaykgKyAnLCcgKyB0aGlzLnZlcnRpY2FsU3BhY2luZyArICcpJztcbiAgICB9O1xuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdyaWRMaW5lVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArICgtdGhpcy52ZXJ0aWNhbFNwYWNpbmcgLSA1KSArIFwiKVwiO1xuICAgIH07XG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudGlja1RyaW0gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbVRpY2tzID8gdHJpbUxhYmVsKGxhYmVsLCB0aGlzLm1heFRpY2tMZW5ndGgpIDogbGFiZWw7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrQXJndW1lbnRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrVmFsdWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja1N0cm9rZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JpZExpbmVIZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBWaWV3Q2hpbGQoJ3RpY2tzZWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tzRWxlbWVudFwiLCB2b2lkIDApO1xuICAgIFhBeGlzVGlja3NDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXgtYXhpcy10aWNrc10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAjdGlja3NlbD5cXG4gICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrc1xcXCIgY2xhc3M9XFxcInRpY2tcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRpY2tUcmFuc2Zvcm0odGljaylcXFwiPlxcbiAgICAgICAgPHRpdGxlPnt7IHRpY2tGb3JtYXQodGljaykgfX08L3RpdGxlPlxcbiAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cXFwiMC4wMVxcXCJcXG4gICAgICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVxcXCJ0ZXh0QW5jaG9yXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0ZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICBbc3R5bGUuZm9udC1zaXplXT1cXFwiJzEycHgnXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICB7eyB0aWNrVHJpbSh0aWNrRm9ybWF0KHRpY2spKSB9fVxcbiAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcblxcbiAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrc1xcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidGlja1RyYW5zZm9ybSh0aWNrKVxcXCI+XFxuICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93R3JpZExpbmVzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIj5cXG4gICAgICAgIDxzdmc6bGluZSBjbGFzcz1cXFwiZ3JpZGxpbmUtcGF0aCBncmlkbGluZS1wYXRoLXZlcnRpY2FsXFxcIiBbYXR0ci55MV09XFxcIi1ncmlkTGluZUhlaWdodFxcXCIgeTI9XFxcIjBcXFwiIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gWEF4aXNUaWNrc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBYQXhpc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYQXhpc0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5yb3RhdGVUaWNrcyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnhPcmllbnQgPSAnYm90dG9tJztcbiAgICAgICAgdGhpcy54QXhpc09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMueEF4aXNDbGFzc05hbWUgPSAneCBheGlzJztcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZmlsbCA9ICdub25lJztcbiAgICAgICAgdGhpcy5zdHJva2UgPSAnc3Ryb2tlJztcbiAgICAgICAgdGhpcy50aWNrU3Ryb2tlID0gJyNjY2MnO1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgIH1cbiAgICBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZSgwLFwiICsgKHRoaXMueEF4aXNPZmZzZXQgKyB0aGlzLnBhZGRpbmcgKyB0aGlzLmRpbXMuaGVpZ2h0KSArIFwiKVwiO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMueEF4aXNUaWNrQ291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbdGhpcy54QXhpc1RpY2tDb3VudF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5lbWl0VGlja3NIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdmFyIG5ld0xhYmVsT2Zmc2V0ID0gaGVpZ2h0ICsgMjUgKyA1O1xuICAgICAgICBpZiAobmV3TGFiZWxPZmZzZXQgIT09IHRoaXMubGFiZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSBuZXdMYWJlbE9mZnNldDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVRpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFRpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93TGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxUZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrSW50ZXJ2YWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrQ291bnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieE9yaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc09mZnNldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltZW5zaW9uc0NoYW5nZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKFhBeGlzVGlja3NDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgWEF4aXNUaWNrc0NvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBYQXhpc1RpY2tzQ29tcG9uZW50KSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tzQ29tcG9uZW50XCIsIHZvaWQgMCk7XG4gICAgWEF4aXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXgtYXhpc10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBbYXR0ci5jbGFzc109XFxcInhBeGlzQ2xhc3NOYW1lXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXMtdGlja3NcXG4gICAgICAgICpuZ0lmPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVRpY2tzXFxcIlxcbiAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlVGlja3NcXFwiXFxuICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFRpY2tMZW5ndGhcXFwiXFxuICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ0aWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgIFt0aWNrQXJndW1lbnRzXT1cXFwidGlja0FyZ3VtZW50c1xcXCJcXG4gICAgICAgIFt0aWNrU3Ryb2tlXT1cXFwidGlja1N0cm9rZVxcXCJcXG4gICAgICAgIFtzY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgIFtvcmllbnRdPVxcXCJ4T3JpZW50XFxcIlxcbiAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgW2dyaWRMaW5lSGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICBbd2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgICAgW3RpY2tWYWx1ZXNdPVxcXCJ0aWNrc1xcXCJcXG4gICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcImVtaXRUaWNrc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWF4aXMtbGFiZWxcXG4gICAgICAgICpuZ0lmPVxcXCJzaG93TGFiZWxcXFwiXFxuICAgICAgICBbbGFiZWxdPVxcXCJsYWJlbFRleHRcXFwiXFxuICAgICAgICBbb2Zmc2V0XT1cXFwibGFiZWxPZmZzZXRcXFwiXFxuICAgICAgICBbb3JpZW50XT1cXFwiJ2JvdHRvbSdcXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICBbd2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIFhBeGlzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gWEF4aXNDb21wb25lbnQ7XG59KCkpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJvdW5kZWQgcmVjdGFuZ2xhciBwYXRoXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHsqfSB4LCB5LCB3LCBoLCByLCB0bCwgdHIsIGJsLCBiclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcm91bmRlZFJlY3QoeCwgeSwgdywgaCwgciwgX2EpIHtcbiAgICB2YXIgdGwgPSBfYVswXSwgdHIgPSBfYVsxXSwgYmwgPSBfYVsyXSwgYnIgPSBfYVszXTtcbiAgICB2YXIgcmV0dmFsID0gJyc7XG4gICAgdyA9IE1hdGguZmxvb3Iodyk7XG4gICAgaCA9IE1hdGguZmxvb3IoaCk7XG4gICAgdyA9IHcgPT09IDAgPyAxIDogdztcbiAgICBoID0gaCA9PT0gMCA/IDEgOiBoO1xuICAgIHJldHZhbCA9IFwiTVwiICsgW3ggKyByLCB5XTtcbiAgICByZXR2YWwgKz0gXCJoXCIgKyAodyAtIDIgKiByKTtcbiAgICBpZiAodHIpIHtcbiAgICAgICAgcmV0dmFsICs9IFwiYVwiICsgW3IsIHJdICsgXCIgMCAwIDEgXCIgKyBbciwgcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR2YWwgKz0gXCJoXCIgKyByICsgXCJ2XCIgKyByO1xuICAgIH1cbiAgICByZXR2YWwgKz0gXCJ2XCIgKyAoaCAtIDIgKiByKTtcbiAgICBpZiAoYnIpIHtcbiAgICAgICAgcmV0dmFsICs9IFwiYVwiICsgW3IsIHJdICsgXCIgMCAwIDEgXCIgKyBbLXIsIHJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dmFsICs9IFwidlwiICsgciArIFwiaFwiICsgLXI7XG4gICAgfVxuICAgIHJldHZhbCArPSBcImhcIiArICgyICogciAtIHcpO1xuICAgIGlmIChibCkge1xuICAgICAgICByZXR2YWwgKz0gXCJhXCIgKyBbciwgcl0gKyBcIiAwIDAgMSBcIiArIFstciwgLXJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dmFsICs9IFwiaFwiICsgLXIgKyBcInZcIiArIC1yO1xuICAgIH1cbiAgICByZXR2YWwgKz0gXCJ2XCIgKyAoMiAqIHIgLSBoKTtcbiAgICBpZiAodGwpIHtcbiAgICAgICAgcmV0dmFsICs9IFwiYVwiICsgW3IsIHJdICsgXCIgMCAwIDEgXCIgKyBbciwgLXJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dmFsICs9IFwidlwiICsgLXIgKyBcImhcIiArIHI7XG4gICAgfVxuICAgIHJldHZhbCArPSBcInpcIjtcbiAgICByZXR1cm4gcmV0dmFsO1xufVxuXG52YXIgWUF4aXNUaWNrc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBZQXhpc1RpY2tzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbNV07XG4gICAgICAgIHRoaXMudGlja1N0cm9rZSA9ICcjY2NjJztcbiAgICAgICAgdGhpcy50cmltVGlja3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heFRpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgdGhpcy5zaG93R3JpZExpbmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvd1JlZkxhYmVscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3dSZWZMaW5lcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmlubmVyVGlja1NpemUgPSA2O1xuICAgICAgICB0aGlzLnRpY2tQYWRkaW5nID0gMztcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAyMDtcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLm91dGVyVGlja1NpemUgPSA2O1xuICAgICAgICB0aGlzLnJvdGF0ZUxhYmVscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUxpbmVMZW5ndGggPSAwO1xuICAgIH1cbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcbiAgICB9O1xuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURpbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHRoaXMudGlja3NFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsIDEwKTtcbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyB3aWR0aDogd2lkdGggfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICB2YXIgc2lnbiA9IHRoaXMub3JpZW50ID09PSAndG9wJyB8fCB0aGlzLm9yaWVudCA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICAgICAgdGhpcy50aWNrU3BhY2luZyA9IE1hdGgubWF4KHRoaXMuaW5uZXJUaWNrU2l6ZSwgMCkgKyB0aGlzLnRpY2tQYWRkaW5nO1xuICAgICAgICBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMudGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG4gICAgICAgIGlmICh0aGlzLnRpY2tGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSB0aGlzLnRpY2tGb3JtYXR0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjYWxlLnRpY2tGb3JtYXQpIHtcbiAgICAgICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IHNjYWxlLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUsIHRoaXMudGlja0FyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGp1c3RlZFNjYWxlID0gc2NhbGUuYmFuZHdpZHRoXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlKGQpICsgc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHNjYWxlO1xuICAgICAgICBpZiAodGhpcy5zaG93UmVmTGluZXMgJiYgdGhpcy5yZWZlcmVuY2VMaW5lcykge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWZlcmVuY2VsaW5lcygpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcmllbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodGljaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgJywwKSc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gdGhpcy5pbm5lclRpY2tTaXplICogc2lnbjtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gdGhpcy50aWNrU3BhY2luZyAqIHNpZ247XG4gICAgICAgICAgICAgICAgdGhpcy5keSA9IHNpZ24gPCAwID8gJzBlbScgOiAnLjcxZW0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB0aGlzLmFkanVzdGVkU2NhbGUodGljaykgKyAnLDApJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgIHRoaXMueTIgPSB0aGlzLmlubmVyVGlja1NpemUgKiBzaWduO1xuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB0aGlzLnRpY2tTcGFjaW5nICogc2lnbjtcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gc2lnbiA8IDAgPyAnMGVtJyA6ICcuNzFlbSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArICcpJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB0aGlzLmlubmVyVGlja1NpemUgKiAtc2lnbjtcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdGhpcy50aWNrU3BhY2luZyAqIC1zaWduO1xuICAgICAgICAgICAgICAgIHRoaXMuZHkgPSAnLjMyZW0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgJyknO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdGhpcy5pbm5lclRpY2tTaXplICogLXNpZ247XG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHRoaXMudGlja1NwYWNpbmcgKiAtc2lnbjtcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gJy4zMmVtJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xuICAgIH07XG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuc2V0UmVmZXJlbmNlbGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVmTWluID0gdGhpcy5hZGp1c3RlZFNjYWxlKE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMucmVmZXJlbmNlTGluZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZhbHVlOyB9KSkpO1xuICAgICAgICB0aGlzLnJlZk1heCA9IHRoaXMuYWRqdXN0ZWRTY2FsZShNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLnJlZmVyZW5jZUxpbmVzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS52YWx1ZTsgfSkpKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VMaW5lTGVuZ3RoID0gdGhpcy5yZWZlcmVuY2VMaW5lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlQXJlYVBhdGggPSByb3VuZGVkUmVjdCgwLCB0aGlzLnJlZk1heCwgdGhpcy5ncmlkTGluZVdpZHRoLCB0aGlzLnJlZk1pbiAtIHRoaXMucmVmTWF4LCAwLCBbXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGlja3M7XG4gICAgICAgIHZhciBtYXhUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoMjApO1xuICAgICAgICB2YXIgbWF4U2NhbGVUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoNTApO1xuICAgICAgICBpZiAodGhpcy50aWNrVmFsdWVzKSB7XG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja1ZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlLnRpY2tzKSB7XG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUudGlja3MuYXBwbHkodGhpcy5zY2FsZSwgW21heFNjYWxlVGlja3NdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tzID0gdGhpcy5zY2FsZS5kb21haW4oKTtcbiAgICAgICAgICAgIHRpY2tzID0gcmVkdWNlVGlja3ModGlja3MsIG1heFRpY2tzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRNYXhUaWNrcyA9IGZ1bmN0aW9uICh0aWNrSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0IC8gdGlja0hlaWdodCk7XG4gICAgfTtcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS50aWNrVHJhbnNmb3JtID0gZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgXCIsXCIgKyB0aGlzLnZlcnRpY2FsU3BhY2luZyArIFwiKVwiO1xuICAgIH07XG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ3JpZExpbmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSg1LDApXCI7XG4gICAgfTtcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS50aWNrVHJpbSA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmltVGlja3MgPyB0cmltTGFiZWwobGFiZWwsIHRoaXMubWF4VGlja0xlbmd0aCkgOiBsYWJlbDtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tBcmd1bWVudHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tWYWx1ZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrU3Ryb2tlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1UaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFRpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmlkTGluZVdpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicmVmZXJlbmNlTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1JlZkxhYmVsc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltZW5zaW9uc0NoYW5nZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKCd0aWNrc2VsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrc0VsZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy15LWF4aXMtdGlja3NdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgI3RpY2tzZWw+XFxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3NcXFwiIGNsYXNzPVxcXCJ0aWNrXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm0odGljaylcXFwiPlxcbiAgICAgICAgPHRpdGxlPnt7IHRpY2tGb3JtYXQodGljaykgfX08L3RpdGxlPlxcbiAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cXFwiMC4wMVxcXCJcXG4gICAgICAgICAgW2F0dHIuZHldPVxcXCJkeVxcXCJcXG4gICAgICAgICAgW2F0dHIueF09XFxcIngxXFxcIlxcbiAgICAgICAgICBbYXR0ci55XT1cXFwieTFcXFwiXFxuICAgICAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgW3N0eWxlLmZvbnQtc2l6ZV09XFxcIicxMnB4J1xcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAge3sgdGlja1RyaW0odGlja0Zvcm1hdCh0aWNrKSkgfX1cXG4gICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG5cXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgKm5nSWY9XFxcInJlZmVyZW5jZUxpbmVMZW5ndGggPiAxICYmIHJlZk1heCAmJiByZWZNaW4gJiYgc2hvd1JlZkxpbmVzXFxcIlxcbiAgICAgIGNsYXNzPVxcXCJyZWZlcmVuY2UtYXJlYVxcXCJcXG4gICAgICBbYXR0ci5kXT1cXFwicmVmZXJlbmNlQXJlYVBhdGhcXFwiXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JpZExpbmVUcmFuc2Zvcm0oKVxcXCJcXG4gICAgLz5cXG4gICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3NcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybSh0aWNrKVxcXCI+XFxuICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93R3JpZExpbmVzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIj5cXG4gICAgICAgIDxzdmc6bGluZVxcbiAgICAgICAgICAqbmdJZj1cXFwib3JpZW50ID09PSAnbGVmdCdcXFwiXFxuICAgICAgICAgIGNsYXNzPVxcXCJncmlkbGluZS1wYXRoIGdyaWRsaW5lLXBhdGgtaG9yaXpvbnRhbFxcXCJcXG4gICAgICAgICAgeDE9XFxcIjBcXFwiXFxuICAgICAgICAgIFthdHRyLngyXT1cXFwiZ3JpZExpbmVXaWR0aFxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8c3ZnOmxpbmVcXG4gICAgICAgICAgKm5nSWY9XFxcIm9yaWVudCA9PT0gJ3JpZ2h0J1xcXCJcXG4gICAgICAgICAgY2xhc3M9XFxcImdyaWRsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC1ob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2F0dHIueDJdPVxcXCItZ3JpZExpbmVXaWR0aFxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG5cXG4gICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHJlZkxpbmUgb2YgcmVmZXJlbmNlTGluZXNcXFwiPlxcbiAgICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd1JlZkxpbmVzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm0ocmVmTGluZS52YWx1ZSlcXFwiPlxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgIGNsYXNzPVxcXCJyZWZsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC1ob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2F0dHIueDJdPVxcXCJncmlkTGluZVdpZHRoXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd1JlZkxhYmVsc1xcXCI+XFxuICAgICAgICAgIDx0aXRsZT57eyB0aWNrVHJpbSh0aWNrRm9ybWF0KHJlZkxpbmUudmFsdWUpKSB9fTwvdGl0bGU+XFxuICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJyZWZsaW5lLWxhYmVsXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmR5XT1cXFwiZHlcXFwiXFxuICAgICAgICAgICAgW2F0dHIueV09XFxcIi02XFxcIlxcbiAgICAgICAgICAgIFthdHRyLnhdPVxcXCJncmlkTGluZVdpZHRoXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIHt7IHJlZkxpbmUubmFtZSB9fVxcbiAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQpO1xuICAgIHJldHVybiBZQXhpc1RpY2tzQ29tcG9uZW50O1xufSgpKTtcblxudmFyIFlBeGlzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFlBeGlzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnNob3dHcmlkTGluZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55T3JpZW50ID0gJ2xlZnQnO1xuICAgICAgICB0aGlzLnlBeGlzT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy55QXhpc0NsYXNzTmFtZSA9ICd5IGF4aXMnO1xuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gMTU7XG4gICAgICAgIHRoaXMuZmlsbCA9ICdub25lJztcbiAgICAgICAgdGhpcy5zdHJva2UgPSAnI0NDQyc7XG4gICAgICAgIHRoaXMudGlja1N0cm9rZSA9ICcjQ0NDJztcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgfVxuICAgIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IC0odGhpcy55QXhpc09mZnNldCArIHRoaXMucGFkZGluZyk7XG4gICAgICAgIGlmICh0aGlzLnlPcmllbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSA2NTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyAodGhpcy5vZmZzZXQgKyB0aGlzLmRpbXMud2lkdGgpICsgXCIgLCAwKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLm9mZnNldCArIFwiICwgMClcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy55QXhpc1RpY2tDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbdGhpcy55QXhpc1RpY2tDb3VudF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5lbWl0VGlja3NXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLmxhYmVsT2Zmc2V0ICYmIHRoaXMueU9yaWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IHdpZHRoICsgdGhpcy5sYWJlbE9mZnNldDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyB3aWR0aDogd2lkdGggfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aWR0aCAhPT0gdGhpcy5sYWJlbE9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IHdpZHRoO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGltZW5zaW9uc0NoYW5nZWQuZW1pdCh7IHdpZHRoOiB3aWR0aCB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4VGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tJbnRlcnZhbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tDb3VudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5T3JpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInJlZmVyZW5jZUxpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dSZWZMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGFiZWxzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzT2Zmc2V0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBWaWV3Q2hpbGQoWUF4aXNUaWNrc0NvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBZQXhpc1RpY2tzQ29tcG9uZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIFlBeGlzVGlja3NDb21wb25lbnQpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NDb21wb25lbnRcIiwgdm9pZCAwKTtcbiAgICBZQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteS1heGlzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIFthdHRyLmNsYXNzXT1cXFwieUF4aXNDbGFzc05hbWVcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXktYXhpcy10aWNrc1xcbiAgICAgICAgKm5nSWY9XFxcInlTY2FsZVxcXCJcXG4gICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltVGlja3NcXFwiXFxuICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFRpY2tMZW5ndGhcXFwiXFxuICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ0aWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgIFt0aWNrQXJndW1lbnRzXT1cXFwidGlja0FyZ3VtZW50c1xcXCJcXG4gICAgICAgIFt0aWNrVmFsdWVzXT1cXFwidGlja3NcXFwiXFxuICAgICAgICBbdGlja1N0cm9rZV09XFxcInRpY2tTdHJva2VcXFwiXFxuICAgICAgICBbc2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICBbb3JpZW50XT1cXFwieU9yaWVudFxcXCJcXG4gICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgIFtncmlkTGluZVdpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgIFtyZWZlcmVuY2VMaW5lc109XFxcInJlZmVyZW5jZUxpbmVzXFxcIlxcbiAgICAgICAgW3Nob3dSZWZMaW5lc109XFxcInNob3dSZWZMaW5lc1xcXCJcXG4gICAgICAgIFtzaG93UmVmTGFiZWxzXT1cXFwic2hvd1JlZkxhYmVsc1xcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcImVtaXRUaWNrc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgLz5cXG5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtYXhpcy1sYWJlbFxcbiAgICAgICAgKm5nSWY9XFxcInNob3dMYWJlbFxcXCJcXG4gICAgICAgIFtsYWJlbF09XFxcImxhYmVsVGV4dFxcXCJcXG4gICAgICAgIFtvZmZzZXRdPVxcXCJsYWJlbE9mZnNldFxcXCJcXG4gICAgICAgIFtvcmllbnRdPVxcXCJ5T3JpZW50XFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcImRpbXMuaGVpZ2h0XFxcIlxcbiAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICA+PC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBZQXhpc0NvbXBvbmVudCk7XG4gICAgcmV0dXJuIFlBeGlzQ29tcG9uZW50O1xufSgpKTtcblxudmFyIEF4ZXNNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXhlc01vZHVsZSgpIHtcbiAgICB9XG4gICAgQXhlc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0F4aXNMYWJlbENvbXBvbmVudCwgWEF4aXNDb21wb25lbnQsIFhBeGlzVGlja3NDb21wb25lbnQsIFlBeGlzQ29tcG9uZW50LCBZQXhpc1RpY2tzQ29tcG9uZW50XSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtBeGlzTGFiZWxDb21wb25lbnQsIFhBeGlzQ29tcG9uZW50LCBYQXhpc1RpY2tzQ29tcG9uZW50LCBZQXhpc0NvbXBvbmVudCwgWUF4aXNUaWNrc0NvbXBvbmVudF1cbiAgICAgICAgfSlcbiAgICBdLCBBeGVzTW9kdWxlKTtcbiAgICByZXR1cm4gQXhlc01vZHVsZTtcbn0oKSk7XG5cbnZhciBDb2xvckhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2xvckhlbHBlcihzY2hlbWUsIHR5cGUsIGRvbWFpbiwgY3VzdG9tQ29sb3JzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2NoZW1lID0gY29sb3JTZXRzLmZpbmQoZnVuY3Rpb24gKGNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzLm5hbWUgPT09IHNjaGVtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JEb21haW4gPSBzY2hlbWUuZG9tYWluO1xuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xuICAgICAgICB0aGlzLmN1c3RvbUNvbG9ycyA9IGN1c3RvbUNvbG9ycztcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuZ2VuZXJhdGVDb2xvclNjaGVtZShzY2hlbWUsIHR5cGUsIHRoaXMuZG9tYWluKTtcbiAgICB9XG4gICAgQ29sb3JIZWxwZXIucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JTY2hlbWUgPSBmdW5jdGlvbiAoc2NoZW1lLCB0eXBlLCBkb21haW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBjb2xvclNldHMuZmluZChmdW5jdGlvbiAoY3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3MubmFtZSA9PT0gc2NoZW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yU2NhbGU7XG4gICAgICAgIGlmICh0eXBlID09PSAncXVhbnRpbGUnKSB7XG4gICAgICAgICAgICBjb2xvclNjYWxlID0gc2NhbGVRdWFudGlsZSgpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHNjaGVtZS5kb21haW4pXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgY29sb3JTY2FsZSA9IHNjYWxlT3JkaW5hbCgpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHNjaGVtZS5kb21haW4pXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICAvLyBsaW5lYXIgc2NoZW1lcyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBjb2xvcnNcbiAgICAgICAgICAgIHZhciBjb2xvckRvbWFpbiA9IHNjaGVtZS5kb21haW4uc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChjb2xvckRvbWFpbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb2xvckRvbWFpbi5wdXNoKGNvbG9yRG9tYWluWzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yRG9tYWluID0gY29sb3JEb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gcmFuZ2UoMCwgMSwgMS4wIC8gY29sb3JEb21haW4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbG9yU2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihwb2ludHMpXG4gICAgICAgICAgICAgICAgLnJhbmdlKGNvbG9yRG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3JTY2FsZTtcbiAgICB9O1xuICAgIENvbG9ySGVscGVyLnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBjYW4gbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVTY2FsZSA9IHNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZG9tYWluKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWVTY2FsZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmN1c3RvbUNvbG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUNvbG9ycyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWVfMSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB2b2lkIDA7IC8vIHRvZG8gdHlwZSBjdXN0b21Db2xvcnNcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUNvbG9ycyAmJiB0aGlzLmN1c3RvbUNvbG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmN1c3RvbUNvbG9ycy5maW5kKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBwaW5nLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZm9ybWF0dGVkVmFsdWVfMS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2xvckhlbHBlci5wcm90b3R5cGUuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5kb21haW5bMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlU2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZG9tYWluKVxuICAgICAgICAgICAgLnJhbmdlKFswLCAxXSk7XG4gICAgICAgIHZhciBjb2xvclZhbHVlU2NhbGUgPSBzY2FsZUJhbmQoKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmNvbG9yRG9tYWluKVxuICAgICAgICAgICAgLnJhbmdlKFswLCAxXSk7XG4gICAgICAgIHZhciBlbmRDb2xvciA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgc3RvcHNcbiAgICAgICAgdmFyIHN0YXJ0VmFsID0gdmFsdWVTY2FsZShzdGFydCk7XG4gICAgICAgIHZhciBzdGFydENvbG9yID0gdGhpcy5nZXRDb2xvcihzdGFydCk7XG4gICAgICAgIHZhciBlbmRWYWwgPSB2YWx1ZVNjYWxlKHZhbHVlKTtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudFZhbCA9IHN0YXJ0VmFsO1xuICAgICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcjogc3RhcnRDb2xvcixcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnRWYWwsXG4gICAgICAgICAgICBvcmlnaW5hbE9mZnNldDogc3RhcnRWYWwsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoY3VycmVudFZhbCA8IGVuZFZhbCAmJiBpIDwgdGhpcy5jb2xvckRvbWFpbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JEb21haW5baV07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gY29sb3JWYWx1ZVNjYWxlKGNvbG9yKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gc3RhcnRWYWwpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0LnRvRml4ZWQoNCkgPj0gKGVuZFZhbCAtIGNvbG9yVmFsdWVTY2FsZS5iYW5kd2lkdGgoKSkudG9GaXhlZCg0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudFZhbCA9IG9mZnNldDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0ub2Zmc2V0IDwgMTAwKSB7XG4gICAgICAgICAgICBzdG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBlbmRWYWwsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFZhbCA9PT0gc3RhcnRWYWwpIHtcbiAgICAgICAgICAgIHN0b3BzWzBdLm9mZnNldCA9IDA7XG4gICAgICAgICAgICBzdG9wc1sxXS5vZmZzZXQgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIG9mZnNldHMgaW50byBwZXJjZW50YWdlc1xuICAgICAgICAgICAgaWYgKHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLm9mZnNldCAhPT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdG9wc18xID0gc3RvcHM7IF9pIDwgc3RvcHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBzdG9wc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgcy5vZmZzZXQgPSAoKHMub2Zmc2V0IC0gc3RhcnRWYWwpIC8gKGVuZFZhbCAtIHN0YXJ0VmFsKSkgKiAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9wcztcbiAgICB9O1xuICAgIHJldHVybiBDb2xvckhlbHBlcjtcbn0oKSk7XG5cbnZhciBDaXJjbGVTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2lyY2xlU2VyaWVzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhbmRhcmQnO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJhclZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmdyYWRpZW50RmlsbCA9IFwidXJsKCNcIiArIHRoaXMuZ3JhZGllbnRJZCArIFwiKVwiO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaXJjbGUgPSB0aGlzLmdldEFjdGl2ZUNpcmNsZSgpO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBY3RpdmVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbmRleEFjdGl2ZURhdGFQb2ludCA9IHRoaXMuZGF0YS5zZXJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgJiYgX3RoaXMudmlzaWJsZVZhbHVlICYmIGxhYmVsLnRvU3RyaW5nKCkgPT09IF90aGlzLnZpc2libGVWYWx1ZS50b1N0cmluZygpICYmIGQudmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbmRleEFjdGl2ZURhdGFQb2ludCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE5vIHZhbGlkIHBvaW50IGlzICdhY3RpdmUvaG92ZXJlZCBvdmVyJyBhdCB0aGlzIG1vbWVudC5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YVBvaW50VG9DaXJjbGUodGhpcy5kYXRhLnNlcmllc1tpbmRleEFjdGl2ZURhdGFQb2ludF0sIGluZGV4QWN0aXZlRGF0YVBvaW50KTtcbiAgICB9O1xuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubWFwRGF0YVBvaW50VG9DaXJjbGUgPSBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xuICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XG4gICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XG4gICAgICAgIHZhciBjeDtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgY3ggPSB0aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjeSA9IHRoaXMueVNjYWxlKHRoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJyA/IHZhbHVlIDogZC5kMSk7XG4gICAgICAgIHZhciByYWRpdXMgPSA1O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy55U2NhbGUucmFuZ2UoKVswXSAtIGN5O1xuICAgICAgICB2YXIgb3BhY2l0eSA9IDE7XG4gICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IoZC5kMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHNlcmllc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZCwge1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNOYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbmFtZTogbGFiZWxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbXCJjaXJjbGUtZGF0YS1cIiArIGldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB0b29sdGlwTGFiZWw6IHRvb2x0aXBMYWJlbCxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBzZXJpZXNOYW1lLFxuICAgICAgICAgICAgZ3JhZGllbnRTdG9wczogdGhpcy5nZXRHcmFkaWVudFN0b3BzKGNvbG9yKSxcbiAgICAgICAgICAgIG1pbjogZC5taW4sXG4gICAgICAgICAgICBtYXg6IGQubWF4XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBfYS50b29sdGlwTGFiZWwsIHZhbHVlID0gX2EudmFsdWUsIHNlcmllc05hbWUgPSBfYS5zZXJpZXNOYW1lLCBtaW4kJDEgPSBfYS5taW4sIG1heCQkMSA9IF9hLm1heDtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgZXNjYXBlTGFiZWwoc2VyaWVzTmFtZSkgKyBcIiBcXHUyMDIyIFwiICsgZXNjYXBlTGFiZWwodG9vbHRpcExhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgdGhpcy5nZXRUb29sdGlwTWluTWF4VGV4dChtaW4kJDEsIG1heCQkMSkgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBNaW5NYXhUZXh0ID0gZnVuY3Rpb24gKG1pbiQkMSwgbWF4JCQxKSB7XG4gICAgICAgIGlmIChtaW4kJDEgIT09IHVuZGVmaW5lZCB8fCBtYXgkJDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcgKCc7XG4gICAgICAgICAgICBpZiAobWluJCQxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4JCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbWluJCQxLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heCQkMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIC0gJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXgkJDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAn4omkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXgkJDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtYXgkJDEudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50U3RvcHMgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5kYXRhLm5hbWUgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmFyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpcmNsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2I7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBDb2xvckhlbHBlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDb2xvckhlbHBlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgKm5nSWY9XFxcImNpcmNsZVxcXCI+XFxuICAgICAgPGRlZnM+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zdmctbGluZWFyLWdyYWRpZW50XFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RvcHNdPVxcXCJjaXJjbGUuZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgKm5nSWY9XFxcImJhclZpc2libGUgJiYgdHlwZSA9PT0gJ3N0YW5kYXJkJ1xcXCJcXG4gICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJjaXJjbGUuY3ggLSBjaXJjbGUucmFkaXVzXFxcIlxcbiAgICAgICAgW2F0dHIueV09XFxcImNpcmNsZS5jeVxcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwiY2lyY2xlLnJhZGl1cyAqIDJcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJjaXJjbGUuaGVpZ2h0XFxcIlxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdyYWRpZW50RmlsbFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJ0b29sdGlwLWJhclxcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGVcXG4gICAgICAgIGNsYXNzPVxcXCJjaXJjbGVcXFwiXFxuICAgICAgICBbY3hdPVxcXCJjaXJjbGUuY3hcXFwiXFxuICAgICAgICBbY3ldPVxcXCJjaXJjbGUuY3lcXFwiXFxuICAgICAgICBbcl09XFxcImNpcmNsZS5yYWRpdXNcXFwiXFxuICAgICAgICBbZmlsbF09XFxcImNpcmNsZS5jb2xvclxcXCJcXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJpc0FjdGl2ZSh7IG5hbWU6IGNpcmNsZS5zZXJpZXNOYW1lIH0pXFxcIlxcbiAgICAgICAgW3BvaW50ZXJFdmVudHNdPVxcXCJjaXJjbGUudmFsdWUgPT09IDAgPyAnbm9uZScgOiAnYWxsJ1xcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiY2lyY2xlLnZhbHVlXFxcIlxcbiAgICAgICAgW2NsYXNzTmFtZXNdPVxcXCJjaXJjbGUuY2xhc3NOYW1lc1xcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKGNpcmNsZS5kYXRhKVxcXCJcXG4gICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlQ2lyY2xlKClcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGVDaXJjbGUoKVxcXCJcXG4gICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjaXJjbGUpXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImNpcmNsZS5kYXRhXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQ2lyY2xlU2VyaWVzQ29tcG9uZW50O1xufSgpKTtcblxudmFyIENpcmNsZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaXJjbGVDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHRoaXMuZGF0YSk7XG4gICAgfTtcbiAgICBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gQXJyYXkuaXNBcnJheSh0aGlzLmNsYXNzTmFtZXMpID9cbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyArPSAnY2lyY2xlJztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3hcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImN5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImNsYXNzTmFtZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImNpcmNsZU9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcInBvaW50ZXJFdmVudHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdjbGljaycpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlRW50ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xuICAgIENpcmNsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtY2lyY2xlXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpjaXJjbGVcXG4gICAgICBbYXR0ci5jeF09XFxcImN4XFxcIlxcbiAgICAgIFthdHRyLmN5XT1cXFwiY3lcXFwiXFxuICAgICAgW2F0dHIucl09XFxcInJcXFwiXFxuICAgICAgW2F0dHIuZmlsbF09XFxcImZpbGxcXFwiXFxuICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwic3Ryb2tlXFxcIlxcbiAgICAgIFthdHRyLm9wYWNpdHldPVxcXCJjaXJjbGVPcGFjaXR5XFxcIlxcbiAgICAgIFthdHRyLmNsYXNzXT1cXFwiY2xhc3NOYW1lc1xcXCJcXG4gICAgICBbYXR0ci5wb2ludGVyLWV2ZW50c109XFxcInBvaW50ZXJFdmVudHNcXFwiXFxuICAgIC8+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQ2lyY2xlQ29tcG9uZW50O1xufSgpKTtcblxudmFyIEdyaWRQYW5lbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmlkUGFuZWxDb21wb25lbnQoKSB7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwicGF0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwieVwiLCB2b2lkIDApO1xuICAgIEdyaWRQYW5lbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtZ3JpZC1wYW5lbF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6cmVjdFxcbiAgICAgIFthdHRyLmhlaWdodF09XFxcImhlaWdodFxcXCJcXG4gICAgICBbYXR0ci53aWR0aF09XFxcIndpZHRoXFxcIlxcbiAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIlxcbiAgICAgIFthdHRyLnldPVxcXCJ5XFxcIlxcbiAgICAgIHN0cm9rZT1cXFwibm9uZVxcXCJcXG4gICAgICBjbGFzcz1cXFwiZ3JpZHBhbmVsXFxcIlxcbiAgICAvPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEdyaWRQYW5lbENvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50KCkge1xuICAgIH1cbiAgICBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdyaWRQYW5lbHMgPSB0aGlzLmdldEdyaWRQYW5lbHMoKTtcbiAgICB9O1xuICAgIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JpZFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnb2RkJztcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcmllbnQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfdGhpcy54U2NhbGUoZC5uYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25JbmRleCA9IE51bWJlci5wYXJzZUludCgocG9zaXRpb24gLyBfdGhpcy54U2NhbGUuc3RlcCgpKS50b1N0cmluZygpLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5kZXggJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdldmVuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3RoaXMueFNjYWxlLmJhbmR3aWR0aCgpICogX3RoaXMueFNjYWxlLnBhZGRpbmdJbm5lcigpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gX3RoaXMueFNjYWxlLmJhbmR3aWR0aCgpICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IF90aGlzLmRpbXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHggPSBfdGhpcy54U2NhbGUoZC5uYW1lKSAtIG9mZnNldCAvIDI7XG4gICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzLnlTY2FsZShkLm5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbkluZGV4ID0gTnVtYmVyLnBhcnNlSW50KChwb3NpdGlvbiAvIF90aGlzLnlTY2FsZS5zdGVwKCkpLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JbmRleCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gJ2V2ZW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfdGhpcy55U2NhbGUuYmFuZHdpZHRoKCkgKiBfdGhpcy55U2NhbGUucGFkZGluZ0lubmVyKCk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBfdGhpcy5kaW1zLndpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICB5ID0gX3RoaXMueVNjYWxlKGQubmFtZSkgLSBvZmZzZXQgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWUsXG4gICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xuICAgIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtZ3JpZC1wYW5lbC1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1ncmlkLXBhbmVsICpuZ0Zvcj1cXFwibGV0IGdyaWRQYW5lbCBvZiBncmlkUGFuZWxzXFxcIlxcbiAgICAgIFtoZWlnaHRdPVxcXCJncmlkUGFuZWwuaGVpZ2h0XFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImdyaWRQYW5lbC53aWR0aFxcXCJcXG4gICAgICBbeF09XFxcImdyaWRQYW5lbC54XFxcIlxcbiAgICAgIFt5XT1cXFwiZ3JpZFBhbmVsLnlcXFwiXFxuICAgICAgW2NsYXNzLmdyaWQtcGFuZWxdPVxcXCJ0cnVlXFxcIlxcbiAgICAgIFtjbGFzcy5vZGRdPVxcXCJncmlkUGFuZWwuY2xhc3MgPT09ICdvZGQnXFxcIlxcbiAgICAgIFtjbGFzcy5ldmVuXT1cXFwiZ3JpZFBhbmVsLmNsYXNzID09PSAnZXZlbidcXFwiPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCk7XG4gICAgcmV0dXJuIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgfVxuICAgIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMueDEgPSAnMCUnO1xuICAgICAgICB0aGlzLngyID0gJzAlJztcbiAgICAgICAgdGhpcy55MSA9ICcwJSc7XG4gICAgICAgIHRoaXMueTIgPSAnMCUnO1xuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLngyID0gJzEwMCUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMueTEgPSAnMTAwJSc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgdm9pZCAwKTtcbiAgICBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6bGluZWFyR3JhZGllbnRcXG4gICAgICBbaWRdPVxcXCJuYW1lXFxcIlxcbiAgICAgIFthdHRyLngxXT1cXFwieDFcXFwiXFxuICAgICAgW2F0dHIueTFdPVxcXCJ5MVxcXCJcXG4gICAgICBbYXR0ci54Ml09XFxcIngyXFxcIlxcbiAgICAgIFthdHRyLnkyXT1cXFwieTJcXFwiPlxcbiAgICAgIDxzdmc6c3RvcCAqbmdGb3I9XFxcImxldCBzdG9wIG9mIHN0b3BzXFxcIlxcbiAgICAgICAgW2F0dHIub2Zmc2V0XT1cXFwic3RvcC5vZmZzZXQgKyAnJSdcXFwiXFxuICAgICAgICBbc3R5bGUuc3RvcC1jb2xvcl09XFxcInN0b3AuY29sb3JcXFwiXFxuICAgICAgICBbc3R5bGUuc3RvcC1vcGFjaXR5XT1cXFwic3RvcC5vcGFjaXR5XFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmxpbmVhckdyYWRpZW50PlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50KTtcbiAgICByZXR1cm4gU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuZW5kT3BhY2l0eSA9IDE7XG4gICAgICAgIHRoaXMuY3ggPSAwO1xuICAgICAgICB0aGlzLmN5ID0gMDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdG9wc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHNJbnB1dCB8fCB0aGlzLnN0b3BzRGVmYXVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcHNJbnB1dCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnIgPSAnMzAlJztcbiAgICAgICAgaWYgKCgnY29sb3InIGluIGNoYW5nZXMpIHx8XG4gICAgICAgICAgICAoJ3N0YXJ0T3BhY2l0eScgaW4gY2hhbmdlcykgfHxcbiAgICAgICAgICAgICgnZW5kT3BhY2l0eScgaW4gY2hhbmdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcHNEZWZhdWx0ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGFydE9wYWNpdHlcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogMTAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5lbmRPcGFjaXR5XG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0T3BhY2l0eVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRPcGFjaXR5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImN4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImN5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdG9wc1wiLCBudWxsKTtcbiAgICBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc3ZnLXJhZGlhbC1ncmFkaWVudF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6cmFkaWFsR3JhZGllbnRcXG4gICAgICBbaWRdPVxcXCJuYW1lXFxcIlxcbiAgICAgIFthdHRyLmN4XT1cXFwiY3hcXFwiXFxuICAgICAgW2F0dHIuY3ldPVxcXCJjeVxcXCJcXG4gICAgICBbYXR0ci5yXT1cXFwiclxcXCJcXG4gICAgICBncmFkaWVudFVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCI+XFxuICAgICAgPHN2ZzpzdG9wICpuZ0Zvcj1cXFwibGV0IHN0b3Agb2Ygc3RvcHNcXFwiXFxuICAgICAgICBbYXR0ci5vZmZzZXRdPVxcXCJzdG9wLm9mZnNldCArICclJ1xcXCJcXG4gICAgICAgIFtzdHlsZS5zdG9wLWNvbG9yXT1cXFwic3RvcC5jb2xvclxcXCJcXG4gICAgICAgIFtzdHlsZS5zdG9wLW9wYWNpdHldPVxcXCJzdG9wLm9wYWNpdHlcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6cmFkaWFsR3JhZGllbnQ+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQpO1xuICAgIHJldHVybiBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBUaW1lbGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lbGluZShlbGVtZW50LCBjZCkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gNTA7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRG9tYWluQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgVGltZWxpbmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEJydXNoKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZWxpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaW1zID0gdGhpcy5nZXREaW1zKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5kaW1zLmhlaWdodDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSB0aGlzLnZpZXdbMV0gLSB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgICAgaWYgKHRoaXMuYnJ1c2gpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQnJ1c2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKDAgLCBcIiArIG9mZnNldFkgKyBcIilcIjtcbiAgICAgICAgdGhpcy5maWx0ZXJJZCA9ICdmaWx0ZXInICsgaWQoKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IFwidXJsKCNcIiArIHRoaXMuZmlsdGVySWQgKyBcIilcIjtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9tYWluID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBUaW1lbGluZS5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NhbGU7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlVGltZSgpXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxuICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy54RG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMueERvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KClcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXG4gICAgICAgICAgICAgICAgLnBhZGRpbmcoMC4xKVxuICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy54RG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBUaW1lbGluZS5wcm90b3R5cGUuYWRkQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmJydXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlld1swXTtcbiAgICAgICAgdGhpcy5icnVzaCA9IGJydXNoWCgpXG4gICAgICAgICAgICAuZXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pXG4gICAgICAgICAgICAub24oJ2JydXNoIGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb24gfHwgX3RoaXMueFNjYWxlLnJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgbmV3RG9tYWluID0gc2VsZWN0aW9uLm1hcChfdGhpcy54U2NhbGUuaW52ZXJ0KTtcbiAgICAgICAgICAgIF90aGlzLm9uRG9tYWluQ2hhbmdlLmVtaXQobmV3RG9tYWluKTtcbiAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0KHRoaXMuZWxlbWVudClcbiAgICAgICAgICAgIC5zZWxlY3QoJy5icnVzaCcpXG4gICAgICAgICAgICAuY2FsbCh0aGlzLmJydXNoKTtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS51cGRhdGVCcnVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJydXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlld1swXTtcbiAgICAgICAgdGhpcy5icnVzaC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSk7XG4gICAgICAgIHNlbGVjdCh0aGlzLmVsZW1lbnQpXG4gICAgICAgICAgICAuc2VsZWN0KCcuYnJ1c2gnKVxuICAgICAgICAgICAgLmNhbGwodGhpcy5icnVzaCk7XG4gICAgICAgIHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLnNlbGVjdGlvbicpXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCB1bmRlZmluZWQpXG4gICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5nZXREaW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnZpZXdbMF07XG4gICAgICAgIHZhciBkaW1zID0ge1xuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGltcztcbiAgICB9O1xuICAgIHZhciBfYSwgX2I7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInZpZXdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwic3RhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJzY2hlbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwiY3VzdG9tQ29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJtaW5pQ2hhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwiYXV0b1NjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwib25Eb21haW5DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBUaW1lbGluZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtdGltZWxpbmVdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBjbGFzcz1cXFwidGltZWxpbmVcXFwiXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICA8c3ZnOmZpbHRlciBbYXR0ci5pZF09XFxcImZpbHRlcklkXFxcIj5cXG4gICAgICAgIDxzdmc6ZmVDb2xvck1hdHJpeCBpbj1cXFwiU291cmNlR3JhcGhpY1xcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJtYXRyaXhcXFwiXFxuICAgICAgICAgICAgdmFsdWVzPVxcXCIwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwIDAgMCAxIDBcXFwiIC8+XFxuICAgICAgPC9zdmc6ZmlsdGVyPlxcbiAgICAgIDxzdmc6ZyBjbGFzcz1cXFwiZW1iZWRkZWQtY2hhcnRcXFwiPlxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgICAgPHN2ZzpyZWN0IHg9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcInZpZXdbMF1cXFwiXFxuICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImJydXNoLWJhY2tncm91bmRcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmcgY2xhc3M9XFxcImJydXNoXFxcIj48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi50aW1lbGluZSAuYnJ1c2gtYmFja2dyb3VuZHtmaWxsOnJnYmEoMCwwLDAsLjA1KX0udGltZWxpbmUgLmJydXNoIC5zZWxlY3Rpb257ZmlsbDpyZ2JhKDAsMCwwLC4xKTtzdHJva2Utd2lkdGg6MXB4O3N0cm9rZTojODg4fS50aW1lbGluZSAuYnJ1c2ggLmhhbmRsZXtmaWxsLW9wYWNpdHk6MH0udGltZWxpbmUgLmVtYmVkZGVkLWNoYXJ0e29wYWNpdHk6LjZ9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QsIHR5cGVvZiAoX2IgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdF0pXG4gICAgXSwgVGltZWxpbmUpO1xuICAgIHJldHVybiBUaW1lbGluZTtcbn0oKSk7XG5cbnZhciBBcmVhQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFyZWFDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0T3BhY2l0eSA9IDAuNTtcbiAgICAgICAgdGhpcy5lbmRPcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnQgfHwgdGhpcy5zdG9wcykge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5nZXRHcmFkaWVudCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVQYXRoRWwoKTtcbiAgICB9O1xuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSB0aGlzLnN0YXJ0aW5nUGF0aDtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpLCAxMDApO1xuICAgIH07XG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlUGF0aEVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmFyZWEnKTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgbm9kZS50cmFuc2l0aW9uKCkuZHVyYXRpb24oNzUwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgdGhpcy5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXR0cignZCcsIHRoaXMucGF0aCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuZW5kT3BhY2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRpbmdQYXRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydE9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRPcGFjaXR5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInN0b3BzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgQXJlYUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXJlYV0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZGVmcyAqbmdJZj1cXFwiZ3JhZGllbnRcXFwiPlxcbiAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnRcXG4gICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCJcXG4gICAgICAgIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6ZGVmcz5cXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgY2xhc3M9XFxcImFyZWFcXFwiXFxuICAgICAgW2F0dHIuZF09XFxcImFyZWFQYXRoXFxcIlxcbiAgICAgIFthdHRyLmZpbGxdPVxcXCJncmFkaWVudCA/IGdyYWRpZW50RmlsbCA6IGZpbGxcXFwiXFxuICAgICAgW3N0eWxlLm9wYWNpdHldPVxcXCJvcGFjaXR5XFxcIlxcbiAgICAvPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBBcmVhQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQXJlYUNvbXBvbmVudDtcbn0oKSk7XG5cbi8vIElmIHdlIGRvbid0IGNoZWNrIHdoZXRoZXIgJ3dpbmRvdycgYW5kICdnbG9iYWwnIHZhcmlhYmxlcyBhcmUgZGVmaW5lZCxcbi8vIGNvZGUgd2lsbCBmYWlsIGluIGJyb3dzZXIvbm9kZSB3aXRoICd2YXJpYWJsZSBpcyB1bmRlZmluZWQnIGVycm9yLlxudmFyIHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByb290ID0gd2luZG93O1xufVxuZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByb290ID0gZ2xvYmFsO1xufVxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbnZhciBNb3VzZUV2ZW50ID0gcm9vdC5Nb3VzZUV2ZW50O1xuZnVuY3Rpb24gY3JlYXRlTW91c2VFdmVudChuYW1lLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG4gICAgaWYgKGJ1YmJsZXMgPT09IHZvaWQgMCkgeyBidWJibGVzID0gZmFsc2U7IH1cbiAgICBpZiAoY2FuY2VsYWJsZSA9PT0gdm9pZCAwKSB7IGNhbmNlbGFibGUgPSB0cnVlOyB9XG4gICAgLy8gQ2FsbGluZyBuZXcgb2YgYW4gZXZlbnQgZG9lcyBub3Qgd29yayBjb3JyZWN0bHkgb24gSUUuIFRoZSBmb2xsb3dpbmcgaXMgYSB0ZXN0ZWQgd29ya2Fyb3VuZFxuICAgIC8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzE3Njk4My9kaXNwYXRjaGV2ZW50LW5vdC13b3JraW5nLWluLWllMTFcbiAgICBpZiAodHlwZW9mIChNb3VzZUV2ZW50KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBTYW5lIGJyb3dzZXJzXG4gICAgICAgIHJldHVybiBuZXcgTW91c2VFdmVudChuYW1lLCB7IGJ1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IGNhbmNlbGFibGUgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJRVxuICAgICAgICB2YXIgZXZlbnQkJDEgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgICAgICBldmVudCQkMS5pbml0RXZlbnQobmFtZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG4gICAgICAgIHJldHVybiBldmVudCQkMTtcbiAgICB9XG59XG5cbnZhciBUb29sdGlwQXJlYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwQXJlYSgpIHtcbiAgICAgICAgdGhpcy5hbmNob3JPcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5hbmNob3JQb3MgPSAtMTtcbiAgICAgICAgdGhpcy5hbmNob3JWYWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaG93UGVyY2VudGFnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHhWYWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ3JvdXAuc2VyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZS50b1N0cmluZygpID09PSB4VmFsLnRvU3RyaW5nKCk7IH0pO1xuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGdyb3VwLm5hbWU7XG4gICAgICAgICAgICBpZiAoZ3JvdXBOYW1lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGdyb3VwTmFtZSA9IGdyb3VwTmFtZS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IChpdGVtLmQxIC0gaXRlbS5kMCkudG9GaXhlZCgyKSArICclJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5kMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGl0ZW0uZDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcih2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IoZ3JvdXAubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBncm91cE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1pbjogaXRlbS5taW4sXG4gICAgICAgICAgICAgICAgICAgIG1heDogaXRlbS5tYXgsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5tb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcbiAgICAgICAgdmFyIHhQb3MgPSBldmVudCQkMS5wYWdlWCAtIGV2ZW50JCQxLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gdGhpcy5maW5kQ2xvc2VzdFBvaW50SW5kZXgoeFBvcyk7XG4gICAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSB0aGlzLnhTZXRbY2xvc2VzdEluZGV4XTtcbiAgICAgICAgdGhpcy5hbmNob3JQb3MgPSB0aGlzLnhTY2FsZShjbG9zZXN0UG9pbnQpO1xuICAgICAgICB0aGlzLmFuY2hvclBvcyA9IE1hdGgubWF4KDAsIHRoaXMuYW5jaG9yUG9zKTtcbiAgICAgICAgdGhpcy5hbmNob3JQb3MgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuYW5jaG9yUG9zKTtcbiAgICAgICAgdGhpcy5hbmNob3JWYWx1ZXMgPSB0aGlzLmdldFZhbHVlcyhjbG9zZXN0UG9pbnQpO1xuICAgICAgICBpZiAodGhpcy5hbmNob3JQb3MgIT09IHRoaXMubGFzdEFuY2hvclBvcykge1xuICAgICAgICAgICAgdmFyIGV2ID0gY3JlYXRlTW91c2VFdmVudCgnbW91c2VsZWF2ZScpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwQW5jaG9yLm5hdGl2ZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgICAgICB0aGlzLmFuY2hvck9wYWNpdHkgPSAwLjc7XG4gICAgICAgICAgICB0aGlzLmhvdmVyLmVtaXQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9zZXN0UG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0QW5jaG9yUG9zID0gdGhpcy5hbmNob3JQb3M7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5maW5kQ2xvc2VzdFBvaW50SW5kZXggPSBmdW5jdGlvbiAoeFBvcykge1xuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLnhTZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pbkRpZmYgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gKChtaW5JbmRleCArIG1heEluZGV4KSAvIDIpIHwgMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IHRoaXMueFNjYWxlKHRoaXMueFNldFtjdXJyZW50SW5kZXhdKTtcbiAgICAgICAgICAgIHZhciBjdXJEaWZmID0gTWF0aC5hYnMoY3VycmVudEVsZW1lbnQgLSB4UG9zKTtcbiAgICAgICAgICAgIGlmIChjdXJEaWZmIDwgbWluRGlmZikge1xuICAgICAgICAgICAgICAgIG1pbkRpZmYgPSBjdXJEaWZmO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RWxlbWVudCA8IHhQb3MpIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RWxlbWVudCA+IHhQb3MpIHtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5EaWZmID0gMDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICB9O1xuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50JCQxID0gY3JlYXRlTW91c2VFdmVudCgnbW91c2VlbnRlcicpO1xuICAgICAgICB0aGlzLnRvb2x0aXBBbmNob3IubmF0aXZlRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50JCQxKTtcbiAgICB9O1xuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50JCQxID0gY3JlYXRlTW91c2VFdmVudCgnbW91c2VsZWF2ZScpO1xuICAgICAgICB0aGlzLnRvb2x0aXBBbmNob3IubmF0aXZlRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50JCQxKTtcbiAgICAgICAgdGhpcy5hbmNob3JPcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0QW5jaG9yUG9zID0gLTE7XG4gICAgfTtcbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuZ2V0VG9vbFRpcFRleHQgPSBmdW5jdGlvbiAodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW0uc2VyaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0b29sdGlwSXRlbS5zZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJz8/Pyc7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICc6ICc7XG4gICAgICAgIGlmICh0b29sdGlwSXRlbS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdG9vbHRpcEl0ZW0udmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbHRpcEl0ZW0ubWluICE9PSB1bmRlZmluZWQgfHwgdG9vbHRpcEl0ZW0ubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnICgnO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLm1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAn4omlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRvb2x0aXBJdGVtLm1pbi50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAtICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9vbHRpcEl0ZW0ubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ+KJpCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbHRpcEl0ZW0ubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdG9vbHRpcEl0ZW0ubWF4LnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJyknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcImRpbXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwieFNldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInJlc3VsdHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJzaG93UGVyY2VudGFnZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwiaG92ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKCd0b29sdGlwQW5jaG9yJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ0b29sdGlwQW5jaG9yXCIsIHZvaWQgMCk7XG4gICAgVG9vbHRpcEFyZWEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXRvb2x0aXAtYXJlYV0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Zz5cXG4gICAgICA8c3ZnOnJlY3RcXG4gICAgICAgIGNsYXNzPVxcXCJ0b29sdGlwLWFyZWFcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwiMFxcXCJcXG4gICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OiAwOyBjdXJzb3I6ICdhdXRvJztcXFwiXFxuICAgICAgICAobW91c2Vtb3ZlKT1cXFwibW91c2VNb3ZlKCRldmVudClcXFwiXFxuICAgICAgICAobW91c2VsZWF2ZSk9XFxcImhpZGVUb29sdGlwKClcXFwiXFxuICAgICAgLz5cXG4gICAgICA8eGh0bWw6bmctdGVtcGxhdGUgI2RlZmF1bHRUb29sdGlwVGVtcGxhdGUgbGV0LW1vZGVsPVxcXCJtb2RlbFxcXCI+XFxuICAgICAgICA8eGh0bWw6ZGl2IGNsYXNzPVxcXCJhcmVhLXRvb2x0aXAtY29udGFpbmVyXFxcIj5cXG4gICAgICAgICAgPHhodG1sOmRpdiAqbmdGb3I9XFxcImxldCB0b29sdGlwSXRlbSBvZiBtb2RlbFxcXCIgY2xhc3M9XFxcInRvb2x0aXAtaXRlbVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtaXRlbS1jb2xvclxcXCIgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVxcXCJ0b29sdGlwSXRlbS5jb2xvclxcXCI+IDwvc3Bhbj5cXG4gICAgICAgICAgICB7eyBnZXRUb29sVGlwVGV4dCh0b29sdGlwSXRlbSkgfX1cXG4gICAgICAgICAgPC94aHRtbDpkaXY+XFxuICAgICAgICA8L3hodG1sOmRpdj5cXG4gICAgICA8L3hodG1sOm5nLXRlbXBsYXRlPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgI3Rvb2x0aXBBbmNob3JcXG4gICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCJhbmNob3JPcGFjaXR5ICE9PSAwID8gJ2FjdGl2ZScgOiAnaW5hY3RpdmUnXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRvb2x0aXAtYW5jaG9yXFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcImFuY2hvclBvc1xcXCJcXG4gICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcIjFcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cXFwiYW5jaG9yT3BhY2l0eVxcXCJcXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XFxcIidub25lJ1xcXCJcXG4gICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIncmlnaHQnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBTcGFjaW5nXT1cXFwiMTVcXFwiXFxuICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdG9vbHRpcFRlbXBsYXRlIDogZGVmYXVsdFRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImFuY2hvclZhbHVlc1xcXCJcXG4gICAgICAgIFt0b29sdGlwSW1tZWRpYXRlRXhpdF09XFxcInRydWVcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2luYWN0aXZlID0+IGFjdGl2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDAuNyB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2FjdGl2ZSA9PiBpbmFjdGl2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIFRvb2x0aXBBcmVhKTtcbiAgICByZXR1cm4gVG9vbHRpcEFyZWE7XG59KCkpO1xuXG4vLyBSb2JlcnQgUGVubmVyJ3MgZWFzZU91dEV4cG9cbmZ1bmN0aW9uIGVhc2VPdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKGMgKiAoLU1hdGgucG93KDIsICgtMTAgKiB0KSAvIGQpICsgMSkgKiAxMDI0KSAvIDEwMjMgKyBiO1xufVxuLyoqXG4gKiBDb3VudHMgZnJvbSBhIG51bWJlciB0byB0aGUgZW5kIGluY3JlbWVudGFsbHkuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHthbnl9IGNvdW50RnJvbVxuICogQHBhcmFtIHthbnl9IGNvdW50VG9cbiAqIEBwYXJhbSB7YW55fSBjb3VudERlY2ltYWxzXG4gKiBAcGFyYW0ge2FueX0gY291bnREdXJhdGlvblxuICogQHBhcmFtIHthbnl9IGNhbGxiYWNrXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjb3VudChjb3VudEZyb20sIGNvdW50VG8sIGNvdW50RGVjaW1hbHMsIGNvdW50RHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0YXJ0VmFsID0gTnVtYmVyKGNvdW50RnJvbSk7XG4gICAgdmFyIGVuZFZhbCA9IE51bWJlcihjb3VudFRvKTtcbiAgICB2YXIgY291bnREb3duID0gc3RhcnRWYWwgPiBlbmRWYWw7XG4gICAgdmFyIGRlY2ltYWxzID0gTWF0aC5tYXgoMCwgY291bnREZWNpbWFscyk7XG4gICAgdmFyIGRlYyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgdmFyIGR1cmF0aW9uID0gTnVtYmVyKGNvdW50RHVyYXRpb24pICogMTAwMDtcbiAgICB2YXIgc3RhcnRUaW1lO1xuICAgIGZ1bmN0aW9uIHJ1bkNvdW50KHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgZnJhbWVWYWw7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHRpbWVzdGFtcCAtIHN0YXJ0VGltZTtcbiAgICAgICAgaWYgKGNvdW50RG93bikge1xuICAgICAgICAgICAgZnJhbWVWYWwgPSBzdGFydFZhbCAtIGVhc2VPdXRFeHBvKHByb2dyZXNzLCAwLCBzdGFydFZhbCAtIGVuZFZhbCwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJhbWVWYWwgPSBlYXNlT3V0RXhwbyhwcm9ncmVzcywgc3RhcnRWYWwsIGVuZFZhbCAtIHN0YXJ0VmFsLCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50RG93bikge1xuICAgICAgICAgICAgZnJhbWVWYWwgPSBmcmFtZVZhbCA8IGVuZFZhbCA/IGVuZFZhbCA6IGZyYW1lVmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJhbWVWYWwgPSBmcmFtZVZhbCA+IGVuZFZhbCA/IGVuZFZhbCA6IGZyYW1lVmFsO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lVmFsID0gTWF0aC5yb3VuZChmcmFtZVZhbCAqIGRlYykgLyBkZWM7XG4gICAgICAgIHZhciB0aWNrID0gcHJvZ3Jlc3MgPCBkdXJhdGlvbjtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgdmFsdWU6IGZyYW1lVmFsLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICBmaW5pc2hlZDogIXRpY2tcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHJ1bkNvdW50KHZhbCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICBzdGFydFRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHJldHVybiBydW5Db3VudCh0aW1lc3RhbXApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgZGVjaW1hbHMgcGxhY2VzXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHthbnl9IGNvdW50VG9cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGRlY2ltYWxDaGVja2VyKGNvdW50VG8pIHtcbiAgICB2YXIgZW5kVmFsID0gTnVtYmVyKGNvdW50VG8pO1xuICAgIGlmIChlbmRWYWwgJSAxICE9PSAwICYmIE1hdGguYWJzKGVuZFZhbCkgPD0gMTApIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vKipcbiAqIENvdW50IHVwIGNvbXBvbmVudFxuICpcbiAqIExvb3NlbHkgaW5zcGlyZWQgYnk6XG4gKiAgLSBodHRwczovL2dpdGh1Yi5jb20vaXp1cGV0L2FuZ3VsYXIyLWNvdW50b1xuICogIC0gaHR0cHM6Ly9pbm9yZ2FuaWsuZ2l0aHViLmlvL2NvdW50VXAuanMvXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIENvdW50VXBEaXJlY3RpdmVcbiAqL1xudmFyIENvdW50VXBEaXJlY3RpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ291bnRVcERpcmVjdGl2ZShjZCwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuY291bnREdXJhdGlvbiA9IDE7XG4gICAgICAgIHRoaXMuY291bnRQcmVmaXggPSAnJztcbiAgICAgICAgdGhpcy5jb3VudFN1ZmZpeCA9ICcnO1xuICAgICAgICB0aGlzLmNvdW50Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNvdW50RmluaXNoID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIHRoaXMuX2NvdW50RGVjaW1hbHMgPSAwO1xuICAgICAgICB0aGlzLl9jb3VudFRvID0gMDtcbiAgICAgICAgdGhpcy5fY291bnRGcm9tID0gMDtcbiAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnREZWNpbWFsc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50RGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50RGVjaW1hbHM7XG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbENoZWNrZXIodGhpcy5jb3VudFRvKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3VudERlY2ltYWxzID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRUb1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50VG87XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY291bnRUbyA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50RnJvbVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50RnJvbTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3VudEZyb20gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvblJlcSk7XG4gICAgfTtcbiAgICBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXEpO1xuICAgICAgICB2YXIgdmFsdWVGb3JtYXR0aW5nID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gXCJcIiArIF90aGlzLmNvdW50UHJlZml4ICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArIF90aGlzLmNvdW50U3VmZml4OyB9KTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgcHJvZ3Jlc3MgPSBfYS5wcm9ncmVzcywgZmluaXNoZWQgPSBfYS5maW5pc2hlZDtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWVGb3JtYXR0aW5nKHZhbHVlKTtcbiAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgaWYgKCFmaW5pc2hlZClcbiAgICAgICAgICAgICAgICBfdGhpcy5jb3VudENoYW5nZS5lbWl0KHsgdmFsdWU6IF90aGlzLnZhbHVlLCBwcm9ncmVzczogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgX3RoaXMuY291bnRGaW5pc2guZW1pdCh7IHZhbHVlOiBfdGhpcy52YWx1ZSwgcHJvZ3Jlc3M6IHByb2dyZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFuaW1hdGlvblJlcSA9IGNvdW50KHRoaXMuY291bnRGcm9tLCB0aGlzLmNvdW50VG8sIHRoaXMuY291bnREZWNpbWFscywgdGhpcy5jb3VudER1cmF0aW9uLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50RHVyYXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudFByZWZpeFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50U3VmZml4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnREZWNpbWFsc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudFRvXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50RnJvbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRGaW5pc2hcIiwgdm9pZCAwKTtcbiAgICBDb3VudFVwRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ3gtY2hhcnRzLWNvdW50LXVwXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJ7e3ZhbHVlfX1cIlxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIENoYW5nZURldGVjdG9yUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIENoYW5nZURldGVjdG9yUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3RdKVxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUpO1xuICAgIHJldHVybiBDb3VudFVwRGlyZWN0aXZlO1xufSgpKTtcblxudmFyIENPTVBPTkVOVFMgPSBbXG4gICAgQXJlYUNvbXBvbmVudCxcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQsXG4gICAgQ291bnRVcERpcmVjdGl2ZSxcbiAgICBUb29sdGlwQXJlYSxcbiAgICBDaGFydENvbXBvbmVudCxcbiAgICBMZWdlbmRDb21wb25lbnQsXG4gICAgTGVnZW5kRW50cnlDb21wb25lbnQsXG4gICAgU2NhbGVMZWdlbmRDb21wb25lbnQsXG4gICAgQ2lyY2xlQ29tcG9uZW50LFxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudCxcbiAgICBHcmlkUGFuZWxDb21wb25lbnQsXG4gICAgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LFxuICAgIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LFxuICAgIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LFxuICAgIFRpbWVsaW5lLFxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50XG5dO1xudmFyIENoYXJ0Q29tbW9uTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYXJ0Q29tbW9uTW9kdWxlKCkge1xuICAgIH1cbiAgICBDaGFydENvbW1vbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIEF4ZXNNb2R1bGUsXG4gICAgICAgICAgICAgICAgVG9vbHRpcE1vZHVsZVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogQ09NUE9ORU5UUy5zbGljZSgpLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBBeGVzTW9kdWxlLFxuICAgICAgICAgICAgICAgIFRvb2x0aXBNb2R1bGVcbiAgICAgICAgICAgIF0uY29uY2F0KENPTVBPTkVOVFMpXG4gICAgICAgIH0pXG4gICAgXSwgQ2hhcnRDb21tb25Nb2R1bGUpO1xuICAgIHJldHVybiBDaGFydENvbW1vbk1vZHVsZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKF9hKSB7XG4gICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodCwgbWFyZ2lucyA9IF9hLm1hcmdpbnMsIF9iID0gX2Euc2hvd1hBeGlzLCBzaG93WEF4aXMgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBfYS5zaG93WUF4aXMsIHNob3dZQXhpcyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLnhBeGlzSGVpZ2h0LCB4QXhpc0hlaWdodCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gX2EueUF4aXNXaWR0aCwgeUF4aXNXaWR0aCA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIF9mID0gX2Euc2hvd1hMYWJlbCwgc2hvd1hMYWJlbCA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mLCBfZyA9IF9hLnNob3dZTGFiZWwsIHNob3dZTGFiZWwgPSBfZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZywgX2ggPSBfYS5zaG93TGVnZW5kLCBzaG93TGVnZW5kID0gX2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX2gsIF9qID0gX2EubGVnZW5kVHlwZSwgbGVnZW5kVHlwZSA9IF9qID09PSB2b2lkIDAgPyAnb3JkaW5hbCcgOiBfaiwgX2sgPSBfYS5sZWdlbmRQb3NpdGlvbiwgbGVnZW5kUG9zaXRpb24gPSBfayA9PT0gdm9pZCAwID8gJ3JpZ2h0JyA6IF9rLCBfbCA9IF9hLmNvbHVtbnMsIGNvbHVtbnMgPSBfbCA9PT0gdm9pZCAwID8gMTIgOiBfbDtcbiAgICB2YXIgeE9mZnNldCA9IG1hcmdpbnNbM107XG4gICAgdmFyIGNoYXJ0V2lkdGggPSB3aWR0aDtcbiAgICB2YXIgY2hhcnRIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW5zWzBdIC0gbWFyZ2luc1syXTtcbiAgICBpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmRQb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBpZiAobGVnZW5kVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBjb2x1bW5zIC09IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5zIC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhcnRXaWR0aCA9IGNoYXJ0V2lkdGggKiBjb2x1bW5zIC8gMTI7XG4gICAgY2hhcnRXaWR0aCA9IGNoYXJ0V2lkdGggLSBtYXJnaW5zWzFdIC0gbWFyZ2luc1szXTtcbiAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgIGNoYXJ0SGVpZ2h0IC09IDU7XG4gICAgICAgIGNoYXJ0SGVpZ2h0IC09IHhBeGlzSGVpZ2h0O1xuICAgICAgICBpZiAoc2hvd1hMYWJlbCkge1xuICAgICAgICAgICAgLy8gdGV4dCBoZWlnaHQgKyBzcGFjaW5nIGJldHdlZW4gYXhpcyBsYWJlbCBhbmQgdGljayBsYWJlbHNcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAyNSArIDU7XG4gICAgICAgICAgICBjaGFydEhlaWdodCAtPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICBjaGFydFdpZHRoIC09IDU7XG4gICAgICAgIGNoYXJ0V2lkdGggLT0geUF4aXNXaWR0aDtcbiAgICAgICAgeE9mZnNldCArPSB5QXhpc1dpZHRoO1xuICAgICAgICB4T2Zmc2V0ICs9IDEwO1xuICAgICAgICBpZiAoc2hvd1lMYWJlbCkge1xuICAgICAgICAgICAgLy8gdGV4dCBoZWlnaHQgKyBzcGFjaW5nIGJldHdlZW4gYXhpcyBsYWJlbCBhbmQgdGljayBsYWJlbHNcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAyNSArIDU7XG4gICAgICAgICAgICBjaGFydFdpZHRoIC09IG9mZnNldDtcbiAgICAgICAgICAgIHhPZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYXJ0V2lkdGggPSBNYXRoLm1heCgwLCBjaGFydFdpZHRoKTtcbiAgICBjaGFydEhlaWdodCA9IE1hdGgubWF4KDAsIGNoYXJ0SGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogTWF0aC5mbG9vcihjaGFydFdpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGNoYXJ0SGVpZ2h0KSxcbiAgICAgICAgeE9mZnNldDogTWF0aC5mbG9vcih4T2Zmc2V0KVxuICAgIH07XG59XG5cbi8qKlxuICogQmFzZWQgb24gdGhlIGRhdGEsIHJldHVybiBhbiBhcnJheSB3aXRoIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQGV4cG9ydFxuICogQHJldHVybnMgYXJyYXlcbiAqIEBwYXJhbSByZXN1bHRzXG4gKi9cbmZ1bmN0aW9uIGdldFVuaXF1ZVhEb21haW5WYWx1ZXMocmVzdWx0cykge1xuICAgIHZhciB2YWx1ZVNldCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlc3VsdHNfMSA9IHJlc3VsdHM7IF9pIDwgcmVzdWx0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c18xW19pXTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IHJlc3VsdC5zZXJpZXM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgZCA9IF9iW19hXTtcbiAgICAgICAgICAgIHZhbHVlU2V0LmFkZChkLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlU2V0KTtcbn1cbi8qKlxuICogR2V0IHRoZSBzY2FsZVR5cGUgb2YgZW51bWVyYWJsZSBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAndGltZScsICdsaW5lYXInIG9yICdvcmRpbmFsJ1xuICovXG5mdW5jdGlvbiBnZXRTY2FsZVR5cGUodmFsdWVzLCBjaGVja0RhdGVUeXBlKSB7XG4gICAgaWYgKGNoZWNrRGF0ZVR5cGUgPT09IHZvaWQgMCkgeyBjaGVja0RhdGVUeXBlID0gdHJ1ZTsgfVxuICAgIGlmIChjaGVja0RhdGVUeXBlKSB7XG4gICAgICAgIHZhciBhbGxEYXRlcyA9IHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTsgfSk7XG4gICAgICAgIGlmIChhbGxEYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuICd0aW1lJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWxsTnVtYmVycyA9IHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7IH0pO1xuICAgIGlmIChhbGxOdW1iZXJzKSB7XG4gICAgICAgIHJldHVybiAnbGluZWFyJztcbiAgICB9XG4gICAgcmV0dXJuICdvcmRpbmFsJztcbn1cblxudmFyIEFyZWFDaGFydENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJlYUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZWFDaGFydENvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMuYmFzZVZhbHVlID0gJ2F1dG8nO1xuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuY3VydmUgPSBjdXJ2ZUxpbmVhcjtcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMudGltZWxpbmVIZWlnaHQgPSA1MDtcbiAgICAgICAgX3RoaXMudGltZWxpbmVQYWRkaW5nID0gMTA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRpbXMuaGVpZ2h0IC09IHRoaXMudGltZWxpbmVIZWlnaHQgKyB0aGlzLm1hcmdpblsyXSArIHRoaXMudGltZWxpbmVQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZERvbWFpbikge1xuICAgICAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbigpO1xuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIHRoaXMuZGltcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVsaW5lKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xuICAgICAgICB0aGlzLmNsaXBQYXRoSWQgPSAnY2xpcCcgKyBpZCgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuY2xpcFBhdGggPSBcInVybCgjXCIgKyB0aGlzLmNsaXBQYXRoSWQgKyBcIilcIjtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMudGltZWxpbmVYRG9tYWluLCB0aGlzLnRpbWVsaW5lV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lVHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIC10aGlzLm1hcmdpblsyXSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRVbmlxdWVYRG9tYWluVmFsdWVzKHRoaXMucmVzdWx0cyk7XG4gICAgICAgIHRoaXMuc2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluJCQxO1xuICAgICAgICB2YXIgbWF4JCQxO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJyB8fCB0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIG1pbiQkMSA9IHRoaXMueFNjYWxlTWluID8gdGhpcy54U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyB0aGlzLnhTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IFtuZXcgRGF0ZShtaW4kJDEpLCBuZXcgRGF0ZShtYXgkJDEpXTtcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYURhdGUgPSBhLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgYkRhdGUgPSBiLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoYURhdGUgPiBiRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgaWYgKGJEYXRlID4gYURhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgZG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHZhbHVlcztcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IGRvbWFpbi5zbGljZSgpO1xuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYXNlVmFsdWUgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5iYXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZU1pbiA/IHRoaXMueVNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgdmFyIG1heCQkMSA9IHRoaXMueVNjYWxlTWF4ID8gdGhpcy55U2NhbGVNYXggOiBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVMaW5lYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlUG9pbnQoKS5wYWRkaW5nKDAuMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGUucmFuZ2UoWzAsIHdpZHRoXSkuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2NhbGVUeXBlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0ZSA9IHRydWU7XG4gICAgICAgIHZhciBudW0gPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlc18xID0gdmFsdWVzOyBfaSA8IHZhbHVlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG51bSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RpbWUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0pIHtcbiAgICAgICAgICAgIHJldHVybiAnbGluZWFyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ29yZGluYWwnO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVEb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyZWREb21haW4gPSBkb21haW47XG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVIb3ZlcmVkVmVydGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IGl0ZW0udmFsdWU7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGljYWwgPSBudWxsO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXMpIHtcbiAgICAgICAgaWYgKHNlcmllcykge1xuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBzZXJpZXMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbWFpbjtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9tYWluOiBbXSxcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdGl2ZUVudHJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBlbnRyeSwgZW50cmllczogW10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzZVZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvU2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidGltZWxpbmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWluXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgnc2VyaWVzVG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZUNpcmNsZXNcIiwgbnVsbCk7XG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYXJlYS1jaGFydCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmRlZnM+XFxuICAgICAgICA8c3ZnOmNsaXBQYXRoIFthdHRyLmlkXT1cXFwiY2xpcFBhdGhJZFxcXCI+XFxuICAgICAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgICAgIFthdHRyLndpZHRoXT1cXFwiZGltcy53aWR0aCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcImRpbXMuaGVpZ2h0ICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiJ3RyYW5zbGF0ZSgtNSwgLTUpJ1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmNsaXBQYXRoPlxcbiAgICAgIDwvc3ZnOmRlZnM+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImFyZWEtY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci5jbGlwLXBhdGhdPVxcXCJjbGlwUGF0aFxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtiYXNlVmFsdWVdPVxcXCJiYXNlVmFsdWVcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcIiF0b29sdGlwRGlzYWJsZWRcXFwiIChtb3VzZWxlYXZlKT1cXFwiaGlkZUNpcmNsZXMoKVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXRvb2x0aXAtYXJlYVxcbiAgICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgICAgW3hTZXRdPVxcXCJ4U2V0XFxcIlxcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAoaG92ZXIpPVxcXCJ1cGRhdGVIb3ZlcmVkVmVydGljYWwoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAvPlxcblxcbiAgICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0c1xcXCI+XFxuICAgICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGUtc2VyaWVzXFxuICAgICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICAgIFt2aXNpYmxlVmFsdWVdPVxcXCJob3ZlcmVkVmVydGljYWxcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgc2VyaWVzKVxcXCJcXG4gICAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy10aW1lbGluZVxcbiAgICAgICAgKm5nSWY9XFxcInRpbWVsaW5lICYmIHNjYWxlVHlwZSAhPSAnb3JkaW5hbCdcXFwiXFxuICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0aW1lbGluZVRyYW5zZm9ybVxcXCJcXG4gICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgIFt2aWV3XT1cXFwiW3RpbWVsaW5lV2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwidGltZWxpbmVIZWlnaHRcXFwiXFxuICAgICAgICBbc2NoZW1lXT1cXFwic2NoZW1lXFxcIlxcbiAgICAgICAgW2N1c3RvbUNvbG9yc109XFxcImN1c3RvbUNvbG9yc1xcXCJcXG4gICAgICAgIFtsZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgKG9uRG9tYWluQ2hhbmdlKT1cXFwidXBkYXRlRG9tYWluKCRldmVudClcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1hcmVhLXNlcmllc1xcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ0aW1lbGluZVhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwidGltZWxpbmVZU2NhbGVcXFwiXFxuICAgICAgICAgICAgW2Jhc2VWYWx1ZV09XFxcImJhc2VWYWx1ZVxcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSlcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQpO1xuICAgIHJldHVybiBBcmVhQ2hhcnRDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XG4gICAgICAgIF90aGlzLmN1cnZlID0gY3VydmVMaW5lYXI7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lSGVpZ2h0ID0gNTA7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lUGFkZGluZyA9IDEwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy50aW1lbGluZUhlaWdodCArIHRoaXMubWFyZ2luWzJdICsgdGhpcy50aW1lbGluZVBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkRG9tYWluKSB7XG4gICAgICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xuICAgICAgICB0aGlzLnNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKCk7XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5kaW1zLmhlaWdodCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzXzEueFNldFtpXTtcbiAgICAgICAgICAgIHZhciBkMCA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXNfMS5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGdyb3VwLnNlcmllcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpc18xLnJlc3VsdHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIHZhciBkID0gZ3JvdXAuc2VyaWVzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBkLmQwID0gZDA7XG4gICAgICAgICAgICAgICAgICAgIGQuZDEgPSBkMCArIGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGQwICs9IGQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkMDogZDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkMTogZDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuc2VyaWVzLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZC5kMCA9IChkLmQwICogMTAwKSAvIHRvdGFsO1xuICAgICAgICAgICAgICAgICAgICBkLmQxID0gKGQuZDEgKiAxMDApIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkLmQwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZC5kMSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA9IFwidXJsKCNcIiArIHRoaXMuY2xpcFBhdGhJZCArIFwiKVwiO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMudGltZWxpbmVYRG9tYWluLCB0aGlzLnRpbWVsaW5lV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lVHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIC10aGlzLm1hcmdpblsyXSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0VW5pcXVlWERvbWFpblZhbHVlcyh0aGlzLnJlc3VsdHMpO1xuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IGdldFNjYWxlVHlwZSh2YWx1ZXMpO1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgZG9tYWluID0gW25ldyBEYXRlKG1pbiQkMSksIG5ldyBEYXRlKG1heCQkMSldO1xuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhRGF0ZSA9IGEuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciBiRGF0ZSA9IGIuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhRGF0ZSA+IGJEYXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgICAgIGRvbWFpbiA9IFttaW4kJDEsIG1heCQkMV07XG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9O1xuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMTAwXTtcbiAgICB9O1xuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFNlcmllc0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCB3aWR0aCkge1xuICAgICAgICB2YXIgc2NhbGU7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlVGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVQb2ludCgpLnBhZGRpbmcoMC4xKTtcbiAgICAgICAgfVxuICAgICAgICBzY2FsZS5yYW5nZShbMCwgd2lkdGhdKS5kb21haW4oZG9tYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcbiAgICAgICAgdGhpcy5maWx0ZXJlZERvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVIb3ZlcmVkVmVydGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IGl0ZW0udmFsdWU7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllcykge1xuICAgICAgICBpZiAoc2VyaWVzKSB7XG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IHNlcmllcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnlEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb21haW46IFtdLFxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnlEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZW50cnksIGVudHJpZXM6IFtdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidGltZWxpbmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb250ZW50Q2hpbGQoJ3Nlcmllc1Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZUNpcmNsZXNcIiwgbnVsbCk7XG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWFyZWEtY2hhcnQtbm9ybWFsaXplZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmRlZnM+XFxuICAgICAgICA8c3ZnOmNsaXBQYXRoIFthdHRyLmlkXT1cXFwiY2xpcFBhdGhJZFxcXCI+XFxuICAgICAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgICAgIFthdHRyLndpZHRoXT1cXFwiZGltcy53aWR0aCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcImRpbXMuaGVpZ2h0ICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiJ3RyYW5zbGF0ZSgtNSwgLTUpJ1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmNsaXBQYXRoPlxcbiAgICAgIDwvc3ZnOmRlZnM+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImFyZWEtY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci5jbGlwLXBhdGhdPVxcXCJjbGlwUGF0aFxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWQ9XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcIiF0b29sdGlwRGlzYWJsZWRcXFwiIChtb3VzZWxlYXZlKT1cXFwiaGlkZUNpcmNsZXMoKVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXRvb2x0aXAtYXJlYVxcbiAgICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgICAgW3hTZXRdPVxcXCJ4U2V0XFxcIlxcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW3Nob3dQZXJjZW50YWdlXT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKGhvdmVyKT1cXFwidXBkYXRlSG92ZXJlZFZlcnRpY2FsKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG5cXG4gICAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHNcXFwiPlxcbiAgICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICAgIG5neC1jaGFydHMtY2lyY2xlLXNlcmllc1xcbiAgICAgICAgICAgICAgICB0eXBlPVxcXCJzdGFja2VkXFxcIlxcbiAgICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgICBbdmlzaWJsZVZhbHVlXT1cXFwiaG92ZXJlZFZlcnRpY2FsXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIHNlcmllcylcXFwiXFxuICAgICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtdGltZWxpbmVcXG4gICAgICAgICpuZ0lmPVxcXCJ0aW1lbGluZSAmJiBzY2FsZVR5cGUgIT0gJ29yZGluYWwnXFxcIlxcbiAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGltZWxpbmVUcmFuc2Zvcm1cXFwiXFxuICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICBbdmlld109XFxcIlt0aW1lbGluZVdpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInRpbWVsaW5lSGVpZ2h0XFxcIlxcbiAgICAgICAgW3NjaGVtZV09XFxcInNjaGVtZVxcXCJcXG4gICAgICAgIFtjdXN0b21Db2xvcnNdPVxcXCJjdXN0b21Db2xvcnNcXFwiXFxuICAgICAgICBbbGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgIChvbkRvbWFpbkNoYW5nZSk9XFxcInVwZGF0ZURvbWFpbigkZXZlbnQpXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtYXJlYS1zZXJpZXNcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwidGltZWxpbmVYU2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInRpbWVsaW5lWVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBub3JtYWxpemVkPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XG4gICAgICAgIF90aGlzLmN1cnZlID0gY3VydmVMaW5lYXI7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lSGVpZ2h0ID0gNTA7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lUGFkZGluZyA9IDEwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy50aW1lbGluZUhlaWdodCArIHRoaXMubWFyZ2luWzJdICsgdGhpcy50aW1lbGluZVBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkRG9tYWluKSB7XG4gICAgICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xuICAgICAgICB0aGlzLnNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKCk7XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5kaW1zLmhlaWdodCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzXzEueFNldFtpXTtcbiAgICAgICAgICAgIHZhciBkMCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpc18xLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBkID0gZ3JvdXAuc2VyaWVzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBkLmQwID0gZDA7XG4gICAgICAgICAgICAgICAgICAgIGQuZDEgPSBkMCArIGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGQwICs9IGQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkMDogZDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkMTogZDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuc2VyaWVzLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA9IFwidXJsKCNcIiArIHRoaXMuY2xpcFBhdGhJZCArIFwiKVwiO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMudGltZWxpbmVYRG9tYWluLCB0aGlzLnRpbWVsaW5lV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lVHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIC10aGlzLm1hcmdpblsyXSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0VW5pcXVlWERvbWFpblZhbHVlcyh0aGlzLnJlc3VsdHMpO1xuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IGdldFNjYWxlVHlwZSh2YWx1ZXMpO1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE51bWJlcih2KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiQkMTtcbiAgICAgICAgdmFyIG1heCQkMTtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScgfHwgdGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBtaW4kJDEgPSB0aGlzLnhTY2FsZU1pbiA/IHRoaXMueFNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgICAgIG1heCQkMSA9IHRoaXMueFNjYWxlTWF4ID8gdGhpcy54U2NhbGVNYXggOiBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBkb21haW4gPSBbbmV3IERhdGUobWluJCQxKSwgbmV3IERhdGUobWF4JCQxKV07XG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFEYXRlID0gYS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJEYXRlID0gYi5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIGlmIChiRGF0ZSA+IGFEYXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IFttaW4kJDEsIG1heCQkMV07XG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNfMi54U2V0W2ldO1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpc18yLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBkID0gZ3JvdXAuc2VyaWVzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW4ucHVzaChzdW0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18yID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzIoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueVNjYWxlTWluID8gdGhpcy55U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyB0aGlzLnlTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRvbWFpbik7XG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XG4gICAgICAgIHZhciBzY2FsZTtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlTGluZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KCkucGFkZGluZygwLjEpO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlLnJhbmdlKFswLCB3aWR0aF0pLmRvbWFpbihkb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIGhlaWdodCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgICB0aGlzLmZpbHRlcmVkRG9tYWluID0gZG9tYWluO1xuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gaXRlbS52YWx1ZTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGljYWwgPSBudWxsO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzKSB7XG4gICAgICAgIGlmIChzZXJpZXMpIHtcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gc2VyaWVzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbWFpbjtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbWFpbjogW10sXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdGl2ZUVudHJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBlbnRyeSwgZW50cmllczogW10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgnc2VyaWVzVG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoaWRlQ2lyY2xlc1wiLCBudWxsKTtcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYXJlYS1jaGFydC1zdGFja2VkJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZGVmcz5cXG4gICAgICAgIDxzdmc6Y2xpcFBhdGggW2F0dHIuaWRdPVxcXCJjbGlwUGF0aElkXFxcIj5cXG4gICAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHQgKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCIndHJhbnNsYXRlKC01LCAtNSknXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Y2xpcFBhdGg+XFxuICAgICAgPC9zdmc6ZGVmcz5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYXJlYS1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLmNsaXAtcGF0aF09XFxcImNsaXBQYXRoXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtYXJlYS1zZXJpZXNcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgc3RhY2tlZD1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwiIXRvb2x0aXBEaXNhYmxlZFxcXCIgKG1vdXNlbGVhdmUpPVxcXCJoaWRlQ2lyY2xlcygpXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtdG9vbHRpcC1hcmVhXFxuICAgICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgICBbeFNldF09XFxcInhTZXRcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIChob3Zlcik9XFxcInVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIC8+XFxuXFxuICAgICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwic3RhY2tlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgICAgW3Zpc2libGVWYWx1ZV09XFxcImhvdmVyZWRWZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBzZXJpZXMpXFxcIlxcbiAgICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXRpbWVsaW5lXFxuICAgICAgICAqbmdJZj1cXFwidGltZWxpbmUgJiYgc2NhbGVUeXBlICE9ICdvcmRpbmFsJ1xcXCJcXG4gICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRpbWVsaW5lVHJhbnNmb3JtXFxcIlxcbiAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgW3ZpZXddPVxcXCJbdGltZWxpbmVXaWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJ0aW1lbGluZUhlaWdodFxcXCJcXG4gICAgICAgIFtzY2hlbWVdPVxcXCJzY2hlbWVcXFwiXFxuICAgICAgICBbY3VzdG9tQ29sb3JzXT1cXFwiY3VzdG9tQ29sb3JzXFxcIlxcbiAgICAgICAgW2xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAob25Eb21haW5DaGFuZ2UpPVxcXCJ1cGRhdGVEb21haW4oJGV2ZW50KVxcXCJcXG4gICAgICA+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInRpbWVsaW5lWFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ0aW1lbGluZVlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgc3RhY2tlZD1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICB9KVxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQpO1xuICAgIHJldHVybiBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIEFyZWFTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJlYVNlcmllc0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5iYXNlVmFsdWUgPSAnYXV0byc7XG4gICAgICAgIHRoaXMuc3RhY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51cGRhdGVHcmFkaWVudCgpO1xuICAgICAgICB2YXIgY3VycmVudEFyZWE7XG4gICAgICAgIHZhciBzdGFydGluZ0FyZWE7XG4gICAgICAgIHZhciB4UHJvcGVydHkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnhTY2FsZShsYWJlbCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YWNrZWQgfHwgdGhpcy5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjdXJyZW50QXJlYSA9IGFyZWEoKVxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkLmQwKTsgfSlcbiAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkLmQxKTsgfSk7XG4gICAgICAgICAgICBzdGFydGluZ0FyZWEgPSBhcmVhKClcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXG4gICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUucmFuZ2UoKVswXTsgfSlcbiAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRBcmVhID0gYXJlYSgpXG4gICAgICAgICAgICAgICAgLngoeFByb3BlcnR5KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5iYXNlVmFsdWUgPT09ICdhdXRvJyA/IF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdIDogX3RoaXMueVNjYWxlKF90aGlzLmJhc2VWYWx1ZSk7IH0pXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZC52YWx1ZSk7IH0pO1xuICAgICAgICAgICAgc3RhcnRpbmdBcmVhID0gYXJlYSgpXG4gICAgICAgICAgICAgICAgLngoeFByb3BlcnR5KVxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyBfdGhpcy55U2NhbGUucmFuZ2UoKVswXSA6IF90aGlzLnlTY2FsZShfdGhpcy5iYXNlVmFsdWUpOyB9KVxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyBfdGhpcy55U2NhbGUucmFuZ2UoKVswXSA6IF90aGlzLnlTY2FsZShfdGhpcy5iYXNlVmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJlYS5jdXJ2ZSh0aGlzLmN1cnZlKTtcbiAgICAgICAgc3RhcnRpbmdBcmVhLmN1cnZlKHRoaXMuY3VydmUpO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAuODtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuc2VyaWVzO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydExpbmVhcihkYXRhLCAnbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIGRhdGEgPSBzb3J0QnlUaW1lKGRhdGEsICduYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5RG9tYWluKGRhdGEsICduYW1lJywgJ2FzYycsIHRoaXMueFNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGggPSBjdXJyZW50QXJlYShkYXRhKTtcbiAgICAgICAgdGhpcy5zdGFydGluZ1BhdGggPSBzdGFydGluZ0FyZWEoZGF0YSk7XG4gICAgfTtcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tlZCB8fCB0aGlzLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZDB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kMDsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGQxdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZDE7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBkMXZhbHVlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGQwdmFsdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCQkMSwgbWluJCQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgkJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0luYWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzIHx8IHRoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImJhc2VWYWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFja2VkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgQXJlYVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXJlYS1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1hcmVhXFxuICAgICAgY2xhc3M9XFxcImFyZWEtc2VyaWVzXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICBbcGF0aF09XFxcInBhdGhcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJjb2xvcnMuZ2V0Q29sb3IoZGF0YS5uYW1lKVxcXCJcXG4gICAgICBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgIFtzdGFydGluZ1BhdGhdPVxcXCJzdGFydGluZ1BhdGhcXFwiXFxuICAgICAgW29wYWNpdHldPVxcXCJvcGFjaXR5XFxcIlxcbiAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50IHx8IGhhc0dyYWRpZW50XFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgLz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQXJlYVNlcmllc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBBcmVhQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJlYUNoYXJ0TW9kdWxlKCkge1xuICAgIH1cbiAgICBBcmVhQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIEFyZWFDaGFydENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQXJlYVNlcmllc0NvbXBvbmVudFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBBcmVhQ2hhcnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEFyZWFTZXJpZXNDb21wb25lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBBcmVhQ2hhcnRNb2R1bGUpO1xuICAgIHJldHVybiBBcmVhQ2hhcnRNb2R1bGU7XG59KCkpO1xuXG52YXIgQmFyQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhckNvbXBvbmVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMucm91bmRFZGdlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGVCYXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRBbmltYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnQgfHwgdGhpcy5zdG9wcykge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5nZXRHcmFkaWVudCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVQYXRoRWwoKTtcbiAgICAgICAgdGhpcy5jaGVja1RvSGlkZUJhcigpO1xuICAgIH07XG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5sb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLmdldFN0YXJ0aW5nUGF0aCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudXBkYXRlLmJpbmQodGhpcyksIDEwMCk7XG4gICAgfTtcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVBhdGhFbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5iYXInKTtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLmdldFBhdGgoKTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmF0dHIoJ2QnLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5nZXRTdGFydE9wYWNpdHkoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0U3RhcnRpbmdQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLmdldFJhZGl1cygpO1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgaWYgKHRoaXMucm91bmRFZGdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnkgKyB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgMSwgMCwgdGhpcy5lZGdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1pbih0aGlzLndpZHRoLCByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHBhdGggPSByb3VuZGVkUmVjdCh0aGlzLngsIHRoaXMueSwgMSwgdGhpcy5oZWlnaHQsIDAsIHRoaXMuZWRnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnkgKyB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgMSwgMCwgdGhpcy5lZGdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnksIDEsIHRoaXMuaGVpZ2h0LCAwLCB0aGlzLmVkZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZ2V0UmFkaXVzKCk7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICBpZiAodGhpcy5yb3VuZEVkZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgICAgIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHBhdGggPSByb3VuZGVkUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHJhZGl1cywgdGhpcy5lZGdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1pbih0aGlzLndpZHRoLCByYWRpdXMpO1xuICAgICAgICAgICAgICAgIHBhdGggPSByb3VuZGVkUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHJhZGl1cywgdGhpcy5lZGdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCByYWRpdXMsIHRoaXMuZWRnZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSAwO1xuICAgICAgICBpZiAodGhpcy5yb3VuZEVkZ2VzICYmIHRoaXMuaGVpZ2h0ID4gNSAmJiB0aGlzLndpZHRoID4gNSkge1xuICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5mbG9vcihNYXRoLm1pbig1LCB0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGggLyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhZGl1cztcbiAgICB9O1xuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0U3RhcnRPcGFjaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb3VuZEVkZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gMC4yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZWRnZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgICAgICAgICBpZiAodGhpcy5yb3VuZEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS52YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gW3RydWUsIHRydWUsIGZhbHNlLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyA9IFtmYWxzZSwgZmFsc2UsIHRydWUsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLnZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gW3RydWUsIGZhbHNlLCB0cnVlLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQodGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5jaGVja1RvSGlkZUJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oaWRlQmFyID1cbiAgICAgICAgICAgIHRoaXMubm9CYXJXaGVuWmVybyAmJlxuICAgICAgICAgICAgICAgICgodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiB0aGlzLmhlaWdodCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiB0aGlzLndpZHRoID09PSAwKSk7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uTW91c2VMZWF2ZVwiLCBudWxsKTtcbiAgICBCYXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWJhcl0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZGVmcyAqbmdJZj1cXFwiaGFzR3JhZGllbnRcXFwiPlxcbiAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnQgW29yaWVudGF0aW9uXT1cXFwib3JpZW50YXRpb25cXFwiIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCIgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCIgLz5cXG4gICAgPC9zdmc6ZGVmcz5cXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgY2xhc3M9XFxcImJhclxcXCJcXG4gICAgICBzdHJva2U9XFxcIm5vbmVcXFwiXFxuICAgICAgcm9sZT1cXFwiaW1nXFxcIlxcbiAgICAgIHRhYkluZGV4PVxcXCItMVxcXCJcXG4gICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmVcXFwiXFxuICAgICAgW2NsYXNzLmhpZGRlbl09XFxcImhpZGVCYXJcXFwiXFxuICAgICAgW2F0dHIuZF09XFxcInBhdGhcXFwiXFxuICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCJcXG4gICAgICBbYXR0ci5maWxsXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudEZpbGwgOiBmaWxsXFxcIlxcbiAgICAgIChjbGljayk9XFxcInNlbGVjdC5lbWl0KGRhdGEpXFxcIlxcbiAgICAvPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBCYXJDb21wb25lbnQpO1xuICAgIHJldHVybiBCYXJDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgQmFySG9yaXpvbnRhbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFySG9yaXpvbnRhbENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXJIb3Jpem9udGFsQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJvdW5kRWRnZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIDEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVdO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueERvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLnlEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy5oZWlnaHQgLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLmhlaWdodF0pXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueURvbWFpbik7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnhTY2FsZU1pbiA/IE1hdGgubWluLmFwcGx5KE1hdGgsIFt0aGlzLnhTY2FsZU1pbl0uY29uY2F0KHZhbHVlcykpIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICAgICAgdmFyIG1heCQkMSA9IHRoaXMueFNjYWxlTWF4ID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgW3RoaXMueFNjYWxlTWF4XS5jb25jYXQodmFsdWVzKSkgOiBNYXRoLm1heC5hcHBseShNYXRoLCBbMF0uY29uY2F0KHZhbHVlcykpO1xuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmxhYmVsOyB9KTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueERvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbWFpbjogW10sXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnhEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUub25EYXRhTGFiZWxNYXhXaWR0aENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGV2ZW50JCQxLnNpemUubmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlLCBldmVudCQkMS5zaXplLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlLCBldmVudCQkMS5zaXplLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQkJDEuaW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWF4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci1ob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3lBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtc2VyaWVzLWhvcml6b250YWxcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3Nlcmllc109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJyb3VuZEVkZ2VzXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRhdGFMYWJlbFdpZHRoQ2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSlcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFySG9yaXpvbnRhbENvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbnZhciBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhckhvcml6b250YWwyRENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLmdyb3VwUGFkZGluZyA9IDE2O1xuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJvdW5kRWRnZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuc2hvd0RhdGFMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAsIDIwICsgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSwgMTAsIDIwICsgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZV07XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcbiAgICAgICAgdGhpcy52YWx1ZXNEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG4gICAgICAgIHRoaXMuZ3JvdXBTY2FsZSA9IHRoaXMuZ2V0R3JvdXBTY2FsZSgpO1xuICAgICAgICB0aGlzLmlubmVyU2NhbGUgPSB0aGlzLmdldElubmVyU2NhbGUoKTtcbiAgICAgICAgdGhpcy52YWx1ZVNjYWxlID0gdGhpcy5nZXRWYWx1ZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMuaGVpZ2h0IC8gdGhpcy5ncm91cFBhZGRpbmcgKyAxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLmhlaWdodF0pXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXG4gICAgICAgICAgICAucGFkZGluZ091dGVyKHNwYWNpbmcgLyAyKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ3JvdXBTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmlubmVyRG9tYWluLmxlbmd0aCAvIChoZWlnaHQgLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgaGVpZ2h0XSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5pbm5lckRvbWFpbik7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZXNEb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy54U2NhbGVNYXhdLmNvbmNhdChkb21haW4pKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIFswXS5jb25jYXQoZG9tYWluKSk7XG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyB0aGlzLmdyb3VwU2NhbGUoZ3JvdXAubGFiZWwpICsgXCIpXCI7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVzRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb21haW46IFtdLFxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVzRG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9O1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcbiAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsICE9PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIShpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwUGFkZGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyUGFkZGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci1ob3Jpem9udGFsLTJkJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWdyaWQtcGFuZWwtc2VyaWVzXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwiZ3JvdXBTY2FsZVxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIG9yaWVudD1cXFwiaG9yaXpvbnRhbFxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwiZ3JvdXBTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeUF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZVxcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZ3JvdXAgb2YgcmVzdWx0czsgbGV0IGluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy1ob3Jpem9udGFsXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJpbm5lclNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc109XFxcImdyb3VwLnNlcmllc1xcXCJcXG4gICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNOYW1lXT1cXFwiZ3JvdXAubmFtZVxcXCJcXG4gICAgICAgICAgICBbcm91bmRFZGdlc109XFxcInJvdW5kRWRnZXNcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRhdGFMYWJlbFdpZHRoQ2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkKCRldmVudCwgaW5kZXgpXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEJhckhvcml6b250YWwyRENvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbnZhciBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLmJhclBhZGRpbmcgPSA4O1xuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcm91cERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMTAwXTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5ncm91cERvbWFpbi5sZW5ndGggLyAodGhpcy5kaW1zLmhlaWdodCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmRpbXMuaGVpZ2h0XSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5ncm91cERvbWFpbik7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMudmFsdWVEb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyB0aGlzLnlTY2FsZShncm91cC5uYW1lKSArIFwiKVwiO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbWFpbjogW10sXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcbiAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyUGFkZGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYmFyLWhvcml6b250YWwtbm9ybWFsaXplZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBncm91cCBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtaG9yaXpvbnRhbFxcbiAgICAgICAgICAgIHR5cGU9XFxcIm5vcm1hbGl6ZWRcXFwiXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNdPVxcXCJncm91cC5zZXJpZXNcXFwiXFxuICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbc2VyaWVzTmFtZV09XFxcImdyb3VwLm5hbWVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIDEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVdO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XG4gICAgICAgIHRoaXMuaW5uZXJEb21haW4gPSB0aGlzLmdldElubmVyRG9tYWluKCk7XG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldElubmVyRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIHZhciBzbWFsbGVzdCA9IDA7XG4gICAgICAgIHZhciBiaWdnZXN0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBzbWFsbGVzdFN1bSA9IDA7XG4gICAgICAgICAgICB2YXIgYmlnZ2VzdFN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChkLnZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdFN1bSArPSBkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmlnZ2VzdFN1bSArPSBkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IGQudmFsdWUgPCBzbWFsbGVzdCA/IGQudmFsdWUgOiBzbWFsbGVzdDtcbiAgICAgICAgICAgICAgICBiaWdnZXN0ID0gZC52YWx1ZSA+IGJpZ2dlc3QgPyBkLnZhbHVlIDogYmlnZ2VzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpbi5wdXNoKHNtYWxsZXN0U3VtKTtcbiAgICAgICAgICAgIGRvbWFpbi5wdXNoKGJpZ2dlc3RTdW0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbi5wdXNoKHNtYWxsZXN0KTtcbiAgICAgICAgZG9tYWluLnB1c2goYmlnZ2VzdCk7XG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy54U2NhbGVNYXhdLmNvbmNhdChkb21haW4pKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRvbWFpbik7XG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMuaGVpZ2h0IC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy5oZWlnaHRdKVxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLCBcIiArIHRoaXMueVNjYWxlKGdyb3VwLm5hbWUpICsgXCIpXCI7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBncm91cCkge1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gZ3JvdXAubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9tYWluOiBbXSxcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnJlc3VsdHNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcuc2VyaWVzOyB9KVxuICAgICAgICAgICAgLmZsYXQoKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IGl0ZW1zLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWF4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93RGF0YUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItaG9yaXpvbnRhbC1zdGFja2VkJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFt5QXhpc09mZnNldF09XFxcImRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBncm91cCBvZiByZXN1bHRzOyBsZXQgaW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncm91cFRyYW5zZm9ybShncm91cClcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtc2VyaWVzLWhvcml6b250YWxcXG4gICAgICAgICAgICB0eXBlPVxcXCJzdGFja2VkXFxcIlxcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNdPVxcXCJncm91cC5zZXJpZXNcXFwiXFxuICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc05hbWVdPVxcXCJncm91cC5uYW1lXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBbc2hvd0RhdGFMYWJlbF09XFxcInNob3dEYXRhTGFiZWxcXFwiXFxuICAgICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkYXRhTGFiZWxXaWR0aENoYW5nZWQpPVxcXCJvbkRhdGFMYWJlbE1heFdpZHRoQ2hhbmdlZCgkZXZlbnQsIGluZGV4KVxcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIEJhclZlcnRpY2FsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXJWZXJ0aWNhbENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbENvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yb3VuZEVkZ2VzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLmRhdGFMYWJlbE1heEhlaWdodCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmdpbiA9IFsxMCArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlLCAyMCwgMTAgKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSwgMjBdO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XG4gICAgICAgIGlmICh0aGlzLnNob3dEYXRhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgKHRoaXMubWFyZ2luWzBdICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUpICsgXCIpXCI7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLnhEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy53aWR0aCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5kb21haW4odGhpcy54RG9tYWluKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW3RoaXMuZGltcy5oZWlnaHQsIDBdKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnlEb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xuICAgICAgICB2YXIgbWluJCQxID0gdGhpcy55U2NhbGVNaW4gPyBNYXRoLm1pbi5hcHBseShNYXRoLCBbdGhpcy55U2NhbGVNaW5dLmNvbmNhdCh2YWx1ZXMpKSA6IE1hdGgubWluLmFwcGx5KE1hdGgsIFswXS5jb25jYXQodmFsdWVzKSk7XG4gICAgICAgIGlmICh0aGlzLnlBeGlzVGlja3MgJiYgIXRoaXMueUF4aXNUaWNrcy5zb21lKGlzTmFOKSkge1xuICAgICAgICAgICAgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgW21pbiQkMV0uY29uY2F0KHRoaXMueUF4aXNUaWNrcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnlTY2FsZU1heF0uY29uY2F0KHZhbHVlcykpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgWzBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICAgICAgaWYgKHRoaXMueUF4aXNUaWNrcyAmJiAhdGhpcy55QXhpc1RpY2tzLnNvbWUoaXNOYU4pKSB7XG4gICAgICAgICAgICBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBbbWF4JCQxXS5jb25jYXQodGhpcy55QXhpc1RpY2tzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueERvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb21haW46IFtdLFxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueERvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4SGVpZ2h0Q2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCQkMSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnQkJDEuc2l6ZS5uZWdhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCQkMS5pbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyUGFkZGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci12ZXJ0aWNhbCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdHJ1ZSlcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3hBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtdmVydGljYWxcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3Nlcmllc109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgIFtyb3VuZEVkZ2VzXT1cXFwicm91bmRFZGdlc1xcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRhdGFMYWJlbEhlaWdodENoYW5nZWQpPVxcXCJvbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICB9KVxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFyVmVydGljYWxDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgQmFyVmVydGljYWwyRENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFyVmVydGljYWwyRENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNjYWxlVHlwZSA9ICdvcmRpbmFsJztcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLmdyb3VwUGFkZGluZyA9IDE2O1xuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJvdW5kRWRnZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0YUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAgKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSwgMjAsIDEwICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIDIwXTtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RhdGFMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5kaW1zLmhlaWdodCAtPSB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XG4gICAgICAgIHRoaXMuaW5uZXJEb21haW4gPSB0aGlzLmdldElubmVyRG9tYWluKCk7XG4gICAgICAgIHRoaXMudmFsdWVzRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xuICAgICAgICB0aGlzLmdyb3VwU2NhbGUgPSB0aGlzLmdldEdyb3VwU2NhbGUoKTtcbiAgICAgICAgdGhpcy5pbm5lclNjYWxlID0gdGhpcy5nZXRJbm5lclNjYWxlKCk7XG4gICAgICAgIHRoaXMudmFsdWVTY2FsZSA9IHRoaXMuZ2V0VmFsdWVTY2FsZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArICh0aGlzLm1hcmdpblswXSArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlKSArIFwiKVwiO1xuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUub25EYXRhTGFiZWxNYXhIZWlnaHRDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cEluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlLCBldmVudCQkMS5zaXplLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlLCBldmVudCQkMS5zaXplLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMuaGVpZ2h0IC8gdGhpcy5ncm91cFBhZGRpbmcgKyAxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5wYWRkaW5nT3V0ZXIoc3BhY2luZyAvIDIpXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZ3JvdXBEb21haW4pO1xuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5ncm91cFNjYWxlLmJhbmR3aWR0aCgpO1xuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuaW5uZXJEb21haW4ubGVuZ3RoIC8gKHdpZHRoIC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5pbm5lckRvbWFpbik7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW3RoaXMuZGltcy5oZWlnaHQsIDBdKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlc0RvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFswXS5jb25jYXQoZG9tYWluKSk7XG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnlTY2FsZU1heF0uY29uY2F0KGRvbWFpbikpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmdyb3VwU2NhbGUoZ3JvdXAubGFiZWwpICsgXCIsIDApXCI7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVzRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9tYWluOiBbXSxcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnZhbHVlc0RvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcbiAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cFBhZGRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci12ZXJ0aWNhbC0yZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1ncmlkLXBhbmVsLXNlcmllc1xcbiAgICAgICAgICBbeFNjYWxlXT1cXFwiZ3JvdXBTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBvcmllbnQ9XFxcInZlcnRpY2FsXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwiZ3JvdXBTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeEF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtdmVydGljYWxcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZ3JvdXAgb2YgcmVzdWx0czsgbGV0IGluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJpbm5lclNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwidmFsdWVTY2FsZVxcXCJcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3Nlcmllc109XFxcImdyb3VwLnNlcmllc1xcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW3Nob3dEYXRhTGFiZWxdPVxcXCJzaG93RGF0YUxhYmVsXFxcIlxcbiAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtzZXJpZXNOYW1lXT1cXFwiZ3JvdXAubmFtZVxcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJyb3VuZEVkZ2VzXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAoZGF0YUxhYmVsSGVpZ2h0Q2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4SGVpZ2h0Q2hhbmdlZCgkZXZlbnQsIGluZGV4KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50KTtcbiAgICByZXR1cm4gQmFyVmVydGljYWwyRENvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbnZhciBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLmJhclBhZGRpbmcgPSA4O1xuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XG4gICAgICAgIHRoaXMuaW5uZXJEb21haW4gPSB0aGlzLmdldElubmVyRG9tYWluKCk7XG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhncm91cC5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gWzAsIDEwMF07XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMud2lkdGggLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5ncm91cERvbWFpbik7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFt0aGlzLmRpbXMuaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnhTY2FsZShncm91cC5uYW1lKSArIFwiLCAwKVwiO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb21haW46IFtdLFxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucmVzdWx0c1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXG4gICAgICAgICAgICAuZmxhdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItdmVydGljYWwtbm9ybWFsaXplZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBncm91cCBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtdmVydGljYWxcXG4gICAgICAgICAgICB0eXBlPVxcXCJub3JtYWxpemVkXFxcIlxcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbc2VyaWVzXT1cXFwiZ3JvdXAuc2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc05hbWVdPVxcXCJncm91cC5uYW1lXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQpO1xuICAgIHJldHVybiBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuc2hvd0RhdGFMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIDIwLCAxMCArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlLCAyMF07XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnNob3dEYXRhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xuICAgICAgICB0aGlzLmdyb3VwRG9tYWluID0gdGhpcy5nZXRHcm91cERvbWFpbigpO1xuICAgICAgICB0aGlzLmlubmVyRG9tYWluID0gdGhpcy5nZXRJbm5lckRvbWFpbigpO1xuICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyAodGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSkgKyBcIilcIjtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLmxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgdmFyIHNtYWxsZXN0ID0gMDtcbiAgICAgICAgdmFyIGJpZ2dlc3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHNtYWxsZXN0U3VtID0gMDtcbiAgICAgICAgICAgIHZhciBiaWdnZXN0U3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgaWYgKGQudmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0U3VtICs9IGQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiaWdnZXN0U3VtICs9IGQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gZC52YWx1ZSA8IHNtYWxsZXN0ID8gZC52YWx1ZSA6IHNtYWxsZXN0O1xuICAgICAgICAgICAgICAgIGJpZ2dlc3QgPSBkLnZhbHVlID4gYmlnZ2VzdCA/IGQudmFsdWUgOiBiaWdnZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluLnB1c2goc21hbGxlc3RTdW0pO1xuICAgICAgICAgICAgZG9tYWluLnB1c2goYmlnZ2VzdFN1bSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluLnB1c2goc21hbGxlc3QpO1xuICAgICAgICBkb21haW4ucHVzaChiaWdnZXN0KTtcbiAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFswXS5jb25jYXQoZG9tYWluKSk7XG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnlTY2FsZU1heF0uY29uY2F0KGRvbWFpbikpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgZG9tYWluKTtcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMud2lkdGggLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5ncm91cERvbWFpbik7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFt0aGlzLmRpbXMuaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGV2ZW50JCQxLnNpemUubmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBJbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArICh0aGlzLnhTY2FsZShncm91cC5uYW1lKSB8fCAwKSArIFwiLCAwKVwiO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb21haW46IFtdLFxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucmVzdWx0c1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXG4gICAgICAgICAgICAuZmxhdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93RGF0YUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItdmVydGljYWwtc3RhY2tlZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFt4QXhpc09mZnNldF09XFxcImRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZVxcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHJlc3VsdHM7IGxldCBpbmRleCA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtdmVydGljYWxcXG4gICAgICAgICAgICB0eXBlPVxcXCJzdGFja2VkXFxcIlxcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbc2VyaWVzXT1cXFwiZ3JvdXAuc2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3Nob3dEYXRhTGFiZWxdPVxcXCJzaG93RGF0YUxhYmVsXFxcIlxcbiAgICAgICAgICAgIFtkYXRhTGFiZWxGb3JtYXR0aW5nXT1cXFwiZGF0YUxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgICBbc2VyaWVzTmFtZV09XFxcImdyb3VwLm5hbWVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkYXRhTGFiZWxIZWlnaHRDaGFuZ2VkKT1cXFwib25EYXRhTGFiZWxNYXhIZWlnaHRDaGFuZ2VkKCRldmVudCwgaW5kZXgpXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbnZhciBEMFR5cGVzO1xuKGZ1bmN0aW9uIChEMFR5cGVzKSB7XG4gICAgRDBUeXBlc1tcInBvc2l0aXZlXCJdID0gXCJwb3NpdGl2ZVwiO1xuICAgIEQwVHlwZXNbXCJuZWdhdGl2ZVwiXSA9IFwibmVnYXRpdmVcIjtcbn0pKEQwVHlwZXMgfHwgKEQwVHlwZXMgPSB7fSkpO1xudmFyIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhbmRhcmQnO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRhTGFiZWxIZWlnaHRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gW107XG4gICAgfVxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFNldHRpbmdzKCk7XG4gICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnhTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgICAgICB2YXIgeVNjYWxlTWluID0gTWF0aC5tYXgodGhpcy55U2NhbGUuZG9tYWluKClbMF0sIDApO1xuICAgICAgICB2YXIgZDAgPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0QwVHlwZXMucG9zaXRpdmVdID0gMCxcbiAgICAgICAgICAgIF9hW0QwVHlwZXMubmVnYXRpdmVdID0gMCxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgdmFyIGQwVHlwZSA9IEQwVHlwZXMucG9zaXRpdmU7XG4gICAgICAgIHZhciB0b3RhbDtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25vcm1hbGl6ZWQnKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIHN1bSArIGQ7IH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFycyA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGQudmFsdWU7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfdGhpcy5nZXRMYWJlbChkKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsKTtcbiAgICAgICAgICAgIHZhciByb3VuZEVkZ2VzID0gX3RoaXMucm91bmRFZGdlcztcbiAgICAgICAgICAgIGQwVHlwZSA9IHZhbHVlID4gMCA/IEQwVHlwZXMucG9zaXRpdmUgOiBEMFR5cGVzLm5lZ2F0aXZlO1xuICAgICAgICAgICAgdmFyIGJhciA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgIHJvdW5kRWRnZXM6IHJvdW5kRWRnZXMsXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTGFiZWw6IGZvcm1hdHRlZExhYmVsLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgICAgICAgICAgIGJhci5oZWlnaHQgPSBNYXRoLmFicyhfdGhpcy55U2NhbGUodmFsdWUpIC0gX3RoaXMueVNjYWxlKHlTY2FsZU1pbikpO1xuICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhci55ID0gX3RoaXMueVNjYWxlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyLnkgPSBfdGhpcy55U2NhbGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnR5cGUgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IG9mZnNldDAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkMFtkMFR5cGVdICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJhci5oZWlnaHQgPSBfdGhpcy55U2NhbGUob2Zmc2V0MCkgLSBfdGhpcy55U2NhbGUob2Zmc2V0MSk7XG4gICAgICAgICAgICAgICAgYmFyLnggPSAwO1xuICAgICAgICAgICAgICAgIGJhci55ID0gX3RoaXMueVNjYWxlKG9mZnNldDEpO1xuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MSA9IG9mZnNldDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnbm9ybWFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MCA9IGQwW2QwVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBvZmZzZXQwICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG90YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDAgPSAob2Zmc2V0MCAqIDEwMCkgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IChvZmZzZXQxICogMTAwKSAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDEgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXIuaGVpZ2h0ID0gX3RoaXMueVNjYWxlKG9mZnNldDApIC0gX3RoaXMueVNjYWxlKG9mZnNldDEpO1xuICAgICAgICAgICAgICAgIGJhci54ID0gMDtcbiAgICAgICAgICAgICAgICBiYXIueSA9IF90aGlzLnlTY2FsZShvZmZzZXQxKTtcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MCA9IG9mZnNldDA7XG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDEgPSBvZmZzZXQxO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKG9mZnNldDEgLSBvZmZzZXQwKS50b0ZpeGVkKDIpICsgJyUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgICAgICAgICAgICAgICBiYXIuY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBiYXIuZ3JhZGllbnRTdG9wcyA9IF90aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihiYXIub2Zmc2V0MSk7XG4gICAgICAgICAgICAgICAgICAgIGJhci5ncmFkaWVudFN0b3BzID0gX3RoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMoYmFyLm9mZnNldDEsIGJhci5vZmZzZXQwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gZm9ybWF0dGVkTGFiZWw7XG4gICAgICAgICAgICBiYXIuYXJpYUxhYmVsID0gZm9ybWF0dGVkTGFiZWwgKyAnICcgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlcmllc05hbWUpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwTGFiZWwgPSBfdGhpcy5zZXJpZXNOYW1lICsgXCIgXFx1MjAyMiBcIiArIGZvcm1hdHRlZExhYmVsO1xuICAgICAgICAgICAgICAgIGJhci5kYXRhLnNlcmllcyA9IF90aGlzLnNlcmllc05hbWU7XG4gICAgICAgICAgICAgICAgYmFyLmFyaWFMYWJlbCA9IF90aGlzLnNlcmllc05hbWUgKyAnICcgKyBiYXIuYXJpYUxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyLnRvb2x0aXBUZXh0ID0gX3RoaXMudG9vbHRpcERpc2FibGVkXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IFwiXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBlc2NhcGVMYWJlbCh0b29sdGlwTGFiZWwpICsgXCI8L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC12YWxcXFwiPlwiICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArIFwiPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuIGJhcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YUxhYmVscygpO1xuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcbiAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gdGhpcy5zZXJpZXNOYW1lO1xuICAgICAgICAgICAgdmFyIHRvdGFsUG9zaXRpdmUgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiAoZCA+IDAgPyBzdW0gKyBkIDogc3VtKTsgfSwgMCk7XG4gICAgICAgICAgICB2YXIgdG90YWxOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIChkIDwgMCA/IHN1bSArIGQgOiBzdW0pOyB9LCAwKTtcbiAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSB0b3RhbFBvc2l0aXZlICsgdG90YWxOZWdhdGl2ZTtcbiAgICAgICAgICAgIHNlY3Rpb24ueCA9IDA7XG4gICAgICAgICAgICBzZWN0aW9uLnkgPSAwO1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24udG90YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5oZWlnaHQgPSB0aGlzLnlTY2FsZSh0b3RhbFBvc2l0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uaGVpZ2h0ID0gdGhpcy55U2NhbGUodG90YWxOZWdhdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gdGhpcy54U2NhbGUuYmFuZHdpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzLnB1c2goc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNlcmllcyA9IF90aGlzLnNlcmllc05hbWUgPyBfdGhpcy5zZXJpZXNOYW1lIDogZC5sYWJlbDtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnRvdGFsID0gZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnggPSBfdGhpcy54U2NhbGUoZC5sYWJlbCk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi55ID0gX3RoaXMueVNjYWxlKDApO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uaGVpZ2h0ID0gX3RoaXMueVNjYWxlKHNlY3Rpb24udG90YWwpIC0gX3RoaXMueVNjYWxlKDApO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24ud2lkdGggPSBfdGhpcy54U2NhbGUuYmFuZHdpZHRoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVRvb2x0aXBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b29sdGlwUGxhY2VtZW50ID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiAndG9wJztcbiAgICAgICAgdGhpcy50b29sdGlwVHlwZSA9IHRoaXMudG9vbHRpcERpc2FibGVkID8gdW5kZWZpbmVkIDogJ3Rvb2x0aXAnO1xuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lICYmIGVudHJ5LnNlcmllcyA9PT0gZC5zZXJpZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIGlmIChkYXRhSXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhSXRlbS5uYW1lO1xuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGJhcikge1xuICAgICAgICByZXR1cm4gYmFyLmxhYmVsO1xuICAgIH07XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnRyYWNrRGF0YUxhYmVsQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGJhckxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpbmRleCArICcjJyArIGJhckxhYmVsLnNlcmllcyArICcjJyArIGJhckxhYmVsLnRvdGFsO1xuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzTmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRFZGdlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxIZWlnaHRDaGFuZ2VkXCIsIHZvaWQgMCk7XG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXNlcmllcy12ZXJ0aWNhbF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtYmFyXFxuICAgICAgKm5nRm9yPVxcXCJsZXQgYmFyIG9mIGJhcnM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgIFtALmRpc2FibGVkXT1cXFwiIWFuaW1hdGlvbnNcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiYmFyLndpZHRoXFxcIlxcbiAgICAgIFtoZWlnaHRdPVxcXCJiYXIuaGVpZ2h0XFxcIlxcbiAgICAgIFt4XT1cXFwiYmFyLnhcXFwiXFxuICAgICAgW3ldPVxcXCJiYXIueVxcXCJcXG4gICAgICBbZmlsbF09XFxcImJhci5jb2xvclxcXCJcXG4gICAgICBbc3RvcHNdPVxcXCJiYXIuZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICBbZGF0YV09XFxcImJhci5kYXRhXFxcIlxcbiAgICAgIFtvcmllbnRhdGlvbl09XFxcIid2ZXJ0aWNhbCdcXFwiXFxuICAgICAgW3JvdW5kRWRnZXNdPVxcXCJiYXIucm91bmRFZGdlc1xcXCJcXG4gICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICBbYXJpYUxhYmVsXT1cXFwiYmFyLmFyaWFMYWJlbFxcXCJcXG4gICAgICBbaXNBY3RpdmVdPVxcXCJpc0FjdGl2ZShiYXIuZGF0YSlcXFwiXFxuICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCJ0b29sdGlwUGxhY2VtZW50XFxcIlxcbiAgICAgIFt0b29sdGlwVHlwZV09XFxcInRvb2x0aXBUeXBlXFxcIlxcbiAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBiYXIudG9vbHRpcFRleHRcXFwiXFxuICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJiYXIuZGF0YVxcXCJcXG4gICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICA+PC9zdmc6Zz5cXG4gICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93RGF0YUxhYmVsXFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtYmFyLWxhYmVsXFxuICAgICAgICAqbmdGb3I9XFxcImxldCBiIG9mIGJhcnNGb3JEYXRhTGFiZWxzOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0RhdGFMYWJlbEJ5XFxcIlxcbiAgICAgICAgW2JhclhdPVxcXCJiLnhcXFwiXFxuICAgICAgICBbYmFyWV09XFxcImIueVxcXCJcXG4gICAgICAgIFtiYXJXaWR0aF09XFxcImIud2lkdGhcXFwiXFxuICAgICAgICBbYmFySGVpZ2h0XT1cXFwiYi5oZWlnaHRcXFwiXFxuICAgICAgICBbdmFsdWVdPVxcXCJiLnRvdGFsXFxcIlxcbiAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICBbb3JpZW50YXRpb25dPVxcXCIndmVydGljYWwnXFxcIlxcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwiZGF0YUxhYmVsSGVpZ2h0Q2hhbmdlZC5lbWl0KHsgc2l6ZTogJGV2ZW50LCBpbmRleDogaSB9KVxcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gU2VyaWVzVmVydGljYWxDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgU2VyaWVzSG9yaXpvbnRhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpZXNIb3Jpem9udGFsKCkge1xuICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gW107XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFuZGFyZCc7XG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRhdGFMYWJlbFdpZHRoQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFNldHRpbmdzKCk7XG4gICAgICAgIHZhciBkMCA9IChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbRDBUeXBlcy5wb3NpdGl2ZV0gPSAwLFxuICAgICAgICAgICAgX2FbRDBUeXBlcy5uZWdhdGl2ZV0gPSAwLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICB2YXIgZDBUeXBlO1xuICAgICAgICBkMFR5cGUgPSBEMFR5cGVzLnBvc2l0aXZlO1xuICAgICAgICB2YXIgdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdub3JtYWxpemVkJykge1xuICAgICAgICAgICAgdG90YWwgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiBzdW0gKyBkOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeFNjYWxlTWluID0gTWF0aC5tYXgodGhpcy54U2NhbGUuZG9tYWluKClbMF0sIDApO1xuICAgICAgICB0aGlzLmJhcnMgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gX3RoaXMuZ2V0TGFiZWwoZCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XG4gICAgICAgICAgICB2YXIgcm91bmRFZGdlcyA9IF90aGlzLnJvdW5kRWRnZXM7XG4gICAgICAgICAgICBkMFR5cGUgPSB2YWx1ZSA+IDAgPyBEMFR5cGVzLnBvc2l0aXZlIDogRDBUeXBlcy5uZWdhdGl2ZTtcbiAgICAgICAgICAgIHZhciBiYXIgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICByb3VuZEVkZ2VzOiByb3VuZEVkZ2VzLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTGFiZWw6IGZvcm1hdHRlZExhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYmFyLmhlaWdodCA9IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICAgICAgICAgICAgYmFyLndpZHRoID0gTWF0aC5hYnMoX3RoaXMueFNjYWxlKHZhbHVlKSAtIF90aGlzLnhTY2FsZSh4U2NhbGVNaW4pKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKHhTY2FsZU1pbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhci55ID0gX3RoaXMueVNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnR5cGUgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IG9mZnNldDAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkMFtkMFR5cGVdICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJhci53aWR0aCA9IF90aGlzLnhTY2FsZShvZmZzZXQxKSAtIF90aGlzLnhTY2FsZShvZmZzZXQwKTtcbiAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZShvZmZzZXQwKTtcbiAgICAgICAgICAgICAgICBiYXIueSA9IDA7XG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDAgPSBvZmZzZXQwO1xuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQxID0gb2Zmc2V0MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnR5cGUgPT09ICdub3JtYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IG9mZnNldDAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkMFtkMFR5cGVdICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MCA9IChvZmZzZXQwICogMTAwKSAvIHRvdGFsO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQxID0gKG9mZnNldDEgKiAxMDApIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhci53aWR0aCA9IF90aGlzLnhTY2FsZShvZmZzZXQxKSAtIF90aGlzLnhTY2FsZShvZmZzZXQwKTtcbiAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZShvZmZzZXQwKTtcbiAgICAgICAgICAgICAgICBiYXIueSA9IDA7XG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDAgPSBvZmZzZXQwO1xuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQxID0gb2Zmc2V0MTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IChvZmZzZXQxIC0gb2Zmc2V0MCkudG9GaXhlZCgyKSArICclJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgICAgICBiYXIuY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnR5cGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYmFyLmdyYWRpZW50U3RvcHMgPSBfdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYXIuY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IoYmFyLm9mZnNldDEpO1xuICAgICAgICAgICAgICAgICAgICBiYXIuZ3JhZGllbnRTdG9wcyA9IF90aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKGJhci5vZmZzZXQxLCBiYXIub2Zmc2V0MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IGZvcm1hdHRlZExhYmVsO1xuICAgICAgICAgICAgYmFyLmFyaWFMYWJlbCA9IGZvcm1hdHRlZExhYmVsICsgJyAnICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZXJpZXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcExhYmVsID0gX3RoaXMuc2VyaWVzTmFtZSArIFwiIFxcdTIwMjIgXCIgKyBmb3JtYXR0ZWRMYWJlbDtcbiAgICAgICAgICAgICAgICBiYXIuZGF0YS5zZXJpZXMgPSBfdGhpcy5zZXJpZXNOYW1lO1xuICAgICAgICAgICAgICAgIGJhci5hcmlhTGFiZWwgPSBfdGhpcy5zZXJpZXNOYW1lICsgJyAnICsgYmFyLmFyaWFMYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhci50b29sdGlwVGV4dCA9IF90aGlzLnRvb2x0aXBEaXNhYmxlZFxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBcIlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgZXNjYXBlTGFiZWwodG9vbHRpcExhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybiBiYXI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGFMYWJlbHMoKTtcbiAgICB9O1xuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnVwZGF0ZURhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFja2VkJykge1xuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcbiAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gdGhpcy5zZXJpZXNOYW1lO1xuICAgICAgICAgICAgdmFyIHRvdGFsUG9zaXRpdmUgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiAoZCA+IDAgPyBzdW0gKyBkIDogc3VtKTsgfSwgMCk7XG4gICAgICAgICAgICB2YXIgdG90YWxOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIChkIDwgMCA/IHN1bSArIGQgOiBzdW0pOyB9LCAwKTtcbiAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSB0b3RhbFBvc2l0aXZlICsgdG90YWxOZWdhdGl2ZTtcbiAgICAgICAgICAgIHNlY3Rpb24ueCA9IDA7XG4gICAgICAgICAgICBzZWN0aW9uLnkgPSAwO1xuICAgICAgICAgICAgLy8gaWYgdG90YWwgaXMgcG9zaXRpdmUgdGhlbiB3ZSBzaG93IGl0IG9uIHRoZSByaWdodCwgb3RoZXJ3aXNlIG9uIHRoZSBsZWZ0XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi50b3RhbCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gdGhpcy54U2NhbGUodG90YWxQb3NpdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gdGhpcy54U2NhbGUodG90YWxOZWdhdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWN0aW9uLmhlaWdodCA9IHRoaXMueVNjYWxlLmJhbmR3aWR0aCgpO1xuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscy5wdXNoKHNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge307XG4gICAgICAgICAgICAgICAgc2VjdGlvbi5zZXJpZXMgPSBfdGhpcy5zZXJpZXNOYW1lID8gX3RoaXMuc2VyaWVzTmFtZSA6IGQubGFiZWw7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi50b3RhbCA9IGQudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VjdGlvbi54ID0gX3RoaXMueFNjYWxlKDApO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24ueSA9IF90aGlzLnlTY2FsZShkLmxhYmVsKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gX3RoaXMueFNjYWxlKHNlY3Rpb24udG90YWwpIC0gX3RoaXMueFNjYWxlKDApO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24uaGVpZ2h0ID0gX3RoaXMueVNjYWxlLmJhbmR3aWR0aCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnVwZGF0ZVRvb2x0aXBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b29sdGlwUGxhY2VtZW50ID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiAndG9wJztcbiAgICAgICAgdGhpcy50b29sdGlwVHlwZSA9IHRoaXMudG9vbHRpcERpc2FibGVkID8gdW5kZWZpbmVkIDogJ3Rvb2x0aXAnO1xuICAgIH07XG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICBpZiAoZGF0YUl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbS5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGJhcikge1xuICAgICAgICByZXR1cm4gYmFyLmxhYmVsO1xuICAgIH07XG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUudHJhY2tEYXRhTGFiZWxCeSA9IGZ1bmN0aW9uIChpbmRleCwgYmFyTGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgJyMnICsgYmFyTGFiZWwuc2VyaWVzICsgJyMnICsgYmFyTGFiZWwudG90YWw7XG4gICAgfTtcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwic2VyaWVzTmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJkYXRhTGFiZWxXaWR0aENoYW5nZWRcIiwgdm9pZCAwKTtcbiAgICBTZXJpZXNIb3Jpem9udGFsID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1zZXJpZXMtaG9yaXpvbnRhbF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtYmFyXFxuICAgICAgKm5nRm9yPVxcXCJsZXQgYmFyIG9mIGJhcnM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImJhci53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYmFyLmhlaWdodFxcXCJcXG4gICAgICBbeF09XFxcImJhci54XFxcIlxcbiAgICAgIFt5XT1cXFwiYmFyLnlcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJiYXIuY29sb3JcXFwiXFxuICAgICAgW3N0b3BzXT1cXFwiYmFyLmdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJiYXIuZGF0YVxcXCJcXG4gICAgICBbb3JpZW50YXRpb25dPVxcXCInaG9yaXpvbnRhbCdcXFwiXFxuICAgICAgW3JvdW5kRWRnZXNdPVxcXCJiYXIucm91bmRFZGdlc1xcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwiY2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICBbaXNBY3RpdmVdPVxcXCJpc0FjdGl2ZShiYXIuZGF0YSlcXFwiXFxuICAgICAgW2FyaWFMYWJlbF09XFxcImJhci5hcmlhTGFiZWxcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcInRvb2x0aXBQbGFjZW1lbnRcXFwiXFxuICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwidG9vbHRpcFR5cGVcXFwiXFxuICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGJhci50b29sdGlwVGV4dFxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImJhci5kYXRhXFxcIlxcbiAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd0RhdGFMYWJlbFxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWJhci1sYWJlbFxcbiAgICAgICAgKm5nRm9yPVxcXCJsZXQgYiBvZiBiYXJzRm9yRGF0YUxhYmVsczsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tEYXRhTGFiZWxCeVxcXCJcXG4gICAgICAgIFtiYXJYXT1cXFwiYi54XFxcIlxcbiAgICAgICAgW2JhclldPVxcXCJiLnlcXFwiXFxuICAgICAgICBbYmFyV2lkdGhdPVxcXCJiLndpZHRoXFxcIlxcbiAgICAgICAgW2JhckhlaWdodF09XFxcImIuaGVpZ2h0XFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYi50b3RhbFxcXCJcXG4gICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ2hvcml6b250YWwnXFxcIlxcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwiZGF0YUxhYmVsV2lkdGhDaGFuZ2VkLmVtaXQoeyBzaXplOiAkZXZlbnQsIGluZGV4OiBpIH0pXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbCk7XG4gICAgcmV0dXJuIFNlcmllc0hvcml6b250YWw7XG59KCkpO1xuXG52YXIgQmFyTGFiZWxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFyTGFiZWxDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmhvcml6b250YWxQYWRkaW5nID0gMjtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFBhZGRpbmcgPSA1O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICB2YXIgdyA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiBoLCB3aWR0aDogdywgbmVnYXRpdmU6IHRoaXMudmFsdWUgPCAwIH07XG4gICAgfTtcbiAgICBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQodGhpcy5nZXRTaXplKCkpO1xuICAgIH07XG4gICAgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdGVkVmFsdWUgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ZWRWYWx1ZSA9IGZvcm1hdExhYmVsKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYmFyWCArIHRoaXMuYmFyV2lkdGg7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggLSB0aGlzLmhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgdGhpcy5ob3Jpem9udGFsUGFkZGluZztcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5iYXJZICsgdGhpcy5iYXJIZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5iYXJYICsgdGhpcy5iYXJXaWR0aCAvIDI7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLmJhclkgKyB0aGlzLmJhckhlaWdodDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSArIHRoaXMudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55IC0gdGhpcy52ZXJ0aWNhbFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJyb3RhdGUoLTQ1LCBcIiArIHRoaXMueCArIFwiICwgXCIgKyB0aGlzLnkgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9hLCBfYjtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImJhclhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyWVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJXaWR0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJIZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltZW5zaW9uc0NoYW5nZWRcIiwgdm9pZCAwKTtcbiAgICBCYXJMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYmFyLWxhYmVsXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCIgIFxcbiAgICA8c3ZnOnRleHQgICBcXG4gICAgICBjbGFzcz1cXFwidGV4dERhdGFMYWJlbFxcXCIgXFxuICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJtaWRkbGVcXFwiICAgICBcXG4gICAgICBbYXR0ci50ZXh0LWFuY2hvcl09XFxcInRleHRBbmNob3JcXFwiXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIlxcbiAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIiBcXG4gICAgICBbYXR0ci55XT1cXFwieVxcXCI+XFxuICAgICAge3tmb3JtYXRlZFZhbHVlfX0gICAgIFxcbiAgICA8L3N2Zzp0ZXh0PiAgICAgICAgICBcXG5cXG4gIFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIudGV4dERhdGFMYWJlbHtmb250LXNpemU6MTFweH1cIl0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9iID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0XSlcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEJhckxhYmVsQ29tcG9uZW50O1xufSgpKTtcblxudmFyIEJhckNoYXJ0TW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhckNoYXJ0TW9kdWxlKCkge1xuICAgIH1cbiAgICBCYXJDaGFydE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgQmFyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJMYWJlbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBTZXJpZXNIb3Jpem9udGFsLFxuICAgICAgICAgICAgICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIEJhckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQmFyTGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgU2VyaWVzSG9yaXpvbnRhbCxcbiAgICAgICAgICAgICAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudFxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIEJhckNoYXJ0TW9kdWxlKTtcbiAgICByZXR1cm4gQmFyQ2hhcnRNb2R1bGU7XG59KCkpO1xuXG5mdW5jdGlvbiBnZXREb21haW4odmFsdWVzLCBzY2FsZVR5cGUsIGF1dG9TY2FsZSwgbWluVmFsLCBtYXhWYWwpIHtcbiAgICB2YXIgZG9tYWluID0gW107XG4gICAgaWYgKHNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcbiAgICAgICAgaWYgKCFhdXRvU2NhbGUpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzY2FsZVR5cGUgPT09ICd0aW1lJyB8fCBzY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIHZhciBtaW4kJDEgPSBtaW5WYWwgPyBtaW5WYWwgOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICB2YXIgbWF4JCQxID0gbWF4VmFsID8gbWF4VmFsIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgZG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvbWFpbiA9IHZhbHVlcztcbiAgICB9XG4gICAgcmV0dXJuIGRvbWFpbjtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlKGRvbWFpbiwgcmFuZ2UkJDEsIHNjYWxlVHlwZSwgcm91bmREb21haW5zKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIGlmIChzY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICBzY2FsZSA9IHNjYWxlVGltZSgpXG4gICAgICAgICAgICAucmFuZ2UocmFuZ2UkJDEpXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UocmFuZ2UkJDEpXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgICAgIGlmIChyb3VuZERvbWFpbnMpIHtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGUubmljZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVQb2ludCgpXG4gICAgICAgICAgICAucmFuZ2UoW3JhbmdlJCQxWzBdLCByYW5nZSQkMVsxXV0pXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbn1cblxudmFyIEJ1YmJsZUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWJibGVDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWJibGVDaGFydENvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICBfdGhpcy54QXhpcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnlBeGlzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5tYXhSYWRpdXMgPSAxMDtcbiAgICAgICAgX3RoaXMubWluUmFkaXVzID0gMztcbiAgICAgICAgX3RoaXMuc2NoZW1lVHlwZSA9ICdvcmRpbmFsJztcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5zY2FsZVR5cGUgPSAnbGluZWFyJztcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMuYnViYmxlUGFkZGluZyA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcbiAgICAgICAgdGhpcy5yRG9tYWluID0gdGhpcy5nZXRSRG9tYWluKCk7XG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xuICAgICAgICB2YXIgY29sb3JEb21haW4gPSB0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJyA/IHRoaXMuc2VyaWVzRG9tYWluIDogdGhpcy5yRG9tYWluO1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBjb2xvckRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnJlc3VsdHM7XG4gICAgICAgIHRoaXMubWluUmFkaXVzID0gTWF0aC5tYXgodGhpcy5taW5SYWRpdXMsIDEpO1xuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IE1hdGgubWF4KHRoaXMubWF4UmFkaXVzLCAxKTtcbiAgICAgICAgdGhpcy5yU2NhbGUgPSB0aGlzLmdldFJTY2FsZSh0aGlzLnJEb21haW4sIFt0aGlzLm1pblJhZGl1cywgdGhpcy5tYXhSYWRpdXNdKTtcbiAgICAgICAgdGhpcy5idWJibGVQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB0aGlzLnNldFNjYWxlcygpO1xuICAgICAgICB0aGlzLmJ1YmJsZVBhZGRpbmcgPSB0aGlzLmdldEJ1YmJsZVBhZGRpbmcoKTtcbiAgICAgICAgdGhpcy5zZXRTY2FsZXMoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA9IFwidXJsKCNcIiArIHRoaXMuY2xpcFBhdGhJZCArIFwiKVwiO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmhpZGVDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcbiAgICB9O1xuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllcykge1xuICAgICAgICBpZiAoc2VyaWVzKSB7XG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IHNlcmllcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0QnViYmxlUGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHlNaW4gPSAwO1xuICAgICAgICB2YXIgeE1pbiA9IDA7XG4gICAgICAgIHZhciB5TWF4ID0gdGhpcy5kaW1zLmhlaWdodDtcbiAgICAgICAgdmFyIHhNYXggPSB0aGlzLmRpbXMud2lkdGg7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmRhdGE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuclNjYWxlKGQucik7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gdGhpcy54U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IHRoaXMueFNjYWxlKE51bWJlcihkLngpKSA6IHRoaXMueFNjYWxlKGQueCk7XG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gdGhpcy55U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IHRoaXMueVNjYWxlKE51bWJlcihkLnkpKSA6IHRoaXMueVNjYWxlKGQueSk7XG4gICAgICAgICAgICAgICAgeE1pbiA9IE1hdGgubWF4KHIgLSBjeCwgeE1pbik7XG4gICAgICAgICAgICAgICAgeU1pbiA9IE1hdGgubWF4KHIgLSBjeSwgeU1pbik7XG4gICAgICAgICAgICAgICAgeU1heCA9IE1hdGgubWF4KGN5ICsgciwgeU1heCk7XG4gICAgICAgICAgICAgICAgeE1heCA9IE1hdGgubWF4KGN4ICsgciwgeE1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXggLSB0aGlzLmRpbXMud2lkdGgsIDApO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCAtIHRoaXMuZGltcy5oZWlnaHQsIDApO1xuICAgICAgICByZXR1cm4gW3lNaW4sIHhNYXgsIHlNYXgsIHhNaW5dO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldFNjYWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5kaW1zLndpZHRoO1xuICAgICAgICBpZiAodGhpcy54U2NhbGVNaW4gPT09IHVuZGVmaW5lZCAmJiB0aGlzLnhTY2FsZU1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIC0gdGhpcy5idWJibGVQYWRkaW5nWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmRpbXMuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy55U2NhbGVNaW4gPT09IHVuZGVmaW5lZCAmJiB0aGlzLnlTY2FsZU1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSB0aGlzLmJ1YmJsZVBhZGRpbmdbMl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHdpZHRoKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIGhlaWdodCk7XG4gICAgfTtcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBnZXRTY2FsZShkb21haW4sIFtoZWlnaHQsIHRoaXMuYnViYmxlUGFkZGluZ1swXV0sIHRoaXMueVNjYWxlVHlwZSwgdGhpcy5yb3VuZERvbWFpbnMpO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XG4gICAgICAgIHJldHVybiBnZXRTY2FsZShkb21haW4sIFt0aGlzLmJ1YmJsZVBhZGRpbmdbM10sIHdpZHRoXSwgdGhpcy54U2NhbGVUeXBlLCB0aGlzLnJvdW5kRG9tYWlucyk7XG4gICAgfTtcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UlNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UkJDEpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcbiAgICB9O1xuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkb21haW46IFtdLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb24sXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnJEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGQueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZC54KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54U2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBnZXREb21haW4odmFsdWVzLCB0aGlzLnhTY2FsZVR5cGUsIHRoaXMuYXV0b1NjYWxlLCB0aGlzLnhTY2FsZU1pbiwgdGhpcy54U2NhbGVNYXgpO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55U2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBnZXREb21haW4odmFsdWVzLCB0aGlzLnlTY2FsZVR5cGUsIHRoaXMuYXV0b1NjYWxlLCB0aGlzLnlTY2FsZU1pbiwgdGhpcy55U2NhbGVNYXgpO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFJEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaW4kJDEgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heCQkMSA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihkLnIpIHx8IDE7XG4gICAgICAgICAgICAgICAgbWluJCQxID0gTWF0aC5taW4obWluJCQxLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbWF4JCQxID0gTWF0aC5tYXgobWF4JCQxLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XG4gICAgfTtcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZW50cnksIGVudHJpZXM6IFtdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgIH07XG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhSYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluUmFkaXVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvU2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1pblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWluXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVDaXJjbGVzXCIsIG51bGwpO1xuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYnViYmxlLWNoYXJ0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZGVmcz5cXG4gICAgICAgIDxzdmc6Y2xpcFBhdGggW2F0dHIuaWRdPVxcXCJjbGlwUGF0aElkXFxcIj5cXG4gICAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHQgKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCIndHJhbnNsYXRlKC01LCAtNSknXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Y2xpcFBhdGg+XFxuICAgICAgPC9zdmc6ZGVmcz5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYnViYmxlLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgIGNsYXNzPVxcXCJidWJibGUtY2hhcnQtYXJlYVxcXCJcXG4gICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICAgeT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgICAgc3R5bGU9XFxcImZpbGw6IHJnYigyNTUsIDAsIDApOyBvcGFjaXR5OiAwOyBjdXJzb3I6ICdhdXRvJztcXFwiXFxuICAgICAgICAgIChtb3VzZWVudGVyKT1cXFwiZGVhY3RpdmF0ZUFsbCgpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci5jbGlwLXBhdGhdPVxcXCJjbGlwUGF0aFxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgZGF0YTsgdHJhY2tCeTogdHJhY2tCeVxcXCIgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtYnViYmxlLXNlcmllc1xcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbclNjYWxlXT1cXFwiclNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3hTY2FsZVR5cGVdPVxcXCJ4U2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZVR5cGVdPVxcXCJ5U2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgW3hBeGlzTGFiZWxdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICAgICAgW3lBeGlzTGFiZWxdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIHNlcmllcylcXFwiXFxuICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50KTtcbiAgICByZXR1cm4gQnViYmxlQ2hhcnRDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgQnViYmxlU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1YmJsZVNlcmllc0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaXJjbGVzID0gdGhpcy5nZXRDaXJjbGVzKCk7XG4gICAgfTtcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldENpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5kYXRhLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2VyaWVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGQueSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGQueCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGQueTtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGQueDtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGQucjtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gX3RoaXMuclNjYWxlKHIgfHwgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IGZvcm1hdExhYmVsKGQubmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gX3RoaXMueFNjYWxlVHlwZSA9PT0gJ2xpbmVhcicgPyBfdGhpcy54U2NhbGUoTnVtYmVyKHgpKSA6IF90aGlzLnhTY2FsZSh4KTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSBfdGhpcy55U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IF90aGlzLnlTY2FsZShOdW1iZXIoeSkpIDogX3RoaXMueVNjYWxlKHkpO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IF90aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInID8gX3RoaXMuY29sb3JzLmdldENvbG9yKHIpIDogX3RoaXMuY29sb3JzLmdldENvbG9yKHNlcmllc05hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9ICFfdGhpcy5hY3RpdmVFbnRyaWVzLmxlbmd0aCA/IHRydWUgOiBfdGhpcy5pc0FjdGl2ZSh7IG5hbWU6IHNlcmllc05hbWUgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBpc0FjdGl2ZSA/IDEgOiAwLjM7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC55LFxuICAgICAgICAgICAgICAgICAgICB4OiBkLngsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogZC5yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgcjogcixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lczogW1wiY2lyY2xlLWRhdGEtXCIgKyBpXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBMYWJlbDogdG9vbHRpcExhYmVsLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIGN4ICsgXCIsXCIgKyBjeSArIFwiKVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNpcmNsZSkgeyByZXR1cm4gY2lyY2xlICE9PSB1bmRlZmluZWQ7IH0pO1xuICAgIH07XG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgdmFyIGhhc1JhZGl1cyA9IHR5cGVvZiBjaXJjbGUuciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIHZhciBoYXNUb29sdGlwTGFiZWwgPSBjaXJjbGUudG9vbHRpcExhYmVsICYmIGNpcmNsZS50b29sdGlwTGFiZWwubGVuZ3RoO1xuICAgICAgICB2YXIgaGFzU2VyaWVzTmFtZSA9IGNpcmNsZS5zZXJpZXNOYW1lICYmIGNpcmNsZS5zZXJpZXNOYW1lLmxlbmd0aDtcbiAgICAgICAgdmFyIHJhZGl1c1ZhbHVlID0gaGFzUmFkaXVzID8gZm9ybWF0TGFiZWwoY2lyY2xlLnIpIDogJyc7XG4gICAgICAgIHZhciB4QXhpc0xhYmVsID0gdGhpcy54QXhpc0xhYmVsICYmIHRoaXMueEF4aXNMYWJlbCAhPT0gJycgPyB0aGlzLnhBeGlzTGFiZWwgKyBcIjpcIiA6ICcnO1xuICAgICAgICB2YXIgeUF4aXNMYWJlbCA9IHRoaXMueUF4aXNMYWJlbCAmJiB0aGlzLnlBeGlzTGFiZWwgIT09ICcnID8gdGhpcy55QXhpc0xhYmVsICsgXCI6XCIgOiAnJztcbiAgICAgICAgdmFyIHggPSBmb3JtYXRMYWJlbChjaXJjbGUueCk7XG4gICAgICAgIHZhciB5ID0gZm9ybWF0TGFiZWwoY2lyY2xlLnkpO1xuICAgICAgICB2YXIgbmFtZSA9IGhhc1Nlcmllc05hbWUgJiYgaGFzVG9vbHRpcExhYmVsXG4gICAgICAgICAgICA/IGNpcmNsZS5zZXJpZXNOYW1lICsgXCIgXFx1MjAyMiBcIiArIGNpcmNsZS50b29sdGlwTGFiZWxcbiAgICAgICAgICAgIDogY2lyY2xlLnNlcmllc05hbWUgKyBjaXJjbGUudG9vbHRpcExhYmVsO1xuICAgICAgICB2YXIgdG9vbHRpcFRpdGxlID0gaGFzU2VyaWVzTmFtZSB8fCBoYXNUb29sdGlwTGFiZWwgP1xuICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBlc2NhcGVMYWJlbChuYW1lKSArIFwiPC9zcGFuPlwiIDogJyc7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgdG9vbHRpcFRpdGxlICsgXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XFxuICAgICAgICA8bGFiZWw+XCIgKyBlc2NhcGVMYWJlbCh4QXhpc0xhYmVsKSArIFwiPC9sYWJlbD4gXCIgKyBlc2NhcGVMYWJlbCh4KSArIFwiPGJyIC8+XFxuICAgICAgICA8bGFiZWw+XCIgKyBlc2NhcGVMYWJlbCh5QXhpc0xhYmVsKSArIFwiPC9sYWJlbD4gXCIgKyBlc2NhcGVMYWJlbCh5KSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XFxuICAgICAgICBcIiArIGVzY2FwZUxhYmVsKHJhZGl1c1ZhbHVlKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICBcIjtcbiAgICB9O1xuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWN0aXZlKHsgbmFtZTogY2lyY2xlLnNlcmllc05hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNpcmNsZS5vcGFjaXR5ICE9PSAwO1xuICAgIH07XG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgY2lyY2xlLmJhclZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcbiAgICB9O1xuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgY2lyY2xlLmJhclZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcbiAgICB9O1xuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiBjaXJjbGUuZGF0YS5zZXJpZXMgKyBcIiBcIiArIGNpcmNsZS5kYXRhLm5hbWU7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiclNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVUeXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVUeXBlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWJ1YmJsZS1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgY2lyY2xlIG9mIGNpcmNsZXM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJjaXJjbGUudHJhbnNmb3JtXFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZVxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIGNsYXNzPVxcXCJjaXJjbGVcXFwiXFxuICAgICAgICAgIFtjeF09XFxcIjBcXFwiXFxuICAgICAgICAgIFtjeV09XFxcIjBcXFwiXFxuICAgICAgICAgIFtyXT1cXFwiY2lyY2xlLnJhZGl1c1xcXCJcXG4gICAgICAgICAgW2ZpbGxdPVxcXCJjaXJjbGUuY29sb3JcXFwiXFxuICAgICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cXFwiY2lyY2xlLm9wYWNpdHlcXFwiXFxuICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJjaXJjbGUuaXNBY3RpdmVcXFwiXFxuICAgICAgICAgIFtwb2ludGVyRXZlbnRzXT1cXFwiJ2FsbCdcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwiY2lyY2xlLnZhbHVlXFxcIlxcbiAgICAgICAgICBbY2xhc3NOYW1lc109XFxcImNpcmNsZS5jbGFzc05hbWVzXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljayhjaXJjbGUuZGF0YSlcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlQ2lyY2xlKGNpcmNsZSlcXFwiXFxuICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZUNpcmNsZShjaXJjbGUpXFxcIlxcbiAgICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjaXJjbGUpXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJjaXJjbGUuZGF0YVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06ICdzY2FsZSgxKScgfSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQpO1xuICAgIHJldHVybiBCdWJibGVTZXJpZXNDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgQnViYmxlQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnViYmxlQ2hhcnRNb2R1bGUoKSB7XG4gICAgfVxuICAgIEJ1YmJsZUNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBCdWJibGVDaGFydENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBCdWJibGVTZXJpZXNDb21wb25lbnRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgQnViYmxlQ2hhcnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgQnViYmxlU2VyaWVzQ29tcG9uZW50XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgQnViYmxlQ2hhcnRNb2R1bGUpO1xuICAgIHJldHVybiBCdWJibGVDaGFydE1vZHVsZTtcbn0oKSk7XG5cbnZhciBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mb3JjZSA9IGZvcmNlU2ltdWxhdGlvbigpXG4gICAgICAgICAgICAuZm9yY2UoJ2NoYXJnZScsIGZvcmNlTWFueUJvZHkoKSlcbiAgICAgICAgICAgIC5mb3JjZSgnY29sbGlkZScsIGZvcmNlQ29sbGlkZSg1KSlcbiAgICAgICAgICAgIC5mb3JjZSgneCcsIGZvcmNlWCgpKVxuICAgICAgICAgICAgLmZvcmNlKCd5JywgZm9yY2VZKCkpO1xuICAgICAgICBfdGhpcy5mb3JjZUxpbmsgPSBmb3JjZUxpbmsoKS5pZChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52YWx1ZTsgfSk7XG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgX3RoaXMubGlua3MgPSBbXTtcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgX3RoaXMucmVzdWx0cyA9IFtdO1xuICAgICAgICBfdGhpcy5ncm91cFJlc3VsdHNCeSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZhbHVlOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJcXG4gICAgICB0cmFuc2xhdGUoXCIgKyAodGhpcy5kaW1zLnhPZmZzZXQgKyB0aGlzLmRpbXMud2lkdGggLyAyKSArIFwiLCBcIiArICh0aGlzLm1hcmdpblswXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyKSArIFwiKVxcbiAgICBcIjtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VcbiAgICAgICAgICAgICAgICAubm9kZXModGhpcy5ub2RlcylcbiAgICAgICAgICAgICAgICAuZm9yY2UoJ2xpbmsnLCB0aGlzLmZvcmNlTGluay5saW5rcyh0aGlzLmxpbmtzKSlcbiAgICAgICAgICAgICAgICAuYWxwaGEoMC41KVxuICAgICAgICAgICAgICAgIC5yZXN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlRW50cmllcy5pbmRleE9mKGV2ZW50JCQxKSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbZXZlbnQkJDFdLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZXZlbnQkJDEsIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuaW5kZXhPZihldmVudCQkMSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGV2ZW50JCQxLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmdldFNlcmllc0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdyb3VwUmVzdWx0c0J5KGQpOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAobm9kZXMsIG5vZGUpIHsgcmV0dXJuIChub2Rlcy5pbmNsdWRlcyhub2RlKSA/IG5vZGVzIDogbm9kZXMuY29uY2F0KFtub2RlXSkpOyB9LCBbXSlcbiAgICAgICAgICAgIC5zb3J0KCk7XG4gICAgfTtcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnRyYWNrTGlua0J5ID0gZnVuY3Rpb24gKGluZGV4LCBsaW5rKSB7XG4gICAgICAgIHJldHVybiBsaW5rLmluZGV4O1xuICAgIH07XG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS50cmFja05vZGVCeSA9IGZ1bmN0aW9uIChpbmRleCwgbm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9O1xuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLnNlcmllc0RvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiAnb3JkaW5hbCcsXG4gICAgICAgICAgICBkb21haW46IHRoaXMuc2VyaWVzRG9tYWluLFxuICAgICAgICAgICAgY29sb3JzOiB0aGlzLmNvbG9ycyxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxlZ2VuZFRpdGxlLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAobm9kZSwgJGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9yY2UuYWxwaGFUYXJnZXQoMC4zKS5yZXN0YXJ0KCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1N0YXJ0ID0geyB4OiAkZXZlbnQueCAtIG5vZGUueCwgeTogJGV2ZW50LnkgLSBub2RlLnkgfTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnggPSAkZXZlbnQueCAtIHRoaXMuZHJhZ2dpbmdTdGFydC54O1xuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZS5meSA9ICRldmVudC55IC0gdGhpcy5kcmFnZ2luZ1N0YXJ0Lnk7XG4gICAgfTtcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uRHJhZyA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nTm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnggPSAkZXZlbnQueCAtIHRoaXMuZHJhZ2dpbmdTdGFydC54O1xuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZS5meSA9ICRldmVudC55IC0gdGhpcy5kcmFnZ2luZ1N0YXJ0Lnk7XG4gICAgfTtcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nTm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5mb3JjZS5hbHBoYVRhcmdldCgwKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlLmZ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUuZXNjYXBlID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVMYWJlbChsYWJlbCk7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImZvcmNlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JjZUxpbmtcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub2Rlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBBcnJheSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibGlua3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCdsaW5rVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QpXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsaW5rVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCdub2RlVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9lID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2UgOiBPYmplY3QpXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9mID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2YgOiBPYmplY3QpXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKENoYXJ0Q29tcG9uZW50LCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9nID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9nIDogT2JqZWN0KVxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBSZXN1bHRzQnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSG9zdExpc3RlbmVyKCdkb2N1bWVudDptb3VzZW1vdmUnLCBbJyRldmVudCddKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9oID0gdHlwZW9mIE1vdXNlRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgTW91c2VFdmVudCkgPT09IFwiZnVuY3Rpb25cIiA/IF9oIDogT2JqZWN0XSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkRyYWdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2V1cCcsIFsnJGV2ZW50J10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2ogPSB0eXBlb2YgTW91c2VFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBNb3VzZUV2ZW50KSA9PT0gXCJmdW5jdGlvblwiID8gX2ogOiBPYmplY3RdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRHJhZ0VuZFwiLCBudWxsKTtcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1mb3JjZS1kaXJlY3RlZC1ncmFwaCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJmb3JjZS1kaXJlY3RlZC1ncmFwaCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmcgY2xhc3M9XFxcImxpbmtzXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IGxpbmsgb2YgbGlua3M7IHRyYWNrQnk6IHRyYWNrTGlua0J5XFxcIj5cXG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcXG4gICAgICAgICAgICAgICpuZ0lmPVxcXCJsaW5rVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XFxcImxpbmtUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XFxcInsgJGltcGxpY2l0OiBsaW5rIH1cXFwiXFxuICAgICAgICAgICAgPjwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgICAgICAqbmdJZj1cXFwiIWxpbmtUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVxcXCIxXFxcIlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcImVkZ2VcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci54MV09XFxcImxpbmsuc291cmNlLnhcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci55MV09XFxcImxpbmsuc291cmNlLnlcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci54Ml09XFxcImxpbmsudGFyZ2V0LnhcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci55Ml09XFxcImxpbmsudGFyZ2V0LnlcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgY2xhc3M9XFxcIm5vZGVzXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgKm5nRm9yPVxcXCJsZXQgbm9kZSBvZiBub2RlczsgdHJhY2tCeTogdHJhY2tOb2RlQnlcXFwiXFxuICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiJ3RyYW5zbGF0ZSgnICsgbm9kZS54ICsgJywnICsgbm9kZS55ICsgJyknXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmZpbGxdPVxcXCJjb2xvcnMuZ2V0Q29sb3IoZ3JvdXBSZXN1bHRzQnkobm9kZSkpXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnN0cm9rZV09XFxcImNvbG9ycy5nZXRDb2xvcihncm91cFJlc3VsdHNCeShub2RlKSlcXFwiXFxuICAgICAgICAgICAgKG1vdXNlZG93bik9XFxcIm9uRHJhZ1N0YXJ0KG5vZGUsICRldmVudClcXFwiXFxuICAgICAgICAgICAgKGNsaWNrKT1cXFwib25DbGljayh7IG5hbWU6IG5vZGUudmFsdWUgfSlcXFwiXFxuICAgICAgICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBlc2NhcGUobm9kZS52YWx1ZSlcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJub2RlXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXFxuICAgICAgICAgICAgICAqbmdJZj1cXFwibm9kZVRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJub2RlVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVxcXCJ7ICRpbXBsaWNpdDogbm9kZSB9XFxcIlxcbiAgICAgICAgICAgID48L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgIDxzdmc6Y2lyY2xlICpuZ0lmPVxcXCIhbm9kZVRlbXBsYXRlXFxcIiByPVxcXCI1XFxcIiAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIuZm9yY2UtZGlyZWN0ZWQtZ3JhcGggLmVkZ2V7c3Ryb2tlOiMzMzN9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50KTtcbiAgICByZXR1cm4gRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb3JjZURpcmVjdGVkR3JhcGhNb2R1bGUoKSB7XG4gICAgfVxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQsXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlKTtcbiAgICByZXR1cm4gRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlO1xufSgpKTtcblxudmFyIEhlYXRNYXBDZWxsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhlYXRNYXBDZWxsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIiAsIFwiICsgdGhpcy55ICsgXCIpXCI7XG4gICAgICAgIHRoaXMuc3RhcnRPcGFjaXR5ID0gMC4zO1xuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRVcmwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5nZXRHcmFkaWVudFN0b3BzKCk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JhZGllbnRTdG9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5sb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmNlbGwnKTtcbiAgICAgICAgbm9kZS5hdHRyKCdvcGFjaXR5JywgMCk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZVRvQ3VycmVudEZvcm0oKTtcbiAgICB9O1xuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5hbmltYXRlVG9DdXJyZW50Rm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5jZWxsJyk7XG4gICAgICAgIG5vZGVcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDEpO1xuICAgIH07XG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQodGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlRW50ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlTGVhdmVcIiwgbnVsbCk7XG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGxdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiY2VsbFxcXCI+XFxuICAgICAgPGRlZnMgKm5nSWY9XFxcImdyYWRpZW50XFxcIj5cXG4gICAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnQgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIiBbbmFtZV09XFxcImdyYWRpZW50SWRcXFwiIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBmaWxsXFxcIlxcbiAgICAgICAgcng9XFxcIjNcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcIndpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNlbGxcXFwiXFxuICAgICAgICBzdHlsZT1cXFwiY3Vyc29yOiBwb2ludGVyXFxcIlxcbiAgICAgICAgKGNsaWNrKT1cXFwib25DbGljaygpXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gSGVhdE1hcENlbGxDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgSGVhdENlbGxTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVhdENlbGxTZXJpZXNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBUZXh0ID0gdGhpcy5nZXRUb29sdGlwVGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2VsbHMgPSB0aGlzLmdldENlbGxzKCk7XG4gICAgfTtcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJvdy5zZXJpZXMubWFwKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2VsbC52YWx1ZTtcbiAgICAgICAgICAgICAgICBjZWxsLnNlcmllcyA9IHJvdy5uYW1lO1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY2VsbDogY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgeDogX3RoaXMueFNjYWxlKHJvdy5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgeTogX3RoaXMueVNjYWxlKGNlbGwubmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy54U2NhbGUuYmFuZHdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3RoaXMueVNjYWxlLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdExhYmVsKGNlbGwubmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHNlcmllczogcm93Lm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH07XG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsLCBkYXRhID0gX2EuZGF0YSwgc2VyaWVzID0gX2Euc2VyaWVzO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBlc2NhcGVMYWJlbChzZXJpZXMpICsgXCIgXFx1MjAyMiBcIiArIGVzY2FwZUxhYmVsKGxhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyBkYXRhLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XG4gICAgfTtcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b29sdGlwVGV4dDtcbiAgICB9O1xuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtaGVhdC1tYXAtY2VsbC1zZXJpZXNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGxcXG4gICAgICAqbmdGb3I9XFxcImxldCBjIG9mIGNlbGxzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgIFt4XT1cXFwiYy54XFxcIlxcbiAgICAgIFt5XT1cXFwiYy55XFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImMud2lkdGhcXFwiXFxuICAgICAgW2hlaWdodF09XFxcImMuaGVpZ2h0XFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiYy5maWxsXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiYy5kYXRhXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKGMuY2VsbClcXFwiXFxuICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUuZW1pdChjLmNlbGwpXFxcIlxcbiAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KGMuY2VsbClcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdG9vbHRpcFRleHQoYylcXFwiXFxuICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJ7IHNlcmllczogYy5zZXJpZXMsIG5hbWU6IGMubGFiZWwsIHZhbHVlOiBjLmRhdGEgfVxcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQpO1xuICAgIHJldHVybiBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBIZWF0TWFwQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWF0TWFwQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYXRNYXBDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIF90aGlzLmlubmVyUGFkZGluZyA9IDg7XG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuc2NhbGVUeXBlID0gJ2xpbmVhcic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodGhpcy52YWx1ZURvbWFpbiwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NhbGVUeXBlLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLm1pbjtcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLm1heDtcbiAgICAgICAgICAgIGlmICghdGhpcy5taW4pIHtcbiAgICAgICAgICAgICAgICBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KHRoaXMudmFsdWVEb21haW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB0aGlzLnZhbHVlRG9tYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsdWVEb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgICAgIHRoaXMucmVjdHMgPSB0aGlzLmdldFJlY3RzKCk7XG4gICAgfTtcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhncm91cC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9O1xuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tYWluID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgTiwgTCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnWycsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCddJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3B4JywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcJycsICcnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnLCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb24odmFsdWVbaW5kZXhdLCBudWxsLCBOLCBMKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcygnJScpKSB7XG4gICAgICAgICAgICByZXR1cm4gK3ZhbHVlLnJlcGxhY2UoJyUnLCAnJykgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE4gLyAoTCAvICt2YWx1ZSArIDEpO1xuICAgIH07XG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0RGltZW5zaW9uKHRoaXMuaW5uZXJQYWRkaW5nLCAwLCB0aGlzLnhEb21haW4ubGVuZ3RoLCB0aGlzLmRpbXMud2lkdGgpO1xuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmRpbXMud2lkdGhdKVxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnhEb21haW4pXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKGYpO1xuICAgIH07XG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0RGltZW5zaW9uKHRoaXMuaW5uZXJQYWRkaW5nLCAxLCB0aGlzLnlEb21haW4ubGVuZ3RoLCB0aGlzLmRpbXMuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbdGhpcy5kaW1zLmhlaWdodCwgMF0pXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueURvbWFpbilcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoZik7XG4gICAgfTtcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSZWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlY3RzID0gW107XG4gICAgICAgIHRoaXMueERvbWFpbi5tYXAoZnVuY3Rpb24gKHhWYWwpIHtcbiAgICAgICAgICAgIF90aGlzLnlEb21haW4ubWFwKGZ1bmN0aW9uICh5VmFsKSB7XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IF90aGlzLnhTY2FsZSh4VmFsKSxcbiAgICAgICAgICAgICAgICAgICAgeTogX3RoaXMueVNjYWxlKHlWYWwpLFxuICAgICAgICAgICAgICAgICAgICByeDogMyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLnhTY2FsZS5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy55U2NhbGUuYmFuZHdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDIwMCwyMDAsMjAwLDAuMDMpJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVjdHM7XG4gICAgfTtcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NhbGVUeXBlLCB0aGlzLnZhbHVlRG9tYWluKTtcbiAgICB9O1xuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NhbGVUeXBlLFxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnZhbHVlRG9tYWluLFxuICAgICAgICAgICAgY29sb3JzOiB0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5jb2xvcnMgOiB0aGlzLmNvbG9ycy5zY2FsZSxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5sZWdlbmRUaXRsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcbiAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBIZWF0TWFwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtaGVhdC1tYXAnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJoZWF0LW1hcCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgcmVjdCBvZiByZWN0c1xcXCJcXG4gICAgICAgICAgW2F0dHIueF09XFxcInJlY3QueFxcXCJcXG4gICAgICAgICAgW2F0dHIueV09XFxcInJlY3QueVxcXCJcXG4gICAgICAgICAgW2F0dHIucnhdPVxcXCJyZWN0LnJ4XFxcIlxcbiAgICAgICAgICBbYXR0ci53aWR0aF09XFxcInJlY3Qud2lkdGhcXFwiXFxuICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcInJlY3QuaGVpZ2h0XFxcIlxcbiAgICAgICAgICBbYXR0ci5maWxsXT1cXFwicmVjdC5maWxsXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGwtc2VyaWVzXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZXh0XT1cXFwidG9vbHRpcFRleHRcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQpXFxcIlxcbiAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICB9KVxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQpO1xuICAgIHJldHVybiBIZWF0TWFwQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIEhlYXRNYXBNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVhdE1hcE1vZHVsZSgpIHtcbiAgICB9XG4gICAgSGVhdE1hcE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgSGVhdE1hcENlbGxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgSGVhdE1hcENvbXBvbmVudFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBIZWF0TWFwQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBIZWF0TWFwQ29tcG9uZW50XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgSGVhdE1hcE1vZHVsZSk7XG4gICAgcmV0dXJuIEhlYXRNYXBNb2R1bGU7XG59KCkpO1xuXG52YXIgTGluZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5lQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5maWxsID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICBMaW5lQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxQYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoRWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlUGF0aEVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkuc2VsZWN0KCcubGluZScpO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zKSB7XG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCB0aGlzLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hdHRyKCdkJywgdGhpcy5wYXRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIF9hO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcInBhdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgTGluZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIExpbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWxpbmVdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOnBhdGhcXG4gICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgY2xhc3M9XFxcImxpbmVcXFwiXFxuICAgICAgW2F0dHIuZF09XFxcImluaXRpYWxQYXRoXFxcIlxcbiAgICAgIFthdHRyLmZpbGxdPVxcXCJmaWxsXFxcIlxcbiAgICAgIFthdHRyLnN0cm9rZV09XFxcInN0cm9rZVxcXCJcXG4gICAgICBzdHJva2Utd2lkdGg9XFxcIjEuNXB4XFxcIlxcbiAgICAvPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogMjAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiAyMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDEwMDAsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBMaW5lQ29tcG9uZW50KTtcbiAgICByZXR1cm4gTGluZUNvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBMaW5lQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmVDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5lQ2hhcnRDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5jdXJ2ZSA9IGN1cnZlTGluZWFyO1xuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dSZWZMaW5lcyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zaG93UmVmTGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lSGVpZ2h0ID0gNTA7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lUGFkZGluZyA9IDEwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgICAgICAgdGhpcy5kaW1zLmhlaWdodCAtPSB0aGlzLnRpbWVsaW5lSGVpZ2h0ICsgdGhpcy5tYXJnaW5bMl0gKyB0aGlzLnRpbWVsaW5lUGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWREb21haW4pIHtcbiAgICAgICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLmRpbXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA9IFwidXJsKCNcIiArIHRoaXMuY2xpcFBhdGhJZCArIFwiKVwiO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVXaWR0aCA9IHRoaXMuZGltcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYRG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy50aW1lbGluZVhEb21haW4sIHRoaXMudGltZWxpbmVXaWR0aCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLnRpbWVsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsIFwiICsgLXRoaXMubWFyZ2luWzJdICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldFVuaXF1ZVhEb21haW5WYWx1ZXModGhpcy5yZXN1bHRzKTtcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodmFsdWVzKTtcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW4kJDE7XG4gICAgICAgIHZhciBtYXgkJDE7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnIHx8IHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgbWluJCQxID0gdGhpcy54U2NhbGVNaW4gPyB0aGlzLnhTY2FsZU1pbiA6IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IHRoaXMueFNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgZG9tYWluID0gW25ldyBEYXRlKG1pbiQkMSksIG5ldyBEYXRlKG1heCQkMSldO1xuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhRGF0ZSA9IGEuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciBiRGF0ZSA9IGIuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhRGF0ZSA+IGJEYXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9tYWluID0gdmFsdWVzO1xuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfTtcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLnZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmluZGV4T2YoZC5taW4pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5taW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmluZGV4T2YoZC5tYXgpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5tYXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkb21haW4uc2xpY2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmF1dG9TY2FsZSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueVNjYWxlTWluID8gdGhpcy55U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyB0aGlzLnlTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRTZXJpZXNEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCB3aWR0aCkge1xuICAgICAgICB2YXIgc2NhbGU7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlVGltZSgpXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMucm91bmREb21haW5zKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZS5uaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KClcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAucGFkZGluZygwLjEpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XG4gICAgfTtcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcbiAgICAgICAgdGhpcy5maWx0ZXJlZERvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XG4gICAgfTtcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gaXRlbS52YWx1ZTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgfTtcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmhpZGVDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW47XG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnlEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbWFpbjogW10sXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfTtcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYWN0aXZlRW50cmllczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXV0b1NjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VGaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJlZmVyZW5jZUxpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1JlZkxhYmVsc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1pblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb250ZW50Q2hpbGQoJ3Nlcmllc1Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVDaXJjbGVzXCIsIG51bGwpO1xuICAgIExpbmVDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWxpbmUtY2hhcnQnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpkZWZzPlxcbiAgICAgICAgPHN2ZzpjbGlwUGF0aCBbYXR0ci5pZF09XFxcImNsaXBQYXRoSWRcXFwiPlxcbiAgICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGggKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcIid0cmFuc2xhdGUoLTUsIC01KSdcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpjbGlwUGF0aD5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJsaW5lLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JlZmVyZW5jZUxpbmVzXT1cXFwicmVmZXJlbmNlTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93UmVmTGluZXNdPVxcXCJzaG93UmVmTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93UmVmTGFiZWxzXT1cXFwic2hvd1JlZkxhYmVsc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIuY2xpcC1wYXRoXT1cXFwiY2xpcFBhdGhcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWxpbmUtc2VyaWVzXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICAgIFtyYW5nZUZpbGxPcGFjaXR5XT1cXFwicmFuZ2VGaWxsT3BhY2l0eVxcXCJcXG4gICAgICAgICAgICAgIFtoYXNSYW5nZV09XFxcImhhc1JhbmdlXFxcIlxcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwiIXRvb2x0aXBEaXNhYmxlZFxcXCIgKG1vdXNlbGVhdmUpPVxcXCJoaWRlQ2lyY2xlcygpXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtdG9vbHRpcC1hcmVhXFxuICAgICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgICBbeFNldF09XFxcInhTZXRcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIChob3Zlcik9XFxcInVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIC8+XFxuXFxuICAgICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzXFxcIj5cXG4gICAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNcXG4gICAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICAgIFt2aXNpYmxlVmFsdWVdPVxcXCJob3ZlcmVkVmVydGljYWxcXFwiXFxuICAgICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy10aW1lbGluZVxcbiAgICAgICAgKm5nSWY9XFxcInRpbWVsaW5lICYmIHNjYWxlVHlwZSAhPSAnb3JkaW5hbCdcXFwiXFxuICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0aW1lbGluZVRyYW5zZm9ybVxcXCJcXG4gICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgIFt2aWV3XT1cXFwiW3RpbWVsaW5lV2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwidGltZWxpbmVIZWlnaHRcXFwiXFxuICAgICAgICBbc2NoZW1lXT1cXFwic2NoZW1lXFxcIlxcbiAgICAgICAgW2N1c3RvbUNvbG9yc109XFxcImN1c3RvbUNvbG9yc1xcXCJcXG4gICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICBbbGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgICAgKG9uRG9tYWluQ2hhbmdlKT1cXFwidXBkYXRlRG9tYWluKCRldmVudClcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1saW5lLXNlcmllc1xcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ0aW1lbGluZVhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwidGltZWxpbmVZU2NhbGVcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgIFtoYXNSYW5nZV09XFxcImhhc1JhbmdlXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50KTtcbiAgICByZXR1cm4gTGluZUNoYXJ0Q29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIExpbmVTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZVNlcmllc0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICB9XG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUdyYWRpZW50cygpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc29ydERhdGEodGhpcy5kYXRhLnNlcmllcyk7XG4gICAgICAgIHZhciBsaW5lR2VuID0gdGhpcy5nZXRMaW5lR2VuZXJhdG9yKCk7XG4gICAgICAgIHRoaXMucGF0aCA9IGxpbmVHZW4oZGF0YSkgfHwgJyc7XG4gICAgICAgIHZhciBhcmVhR2VuID0gdGhpcy5nZXRBcmVhR2VuZXJhdG9yKCk7XG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSBhcmVhR2VuKGRhdGEpIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5oYXNSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlJCQxID0gdGhpcy5nZXRSYW5nZUdlbmVyYXRvcigpO1xuICAgICAgICAgICAgdGhpcy5vdXRlclBhdGggPSByYW5nZSQkMShkYXRhKSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNHcmFkaWVudCkge1xuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSB0aGlzLmdyYWRpZW50VXJsO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAobWF4JCQxID09PSBtaW4kJDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZSA9IHRoaXMuY29sb3JzLmdldENvbG9yKG1heCQkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSA9IHRoaXMuY29sb3JzLmdldENvbG9yKHRoaXMuZGF0YS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGluZUdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGxpbmUoKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZC52YWx1ZSk7IH0pXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSYW5nZUdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFyZWEoKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKHR5cGVvZiBkLm1pbiA9PT0gJ251bWJlcicgPyBkLm1pbiA6IGQudmFsdWUpOyB9KVxuICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUodHlwZW9mIGQubWF4ID09PSAnbnVtYmVyJyA/IGQubWF4IDogZC52YWx1ZSk7IH0pXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBcmVhR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeFByb3BlcnR5ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy54U2NhbGUobGFiZWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXJlYSgpXG4gICAgICAgICAgICAueCh4UHJvcGVydHkpXG4gICAgICAgICAgICAueTAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMueVNjYWxlLnJhbmdlKClbMF07IH0pXG4gICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkLnZhbHVlKTsgfSlcbiAgICAgICAgICAgIC5jdXJ2ZSh0aGlzLmN1cnZlKTtcbiAgICB9O1xuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnNvcnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHNvcnRCeURvbWFpbihkYXRhLCAnbmFtZScsICdhc2MnLCB0aGlzLnhTY2FsZS5kb21haW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVHcmFkaWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRVcmwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG4gICAgICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgkJDEsIG1pbiQkMSk7XG4gICAgICAgICAgICB0aGlzLmFyZWFHcmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgkJDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hcmVhR3JhZGllbnRTdG9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNJbmFjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcyB8fCB0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFzUmFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIExpbmVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWxpbmUtc2VyaWVzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnPlxcbiAgICAgIDxkZWZzPlxcbiAgICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudCAqbmdJZj1cXFwiaGFzR3JhZGllbnRcXFwiXFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtYXJlYVxcbiAgICAgICAgY2xhc3M9XFxcImxpbmUtaGlnaGxpZ2h0XFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgW3BhdGhdPVxcXCJhcmVhUGF0aFxcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudFVybCA6IGNvbG9ycy5nZXRDb2xvcihkYXRhLm5hbWUpXFxcIlxcbiAgICAgICAgW29wYWNpdHldPVxcXCIwLjI1XFxcIlxcbiAgICAgICAgW3N0YXJ0T3BhY2l0eV09XFxcIjBcXFwiXFxuICAgICAgICBbZ3JhZGllbnRdPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgW3N0b3BzXT1cXFwiYXJlYUdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpc0luYWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtbGluZVxcbiAgICAgICAgY2xhc3M9XFxcImxpbmUtc2VyaWVzXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgW3BhdGhdPVxcXCJwYXRoXFxcIlxcbiAgICAgICAgW3N0cm9rZV09XFxcInN0cm9rZVxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJpc0FjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAgIFtjbGFzcy5pbmFjdGl2ZV09XFxcImlzSW5hY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgLz5cXG4gICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLWFyZWFcXG4gICAgICAgICpuZ0lmPVxcXCJoYXNSYW5nZVxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJsaW5lLXNlcmllcy1yYW5nZVxcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgIFtwYXRoXT1cXFwib3V0ZXJQYXRoXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJoYXNHcmFkaWVudCA/IGdyYWRpZW50VXJsIDogY29sb3JzLmdldENvbG9yKGRhdGEubmFtZSlcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpc0luYWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW29wYWNpdHldPVxcXCJyYW5nZUZpbGxPcGFjaXR5XFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudCk7XG4gICAgcmV0dXJuIExpbmVTZXJpZXNDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgTGluZUNoYXJ0TW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVDaGFydE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTGluZUNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBMaW5lQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIExpbmVDaGFydENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBMaW5lU2VyaWVzQ29tcG9uZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIExpbmVDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgTGluZUNoYXJ0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIExpbmVTZXJpZXNDb21wb25lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBMaW5lQ2hhcnRNb2R1bGUpO1xuICAgIHJldHVybiBMaW5lQ2hhcnRNb2R1bGU7XG59KCkpO1xuXG52YXIgdHdvUEkgPSAyICogTWF0aC5QSTtcbnZhciBQb2xhckNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb2xhckNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvbGFyQ2hhcnRDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5jdXJ2ZSA9IGN1cnZlQ2FyZGluYWxDbG9zZWQ7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMucmFuZ2VGaWxsT3BhY2l0eSA9IDAuMTU7XG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2hvd1Nlcmllc09uSG92ZXIgPSB0cnVlO1xuICAgICAgICBfdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy55QXhpc01pblNjYWxlID0gMDtcbiAgICAgICAgX3RoaXMubGFiZWxUcmltID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubGFiZWxUcmltU2l6ZSA9IDEwO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RGltcygpO1xuICAgICAgICB0aGlzLnNldFNjYWxlcygpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRUaWNrcygpO1xuICAgIH07XG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0RGltcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5kaW1zLndpZHRoIC8gMik7XG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmRpbXMuaGVpZ2h0IC8gMik7XG4gICAgICAgIHZhciBvdXRlclJhZGl1cyA9ICh0aGlzLm91dGVyUmFkaXVzID0gTWF0aC5taW4oaGFsZkhlaWdodCAvIDEuNSwgaGFsZldpZHRoIC8gMS41KSk7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gTWF0aC5tYXgoMCwgaGFsZkhlaWdodCAtIG91dGVyUmFkaXVzKTtcbiAgICAgICAgdGhpcy55QXhpc0RpbXMgPSBfX2Fzc2lnbih7fSwgdGhpcy5kaW1zLCB7IHdpZHRoOiBoYWxmV2lkdGggfSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtWUF4aXMgPSBcInRyYW5zbGF0ZSgwLCBcIiArIHlPZmZzZXQgKyBcIilcIjtcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IHRoaXMuZGltcy5oZWlnaHQgKyA0MDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1QbG90ID0gXCJ0cmFuc2xhdGUoXCIgKyBoYWxmV2lkdGggKyBcIiwgXCIgKyBoYWxmSGVpZ2h0ICsgXCIpXCI7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTY2FsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0gdGhpcy5nZXRYVmFsdWVzKCk7XG4gICAgICAgIHRoaXMuc2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHhWYWx1ZXMpO1xuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluIHx8IHRoaXMuZ2V0WERvbWFpbih4VmFsdWVzKTtcbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHR3b1BJKTtcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIHRoaXMub3V0ZXJSYWRpdXMpO1xuICAgICAgICB0aGlzLnlBeGlzU2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4ucmV2ZXJzZSgpLCB0aGlzLm91dGVyUmFkaXVzKTtcbiAgICB9O1xuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldFRpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGlja0Zvcm1hdDtcbiAgICAgICAgaWYgKHRoaXMueEF4aXNUaWNrRm9ybWF0dGluZykge1xuICAgICAgICAgICAgdGlja0Zvcm1hdCA9IHRoaXMueEF4aXNUaWNrRm9ybWF0dGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnhTY2FsZS50aWNrRm9ybWF0KSB7XG4gICAgICAgICAgICB0aWNrRm9ybWF0ID0gdGhpcy54U2NhbGUudGlja0Zvcm1hdC5hcHBseSh0aGlzLnhTY2FsZSwgWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tGb3JtYXQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGUoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgICAgIHZhciBzID0gMS4xO1xuICAgICAgICB0aGlzLnRoZXRhVGlja3MgPSB0aGlzLnhEb21haW4ubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IF90aGlzLnhTY2FsZShkKTtcbiAgICAgICAgICAgIHZhciBkZCA9IHMgKiBvdXRlclJhZGl1cyAqIChzdGFydEFuZ2xlID4gTWF0aC5QSSA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB0aWNrRm9ybWF0KGQpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0UG9zID0gW291dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSksIC1vdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpXTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBbZGQsIHMgKiBzdGFydFBvc1sxXV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgc3RhcnRQb3M6IHN0YXJ0UG9zLFxuICAgICAgICAgICAgICAgIHBvczogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMTA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aGV0YVRpY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnRoZXRhVGlja3NbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCB0aGlzLnRoZXRhVGlja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMudGhldGFUaWNrc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoYi5wb3NbMF0gKiBhLnBvc1swXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBtaW5EaXN0YW5jZSAtIE1hdGguYWJzKGIucG9zWzFdIC0gYS5wb3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucG9zWzFdICs9IE1hdGguc2lnbihiLnBvc1swXSkgKiBvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmFkaXVzVGlja3MgPSB0aGlzLnlBeGlzU2NhbGUudGlja3MoTWF0aC5mbG9vcih0aGlzLmRpbXMuaGVpZ2h0IC8gNTApKS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkKTsgfSk7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gdGhpcy5nZXRYVmFsdWVzKCk7IH1cbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE51bWJlcih2KTsgfSk7XG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLnZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLm1pbikgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLm1pbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGQubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi5pbmRleE9mKGQubWF4KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubWF4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WURvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcbiAgICAgICAgaWYgKGRvbWFpbiA9PT0gdm9pZCAwKSB7IGRvbWFpbiA9IHRoaXMuZ2V0WVZhbHVlcygpOyB9XG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkb21haW4pO1xuICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgW3RoaXMueUF4aXNNaW5TY2FsZV0uY29uY2F0KGRvbWFpbikpO1xuICAgICAgICBtaW4kJDEgPSBNYXRoLm1heCgwLCBtaW4kJDEpO1xuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlKSB7XG4gICAgICAgICAgICBtaW4kJDEgPSBNYXRoLm1pbigwLCBtaW4kJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xuICAgIH07XG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcbiAgICB9O1xuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zY2FsZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZVRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xuICAgICAgICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZVBvaW50KClcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aCAtIHR3b1BJIC8gZG9tYWluLmxlbmd0aF0pXG4gICAgICAgICAgICAgICAgICAgIC5wYWRkaW5nKDApXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSlcbiAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllcykge1xuICAgICAgICBpZiAoc2VyaWVzKSB7XG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IHNlcmllcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb21haW4gPSB0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJyA/IHRoaXMuc2VyaWVzRG9tYWluIDogdGhpcy55RG9tYWluLnJldmVyc2UoKTtcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXG4gICAgICAgICAgICAgICAgY29sb3JzOiB0aGlzLmNvbG9ycyxcbiAgICAgICAgICAgICAgICBkb21haW46IHRoaXMuc2VyaWVzRG9tYWluLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxlZ2VuZFRpdGxlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcbiAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMuc2NhbGUsXG4gICAgICAgICAgICBkb21haW46IHRoaXMueURvbWFpbixcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9O1xuICAgIH07XG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuc2hvd1Nlcmllc09uSG92ZXIgPyBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcykgOiB0aGlzLmFjdGl2ZUVudHJpZXM7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYWN0aXZlRW50cmllczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICB9O1xuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXV0b1NjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1Nlcmllc09uSG92ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc01pblNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVNpemVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgUG9sYXJDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLXBvbGFyLWNoYXJ0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBjbGFzcz1cXFwicG9sYXItY2hhcnQgY2hhcnRcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtUGxvdFxcXCI+XFxuICAgICAgICAgIDxzdmc6Y2lyY2xlIGNsYXNzPVxcXCJwb2xhci1jaGFydC1iYWNrZ3JvdW5kXFxcIiBjeD1cXFwiMFxcXCIgY3k9XFxcIjBcXFwiIFthdHRyLnJdPVxcXCJ0aGlzLm91dGVyUmFkaXVzXFxcIiAvPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcInNob3dHcmlkTGluZXNcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Y2lyY2xlXFxuICAgICAgICAgICAgICAqbmdGb3I9XFxcImxldCByIG9mIHJhZGl1c1RpY2tzXFxcIlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcImdyaWRsaW5lLXBhdGggcmFkaWFsLWdyaWRsaW5lLXBhdGhcXFwiXFxuICAgICAgICAgICAgICBjeD1cXFwiMFxcXCJcXG4gICAgICAgICAgICAgIGN5PVxcXCIwXFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIucl09XFxcInJcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJ4QXhpc1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXBpZS1sYWJlbFxcbiAgICAgICAgICAgICAgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aGV0YVRpY2tzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJ0aWNrXFxcIlxcbiAgICAgICAgICAgICAgW3JhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgICAgW2xhYmVsXT1cXFwidGljay5sYWJlbFxcXCJcXG4gICAgICAgICAgICAgIFttYXhdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICAgIFt2YWx1ZV09XFxcInNob3dHcmlkTGluZXMgPyAxIDogb3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgICBbZXhwbG9kZVNsaWNlc109XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgICBbbGFiZWxUcmltXT1cXFwibGFiZWxUcmltXFxcIlxcbiAgICAgICAgICAgICAgW2xhYmVsVHJpbVNpemVdPVxcXCJsYWJlbFRyaW1TaXplXFxcIlxcbiAgICAgICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1ZQXhpc1xcXCJcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieUF4aXNTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJ5QXhpc0RpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpcyAmJiBzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsXT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW29mZnNldF09XFxcImxhYmVsT2Zmc2V0XFxcIlxcbiAgICAgICAgICBbb3JpZW50XT1cXFwiJ2JvdHRvbSdcXFwiXFxuICAgICAgICAgIFtoZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVBsb3RcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXBvbGFyLXNlcmllc1xcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICAgIFtyYW5nZUZpbGxPcGFjaXR5XT1cXFwicmFuZ2VGaWxsT3BhY2l0eVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcbiAgICAgICAgICAgICAgICBcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsXG4gICAgICAgICAgICAgICAgXCIucGllLWxhYmVse2ZvbnQtc2l6ZToxMXB4fS5waWUtbGFiZWwuYW5pbWF0aW9ue2FuaW1hdGlvbjo3NTBtcyBlYXNlLWluIGZhZGVJbn1Aa2V5ZnJhbWVzIGZhZGVJbntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fS5waWUtbGFiZWwtbGluZXtzdHJva2UtZGFzaGFycmF5OjEwMCV9LnBpZS1sYWJlbC1saW5lLmFuaW1hdGlvbnthbmltYXRpb246M3MgbGluZWFyIGRyYXdPdXQ7dHJhbnNpdGlvbjpkIDc1MG1zfUBrZXlmcmFtZXMgZHJhd091dHtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjEwMCV9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MH19XCIsXG4gICAgICAgICAgICAgICAgXCIucG9sYXItY2hhcnQgLnBvbGFyLWNoYXJ0LWJhY2tncm91bmR7ZmlsbDpub25lfS5wb2xhci1jaGFydCAucmFkaWFsLWdyaWRsaW5lLXBhdGh7c3Ryb2tlLWRhc2hhcnJheToxMCAxMDtmaWxsOm5vbmV9LnBvbGFyLWNoYXJ0IC5waWUtbGFiZWwtbGluZXtzdHJva2U6IzJmMzY0Nn0ucG9sYXItY2hhcnRzLXNlcmllcyAucG9sYXItc2VyaWVzLWFyZWF7cG9pbnRlci1ldmVudHM6bm9uZX0ucG9sYXItc2VyaWVzLXBhdGh7cG9pbnRlci1ldmVudHM6bm9uZX1cIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQpO1xuICAgIHJldHVybiBQb2xhckNoYXJ0Q29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIFBvbGFyU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbGFyU2VyaWVzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2lyY2xlUmFkaXVzID0gMztcbiAgICB9XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudXBkYXRlR3JhZGllbnRzKCk7XG4gICAgICAgIHZhciBsaW5lJCQxID0gdGhpcy5nZXRMaW5lR2VuZXJhdG9yKCk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zb3J0RGF0YSh0aGlzLmRhdGEuc2VyaWVzKTtcbiAgICAgICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmRhdGEubmFtZTtcbiAgICAgICAgdmFyIGxpbmVhclNjYWxlVHlwZSA9IHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcic7XG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZS5kb21haW4oKVswXTtcbiAgICAgICAgdGhpcy5zZXJpZXNDb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKGxpbmVhclNjYWxlVHlwZSA/IG1pbiQkMSA6IHNlcmllc05hbWUpO1xuICAgICAgICB0aGlzLnBhdGggPSBsaW5lJCQxKGRhdGEpIHx8ICcnO1xuICAgICAgICB0aGlzLmNpcmNsZXMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGEgPSBfdGhpcy5nZXRBbmdsZShkKTtcbiAgICAgICAgICAgIHZhciByID0gX3RoaXMuZ2V0UmFkaXVzKGQpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihsaW5lYXJTY2FsZVR5cGUgPyBNYXRoLmFicyh2YWx1ZSkgOiBzZXJpZXNOYW1lKTtcbiAgICAgICAgICAgIHZhciBjRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGQsIHtcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllc05hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG5hbWU6IGQubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGNEYXRhLFxuICAgICAgICAgICAgICAgIGN4OiByICogTWF0aC5zaW4oYSksXG4gICAgICAgICAgICAgICAgY3k6IC1yICogTWF0aC5jb3MoYSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBsYWJlbDogZC5uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMuaW5hY3RpdmUgPSB0aGlzLmlzSW5hY3RpdmUodGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy50b29sdGlwVGV4dCA9IHRoaXMudG9vbHRpcFRleHQgfHwgKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5kZWZhdWx0VG9vbHRpcFRleHQoYyk7IH0pO1xuICAgIH07XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueFNjYWxlKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy54U2NhbGUobGFiZWwpO1xuICAgIH07XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnlTY2FsZShkLnZhbHVlKTtcbiAgICB9O1xuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMaW5lR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbGluZVJhZGlhbCgpXG4gICAgICAgICAgICAuYW5nbGUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdldEFuZ2xlKGQpOyB9KVxuICAgICAgICAgICAgLnJhZGl1cyhmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuZ2V0UmFkaXVzKGQpOyB9KVxuICAgICAgICAgICAgLmN1cnZlKHRoaXMuY3VydmUpO1xuICAgIH07XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnNvcnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3J0QnlEb21haW4oZGF0YSwgJ25hbWUnLCAnYXNjJywgdGhpcy54U2NhbGUuZG9tYWluKCkpO1xuICAgIH07XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0luYWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzIHx8IHRoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmRlZmF1bHRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgZXNjYXBlTGFiZWwodGhpcy5kYXRhLm5hbWUpICsgXCIgXFx1MjAyMiBcIiArIGVzY2FwZUxhYmVsKGxhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgXCI8L3NwYW4+XFxuICAgIFwiO1xuICAgIH07XG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUdyYWRpZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRoaXMuZ3JhZGllbnQgfHwgdGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnbGluZWFyJztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0dyYWRpZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmdyYWRpZW50VXJsID0gXCJ1cmwoI1wiICsgdGhpcy5ncmFkaWVudElkICsgXCIpXCI7XG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMobWF4JCQxLCBtaW4kJDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBQb2xhclNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcG9sYXItc2VyaWVzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIGNsYXNzPVxcXCJwb2xhci1jaGFydHMtc2VyaWVzXFxcIj5cXG4gICAgICA8ZGVmcz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXN2Zy1yYWRpYWwtZ3JhZGllbnRcXG4gICAgICAgICAgKm5nSWY9XFxcImhhc0dyYWRpZW50XFxcIlxcbiAgICAgICAgICBvcmllbnRhdGlvbj1cXFwidmVydGljYWxcXFwiXFxuICAgICAgICAgIFtjb2xvcl09XFxcInNlcmllc0NvbG9yXFxcIlxcbiAgICAgICAgICBbbmFtZV09XFxcImdyYWRpZW50SWRcXFwiXFxuICAgICAgICAgIFtzdGFydE9wYWNpdHldPVxcXCIwLjI1XFxcIlxcbiAgICAgICAgICBbZW5kT3BhY2l0eV09XFxcIjFcXFwiXFxuICAgICAgICAgIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvZGVmcz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtbGluZVxcbiAgICAgICAgY2xhc3M9XFxcInBvbGFyLXNlcmllcy1wYXRoXFxcIlxcbiAgICAgICAgW3BhdGhdPVxcXCJwYXRoXFxcIlxcbiAgICAgICAgW3N0cm9rZV09XFxcImhhc0dyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBzZXJpZXNDb2xvclxcXCJcXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJhY3RpdmVcXFwiXFxuICAgICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpbmFjdGl2ZVxcXCJcXG4gICAgICAgIFthdHRyLmZpbGwtb3BhY2l0eV09XFxcInJhbmdlRmlsbE9wYWNpdHlcXFwiXFxuICAgICAgICBbZmlsbF09XFxcImhhc0dyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBzZXJpZXNDb2xvclxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGVcXG4gICAgICAgICpuZ0Zvcj1cXFwibGV0IGNpcmNsZSBvZiBjaXJjbGVzXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNpcmNsZVxcXCJcXG4gICAgICAgIFtjeF09XFxcImNpcmNsZS5jeFxcXCJcXG4gICAgICAgIFtjeV09XFxcImNpcmNsZS5jeVxcXCJcXG4gICAgICAgIFtyXT1cXFwiY2lyY2xlUmFkaXVzXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJjaXJjbGUuY29sb3JcXFwiXFxuICAgICAgICBbc3R5bGUub3BhY2l0eV09XFxcImluYWN0aXZlID8gMC4yIDogMVxcXCJcXG4gICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICAgIHRvb2x0aXBUeXBlPVxcXCJ0b29sdGlwXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IHRvb2x0aXBUZXh0KGNpcmNsZSlcXFwiXFxuICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwiY2lyY2xlLmRhdGFcXFwiXFxuICAgICAgICAoc2VsZWN0KT1cXFwic2VsZWN0LmVtaXQoY2lyY2xlLmRhdGEpXFxcIlxcbiAgICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUuZW1pdCh7IG5hbWU6IGNpcmNsZS5kYXRhLnNlcmllcyB9KVxcXCJcXG4gICAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KHsgbmFtZTogY2lyY2xlLmRhdGEuc2VyaWVzIH0pXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gUG9sYXJTZXJpZXNDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnVG90YWwnO1xuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzIwLCAyMCwgMjAsIDIwXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiAodGhpcy53aWR0aCAqIDQpIC8gMTIuMCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5kaW1zLndpZHRoIC8gMjtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSB0aGlzLm1hcmdpblswXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyO1xuICAgICAgICB0aGlzLmxlZ2VuZFdpZHRoID0gdGhpcy53aWR0aCAtIHRoaXMuZGltcy53aWR0aCAtIHRoaXMubWFyZ2luWzFdO1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5kaW1zLndpZHRoLCB0aGlzLmRpbXMuaGVpZ2h0KSAvIDIuNTtcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgKiAwLjc1O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeE9mZnNldCArIFwiICwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XG4gICAgfTtcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmxhYmVsOyB9KTtcbiAgICB9O1xuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLmRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicGVyY2VudGFnZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYWR2YW5jZWQtcGllLWNoYXJ0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2IFtzdHlsZS53aWR0aC5weF09XFxcIndpZHRoXFxcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cXFwiaGVpZ2h0XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJhZHZhbmNlZC1waWUgY2hhcnRcXFwiIFtzdHlsZS53aWR0aC5weF09XFxcImRpbXMud2lkdGhcXFwiIFtzdHlsZS5oZWlnaHQucHhdPVxcXCJkaW1zLmhlaWdodFxcXCI+XFxuICAgICAgICA8bmd4LWNoYXJ0cy1jaGFydCBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCIgW3Nob3dMZWdlbmRdPVxcXCJmYWxzZVxcXCIgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcInBpZSBjaGFydFxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXBpZS1zZXJpZXNcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbc2VyaWVzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgICAgIFtpbm5lclJhZGl1c109XFxcImlubmVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW291dGVyUmFkaXVzXT1cXFwib3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZXh0XT1cXFwidG9vbHRpcFRleHRcXFwiXFxuICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJhZHZhbmNlZC1waWUtbGVnZW5kLXdyYXBwZXJcXFwiIFtzdHlsZS53aWR0aC5weF09XFxcIndpZHRoIC0gZGltcy53aWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcImhlaWdodFxcXCI+XFxuICAgICAgICA8bmd4LWNoYXJ0cy1hZHZhbmNlZC1sZWdlbmRcXG4gICAgICAgICAgW2RhdGFdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbd2lkdGhdPVxcXCJ3aWR0aCAtIGRpbXMud2lkdGggLSBtYXJnaW5bMV1cXFwiXFxuICAgICAgICAgIFtsYWJlbF09XFxcImxhYmVsXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtsYWJlbEZvcm1hdHRpbmddPVxcXCJuYW1lRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3BlcmNlbnRhZ2VGb3JtYXR0aW5nXT1cXFwicGVyY2VudGFnZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgIDwvbmd4LWNoYXJ0cy1hZHZhbmNlZC1sZWdlbmQ+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLmFkdmFuY2VkLXBpZXtkaXNwbGF5OmlubGluZS1ibG9jaztmbG9hdDpsZWZ0fS5hZHZhbmNlZC1waWUtbGVnZW5kLXdyYXBwZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2t9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCk7XG4gICAgcmV0dXJuIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgUGllTGFiZWxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGllTGFiZWxDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFiZWxUcmltID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYWJlbFRyaW1TaXplID0gMTA7XG4gICAgICAgIHRoaXMuaXNJRSA9IC8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgdGhpcy50cmltTGFiZWwgPSB0cmltTGFiZWw7XG4gICAgfVxuICAgIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnRSYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgaWYgKHRoaXMuZXhwbG9kZVNsaWNlcykge1xuICAgICAgICAgICAgc3RhcnRSYWRpdXMgPSB0aGlzLnJhZGl1cyAqIHRoaXMudmFsdWUgLyB0aGlzLm1heDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJBcmMgPSBhcmMoKVxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHN0YXJ0UmFkaXVzKVxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHN0YXJ0UmFkaXVzKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGlubmVyUG9zIHRoZW4gc2NhbGUgb3V0ZXIgcG9zaXRpb24gdG8gbWF0Y2ggbGFiZWwgcG9zaXRpb25cbiAgICAgICAgdmFyIGlubmVyUG9zID0gaW5uZXJBcmMuY2VudHJvaWQodGhpcy5kYXRhKTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5kYXRhLnBvc1sxXSAvIGlubmVyUG9zWzFdO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnBvc1sxXSA9PT0gMCB8fCBpbm5lclBvc1sxXSA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRlclBvcyA9IFtzY2FsZSAqIGlubmVyUG9zWzBdLCBzY2FsZSAqIGlubmVyUG9zWzFdXTtcbiAgICAgICAgdGhpcy5saW5lID0gXCJNXCIgKyBpbm5lclBvcyArIFwiTFwiICsgb3V0ZXJQb3MgKyBcIkxcIiArIHRoaXMuZGF0YS5wb3M7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRYXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnBvc1swXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0WVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5wb3NbMV07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwic3R5bGVUcmFuc2Zvcm1cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzSUUgPyBudWxsIDogXCJ0cmFuc2xhdGUzZChcIiArIHRoaXMudGV4dFggKyBcInB4LFwiICsgdGhpcy50ZXh0WSArIFwicHgsIDApXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXR0clRyYW5zZm9ybVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzSUUgPyBudWxsIDogXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnRleHRYICsgXCIsXCIgKyB0aGlzLnRleHRZICsgXCIpXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dFRyYW5zaXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzSUUgfHwgIXRoaXMuYW5pbWF0aW9ucyA/IG51bGwgOiAndHJhbnNmb3JtIDAuNzVzJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLnRleHRBbmNob3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pZEFuZ2xlKHRoaXMuZGF0YSkgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgIH07XG4gICAgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLm1pZEFuZ2xlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDI7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGxvZGVTbGljZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFRyaW1TaXplXCIsIHZvaWQgMCk7XG4gICAgUGllTGFiZWxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1sYWJlbF0nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDx0aXRsZT57e2xhYmVsfX08L3RpdGxlPlxcbiAgICA8c3ZnOmdcXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJhdHRyVHJhbnNmb3JtXFxcIlxcbiAgICAgIFtzdHlsZS50cmFuc2Zvcm1dPVxcXCJzdHlsZVRyYW5zZm9ybVxcXCJcXG4gICAgICBbc3R5bGUudHJhbnNpdGlvbl09XFxcInRleHRUcmFuc2l0aW9uXFxcIj5cXG4gICAgICA8c3ZnOnRleHRcXG4gICAgICAgIGNsYXNzPVxcXCJwaWUtbGFiZWxcXFwiXFxuICAgICAgICBbY2xhc3MuYW5pbWF0aW9uXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgIGR5PVxcXCIuMzVlbVxcXCJcXG4gICAgICAgIFtzdHlsZS50ZXh0QW5jaG9yXT1cXFwidGV4dEFuY2hvcigpXFxcIlxcbiAgICAgICAgW3N0eWxlLnNoYXBlUmVuZGVyaW5nXT1cXFwiJ2NyaXNwRWRnZXMnXFxcIj5cXG4gICAgICAgIHt7bGFiZWxUcmltID8gdHJpbUxhYmVsKGxhYmVsLCBsYWJlbFRyaW1TaXplKSA6IGxhYmVsfX1cXG4gICAgICA8L3N2Zzp0ZXh0PlxcbiAgICA8L3N2ZzpnPlxcbiAgICA8c3ZnOnBhdGhcXG4gICAgICBbYXR0ci5kXT1cXFwibGluZVxcXCJcXG4gICAgICBbYXR0ci5zdHJva2VdPVxcXCJjb2xvclxcXCJcXG4gICAgICBmaWxsPVxcXCJub25lXFxcIlxcbiAgICAgIGNsYXNzPVxcXCJwaWUtbGFiZWwtbGluZSBsaW5lXFxcIlxcbiAgICAgIFtjbGFzcy5hbmltYXRpb25dPVxcXCJhbmltYXRpb25zXFxcIj5cXG4gICAgPC9zdmc6cGF0aD5cXG4gIFwiLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudCk7XG4gICAgcmV0dXJuIFBpZUxhYmVsQ29tcG9uZW50O1xufSgpKTtcblxudmFyIFBpZUFyY0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQaWVBcmNDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICAgICAgdGhpcy5leHBsb2RlU2xpY2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb2ludGVyRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRibGNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFkaWVudCA/IHRoaXMuZ3JhZGllbnRGaWxsIDogdGhpcy5maWxsO1xuICAgIH07XG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5nZXRQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyRXZlbnRzID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIH07XG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxjID0gdGhpcy5jYWxjdWxhdGVBcmMoKTtcbiAgICAgICAgdGhpcy5zdGFydE9wYWNpdHkgPSAwLjU7XG4gICAgICAgIHRoaXMucmFkaWFsR3JhZGllbnRJZCA9ICdsaW5lYXJHcmFkJyArIGlkKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLnJhZGlhbEdyYWRpZW50SWQgKyBcIilcIjtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBjYWxjLnN0YXJ0QW5nbGUodGhpcy5zdGFydEFuZ2xlKS5lbmRBbmdsZSh0aGlzLmVuZEFuZ2xlKSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUFyYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cztcbiAgICAgICAgaWYgKHRoaXMuZXhwbG9kZVNsaWNlcyAmJiB0aGlzLmlubmVyUmFkaXVzID09PSAwKSB7XG4gICAgICAgICAgICBvdXRlclJhZGl1cyA9ICh0aGlzLm91dGVyUmFkaXVzICogdGhpcy52YWx1ZSkgLyB0aGlzLm1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJjKClcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyh0aGlzLmlubmVyUmFkaXVzKVxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKVxuICAgICAgICAgICAgLmNvcm5lclJhZGl1cyh0aGlzLmNvcm5lclJhZGl1cyk7XG4gICAgfTtcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudClcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5hcmMnKVxuICAgICAgICAgICAgLmRhdGEoW3sgc3RhcnRBbmdsZTogdGhpcy5zdGFydEFuZ2xlLCBlbmRBbmdsZTogdGhpcy5lbmRBbmdsZSB9XSk7XG4gICAgICAgIHZhciBjYWxjID0gdGhpcy5jYWxjdWxhdGVBcmMoKTtcbiAgICAgICAgbm9kZVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHJUd2VlbignZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xuICAgICAgICAgICAgdmFyIGNvcHlPZkQgPSBPYmplY3QuYXNzaWduKHt9LCBkKTtcbiAgICAgICAgICAgIGNvcHlPZkQuZW5kQW5nbGUgPSBjb3B5T2ZELnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUoY29weU9mRCwgY29weU9mRCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxuICAgICAgICAgICAgLmF0dHJUd2VlbignZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlciA9IGludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlcigwKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjKGludGVycG9sYXRlcih0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCcuYXJjJylcbiAgICAgICAgICAgIC5kYXRhKFt7IHN0YXJ0QW5nbGU6IHRoaXMuc3RhcnRBbmdsZSwgZW5kQW5nbGU6IHRoaXMuZW5kQW5nbGUgfV0pO1xuICAgICAgICB2YXIgY2FsYyA9IHRoaXMuY2FsY3VsYXRlQXJjKCk7XG4gICAgICAgIG5vZGVcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9jdXJyZW50IHx8IGQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdC5lbWl0KF90aGlzLmRhdGEpOyB9LCAyMDApO1xuICAgIH07XG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5vbkRibENsaWNrID0gZnVuY3Rpb24gKGV2ZW50JCQxKSB7XG4gICAgICAgIGV2ZW50JCQxLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50JCQxLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgIHRoaXMuZGJsY2xpY2suZW1pdCh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQkJDFcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwicG9pbnRlckV2ZW50c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGJsY2xpY2tcIiwgdm9pZCAwKTtcbiAgICBQaWVBcmNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1hcmNdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgY2xhc3M9XFxcImFyYy1ncm91cFxcXCI+XFxuICAgICAgPHN2ZzpkZWZzICpuZ0lmPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1zdmctcmFkaWFsLWdyYWRpZW50XFxuICAgICAgICAgIFtjb2xvcl09XFxcImZpbGxcXFwiXFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJyYWRpYWxHcmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RhcnRPcGFjaXR5XT1cXFwic3RhcnRPcGFjaXR5XFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6cGF0aFxcbiAgICAgICAgW2F0dHIuZF09XFxcInBhdGhcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiYXJjXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlXFxcIlxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdldEdyYWRpZW50KClcXFwiXFxuICAgICAgICAoY2xpY2spPVxcXCJvbkNsaWNrKClcXFwiXFxuICAgICAgICAoZGJsY2xpY2spPVxcXCJvbkRibENsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAobW91c2VlbnRlcik9XFxcImFjdGl2YXRlLmVtaXQoZGF0YSlcXFwiXFxuICAgICAgICAobW91c2VsZWF2ZSk9XFxcImRlYWN0aXZhdGUuZW1pdChkYXRhKVxcXCJcXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XFxcImdldFBvaW50ZXJFdmVudHMoKVxcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBQaWVBcmNDb21wb25lbnQpO1xuICAgIHJldHVybiBQaWVBcmNDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgUGllQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpZUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBpZUNoYXJ0Q29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGFiZWxzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIF90aGlzLmV4cGxvZGVTbGljZXMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZG91Z2hudXQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuYXJjV2lkdGggPSAwLjI1O1xuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50cmltTGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubWF4TGFiZWxMZW5ndGggPSAxMDtcbiAgICAgICAgX3RoaXMuZGJsY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxzICYmIHRoaXMuaGFzTm9PcHRpb25hbE1hcmdpbnNTZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5tYXJnaW5zID0gWzMwLCA4MCwgMzAsIDgwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5sYWJlbHMgJiYgdGhpcy5oYXNOb09wdGlvbmFsTWFyZ2luc1NldCgpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmdpbnMgPSBbMjAsIDIwLCAyMCwgMjBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2lucyxcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLm1hcmdpbnNbM10gKyB0aGlzLmRpbXMud2lkdGggLyAyO1xuICAgICAgICB2YXIgeU9mZnNldCA9IHRoaXMubWFyZ2luc1swXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUoXCIgKyB4T2Zmc2V0ICsgXCIsIFwiICsgeU9mZnNldCArIFwiKVwiO1xuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5kaW1zLndpZHRoLCB0aGlzLmRpbXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxzKSB7XG4gICAgICAgICAgICB0aGlzLm91dGVyUmFkaXVzIC89IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm91dGVyUmFkaXVzIC89IDI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmRvdWdobnV0KSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAqICgxIC0gdGhpcy5hcmNXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRvbWFpbi5pbmRleE9mKGEubmFtZSkgLSBfdGhpcy5kb21haW4uaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XG4gICAgfTtcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XG4gICAgfTtcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLmRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2FsZVR5cGU6ICdvcmRpbmFsJyxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5kb21haW4sXG4gICAgICAgICAgICBjb2xvcnM6IHRoaXMuY29sb3JzLFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMubGVnZW5kVGl0bGUsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxuICAgICAgICB9O1xuICAgIH07XG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmhhc05vT3B0aW9uYWxNYXJnaW5zU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubWFyZ2lucyB8fCB0aGlzLm1hcmdpbnMubGVuZ3RoIDw9IDA7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRvdWdobnV0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFyY1dpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1MYWJlbHNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4TGFiZWxMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRibGNsaWNrXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIFBpZUNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtcGllLWNoYXJ0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2xhdGlvblxcXCIgY2xhc3M9XFxcInBpZS1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1waWUtc2VyaWVzXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFtzZXJpZXNdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsc109XFxcImxhYmVsc1xcXCJcXG4gICAgICAgICAgW2xhYmVsRm9ybWF0dGluZ109XFxcImxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RyaW1MYWJlbHNdPVxcXCJ0cmltTGFiZWxzXFxcIlxcbiAgICAgICAgICBbbWF4TGFiZWxMZW5ndGhdPVxcXCJtYXhMYWJlbExlbmd0aFxcXCJcXG4gICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJpbm5lclJhZGl1c1xcXCJcXG4gICAgICAgICAgW291dGVyUmFkaXVzXT1cXFwib3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICAgIFtleHBsb2RlU2xpY2VzXT1cXFwiZXhwbG9kZVNsaWNlc1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZXh0XT1cXFwidG9vbHRpcFRleHRcXFwiXFxuICAgICAgICAgIChkYmxjbGljayk9XFxcImRibGNsaWNrLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIucGllLWxhYmVse2ZvbnQtc2l6ZToxMXB4fS5waWUtbGFiZWwuYW5pbWF0aW9ue2FuaW1hdGlvbjo3NTBtcyBlYXNlLWluIGZhZGVJbn1Aa2V5ZnJhbWVzIGZhZGVJbntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fS5waWUtbGFiZWwtbGluZXtzdHJva2UtZGFzaGFycmF5OjEwMCV9LnBpZS1sYWJlbC1saW5lLmFuaW1hdGlvbnthbmltYXRpb246M3MgbGluZWFyIGRyYXdPdXQ7dHJhbnNpdGlvbjpkIDc1MG1zfUBrZXlmcmFtZXMgZHJhd091dHtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjEwMCV9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MH19XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQpO1xuICAgIHJldHVybiBQaWVDaGFydENvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIGdyaWRTaXplKGRpbXMsIGxlbiwgbWluV2lkdGgpIHtcbiAgICB2YXIgcm93cyA9IDE7XG4gICAgdmFyIGNvbHMgPSBsZW47XG4gICAgdmFyIHdpZHRoID0gZGltcy53aWR0aDtcbiAgICBpZiAod2lkdGggPiBtaW5XaWR0aCkge1xuICAgICAgICB3aGlsZSAod2lkdGggLyBjb2xzIDwgbWluV2lkdGgpIHtcbiAgICAgICAgICAgIHJvd3MgKz0gMTtcbiAgICAgICAgICAgIGNvbHMgPSBNYXRoLmNlaWwobGVuIC8gcm93cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjb2xzLCByb3dzXTtcbn1cbmZ1bmN0aW9uIGdyaWRMYXlvdXQoZGltcywgZGF0YSwgbWluV2lkdGgsIGRlc2lnbmF0ZWRUb3RhbCkge1xuICAgIHZhciB4U2NhbGUgPSBzY2FsZUJhbmQoKTtcbiAgICB2YXIgeVNjYWxlID0gc2NhbGVCYW5kKCk7XG4gICAgdmFyIHdpZHRoID0gZGltcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gZGltcy5oZWlnaHQ7XG4gICAgdmFyIF9hID0gZ3JpZFNpemUoZGltcywgZGF0YS5sZW5ndGgsIG1pbldpZHRoKSwgY29sdW1ucyA9IF9hWzBdLCByb3dzID0gX2FbMV07XG4gICAgdmFyIHhEb21haW4gPSBbXTtcbiAgICB2YXIgeURvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIHlEb21haW4ucHVzaChpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zOyBpKyspIHtcbiAgICAgICAgeERvbWFpbi5wdXNoKGkpO1xuICAgIH1cbiAgICB4U2NhbGUuZG9tYWluKHhEb21haW4pO1xuICAgIHlTY2FsZS5kb21haW4oeURvbWFpbik7XG4gICAgeFNjYWxlLnJhbmdlUm91bmQoWzAsIHdpZHRoXSwgMC4xKTtcbiAgICB5U2NhbGUucmFuZ2VSb3VuZChbMCwgaGVpZ2h0XSwgMC4xKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIHRvdGFsID0gZGVzaWduYXRlZFRvdGFsID8gZGVzaWduYXRlZFRvdGFsIDogZ2V0VG90YWwoZGF0YSk7XG4gICAgdmFyIGNhcmRXaWR0aCA9IHhTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICB2YXIgY2FyZEhlaWdodCA9IHlTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0ge307XG4gICAgICAgIHJlc1tpXS5kYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogZGF0YVtpXSA/IGRhdGFbaV0ubmFtZSA6ICcnLFxuICAgICAgICAgICAgdmFsdWU6IGRhdGFbaV0gPyBkYXRhW2ldLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXh0cmE6IGRhdGFbaV0gPyBkYXRhW2ldLmV4dHJhIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFiZWw6IGRhdGFbaV0gPyBkYXRhW2ldLmxhYmVsIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgcmVzW2ldLnggPSB4U2NhbGUoaSAlIGNvbHVtbnMpO1xuICAgICAgICByZXNbaV0ueSA9IHlTY2FsZShNYXRoLmZsb29yKGkgLyBjb2x1bW5zKSk7XG4gICAgICAgIHJlc1tpXS53aWR0aCA9IGNhcmRXaWR0aDtcbiAgICAgICAgcmVzW2ldLmhlaWdodCA9IGNhcmRIZWlnaHQ7XG4gICAgICAgIHJlc1tpXS5kYXRhLnBlcmNlbnQgPSB0b3RhbCA+IDAgPyByZXNbaV0uZGF0YS52YWx1ZSAvIHRvdGFsIDogMDtcbiAgICAgICAgcmVzW2ldLmRhdGEudG90YWwgPSB0b3RhbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldFRvdGFsKHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkID8gZC52YWx1ZSA6IDApOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgdmFsKSB7IHJldHVybiBzdW0gKyB2YWw7IH0sIDApO1xufVxuXG52YXIgUGllR3JpZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGllR3JpZENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaWVHcmlkQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxhYmVsID0gJ1RvdGFsJztcbiAgICAgICAgX3RoaXMubWluV2lkdGggPSAxNTA7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsyMCwgMjAsIDIwLCAyMF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGdyaWRMYXlvdXQodGhpcy5kaW1zLCB0aGlzLnJlc3VsdHMsIHRoaXMubWluV2lkdGgsIHRoaXMuZGVzaWduYXRlZFRvdGFsKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMubWFyZ2luWzNdICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgICAgIHRoaXMuc2VyaWVzID0gdGhpcy5nZXRTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdGhpcy50b29sdGlwVGV4dCA9IHRoaXMudG9vbHRpcFRleHQgfHwgdGhpcy5kZWZhdWx0VG9vbHRpcFRleHQ7XG4gICAgfTtcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5kZWZhdWx0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICB2YXIgbGFiZWwgPSB0cmltTGFiZWwoZm9ybWF0TGFiZWwoZGF0YS5uYW1lKSk7XG4gICAgICAgIHZhciB2YWwgPSBkYXRhLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGxhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbCArIFwiPC9zcGFuPlxcbiAgICBcIjtcbiAgICB9O1xuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubGFiZWw7IH0pO1xuICAgIH07XG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmRlc2lnbmF0ZWRUb3RhbCA/IHRoaXMuZGVzaWduYXRlZFRvdGFsIDogdGhpcy5nZXRUb3RhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lTGFiZWxIZWlnaHQgPSAyMDtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gMTA7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGQuZGF0YS5uYW1lO1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZm9ybWF0TGFiZWwobmFtZSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLmRhdGEudmFsdWU7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gbWluKFtkLndpZHRoIC0gcGFkZGluZywgZC5oZWlnaHQgLSBiYXNlbGluZUxhYmVsSGVpZ2h0XSkgLyAyIC0gNTtcbiAgICAgICAgICAgIHZhciBpbm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuOTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgY29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgxMDAsMTAwLDEwMCwwLjMpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb2xvclNjYWxlLmdldENvbG9yKGxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHhQb3MgPSBkLnggKyAoZC53aWR0aCAtIHBhZGRpbmcpIC8gMjtcbiAgICAgICAgICAgIHZhciB5UG9zID0gZC55ICsgKGQuaGVpZ2h0IC0gYmFzZWxpbmVMYWJlbEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeFBvcyArIFwiLCBcIiArIHlQb3MgKyBcIilcIixcbiAgICAgICAgICAgICAgICBjb2xvcnM6IGNvbG9ycyxcbiAgICAgICAgICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0cmltTGFiZWwobGFiZWwpLFxuICAgICAgICAgICAgICAgIHRvdGFsOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcGVyY2VudDogZm9ybWF0KCcuMSUnKShkLmRhdGEucGVyY2VudCksXG4gICAgICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvdGFsIC0gdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5kYXRhLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VG90YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gc3VtICsgZDsgfSwgMCk7XG4gICAgfTtcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVzaWduYXRlZFRvdGFsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbldpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIFBpZUdyaWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1waWUtZ3JpZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiIFtzaG93TGVnZW5kXT1cXFwiZmFsc2VcXFwiIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCI+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcInBpZS1ncmlkIGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2Ygc2VyaWVzXFxcIiBjbGFzcz1cXFwicGllLWdyaWQtaXRlbVxcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwic2VyaWVzLnRyYW5zZm9ybVxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtcGllLWdyaWQtc2VyaWVzXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcInNlcmllcy5jb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXMuZGF0YVxcXCJcXG4gICAgICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJzZXJpZXMuaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgW291dGVyUmFkaXVzXT1cXFwic2VyaWVzLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdG9vbHRpcFRleHQoeyBkYXRhOiBzZXJpZXMgfSlcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJzZXJpZXMuZGF0YVswXS5kYXRhXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAqbmdJZj1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwibGFiZWwgcGVyY2VudC1sYWJlbFxcXCJcXG4gICAgICAgICAgICBkeT1cXFwiLTAuNWVtXFxcIlxcbiAgICAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgICAgeT1cXFwiNVxcXCJcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWNvdW50LXVwXFxuICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJzZXJpZXMucGVyY2VudFxcXCJcXG4gICAgICAgICAgICBbY291bnRTdWZmaXhdPVxcXCInJSdcXFwiXFxuICAgICAgICAgICAgdGV4dC1hbmNob3I9XFxcIm1pZGRsZVxcXCJcXG4gICAgICAgICAgPjwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDxzdmc6dGV4dCAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiIGNsYXNzPVxcXCJsYWJlbCBwZXJjZW50LWxhYmVsXFxcIiBkeT1cXFwiLTAuNWVtXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCI1XFxcIiB0ZXh0LWFuY2hvcj1cXFwibWlkZGxlXFxcIj5cXG4gICAgICAgICAgICB7eyBzZXJpZXMucGVyY2VudC50b0xvY2FsZVN0cmluZygpIH19XFxuICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDxzdmc6dGV4dCBjbGFzcz1cXFwibGFiZWxcXFwiIGR5PVxcXCIwLjVlbVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiNVxcXCIgdGV4dC1hbmNob3I9XFxcIm1pZGRsZVxcXCI+XFxuICAgICAgICAgICAge3sgc2VyaWVzLmxhYmVsIH19XFxuICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICpuZ0lmPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJsYWJlbFxcXCJcXG4gICAgICAgICAgICBkeT1cXFwiMS4yM2VtXFxcIlxcbiAgICAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgICAgW2F0dHIueV09XFxcInNlcmllcy5vdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICB0ZXh0LWFuY2hvcj1cXFwibWlkZGxlXFxcIlxcbiAgICAgICAgICAgIG5neC1jaGFydHMtY291bnQtdXBcXG4gICAgICAgICAgICBbY291bnRUb109XFxcInNlcmllcy50b3RhbFxcXCJcXG4gICAgICAgICAgICBbY291bnRQcmVmaXhdPVxcXCJsYWJlbCArICc6ICdcXFwiXFxuICAgICAgICAgID48L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImxhYmVsXFxcIlxcbiAgICAgICAgICAgIGR5PVxcXCIxLjIzZW1cXFwiXFxuICAgICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci55XT1cXFwic2VyaWVzLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIHRleHQtYW5jaG9yPVxcXCJtaWRkbGVcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICB7eyBsYWJlbCB9fToge3sgc2VyaWVzLnRvdGFsLnRvTG9jYWxlU3RyaW5nKCkgfX1cXG4gICAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLnBpZS1ncmlkIC5hcmMxe29wYWNpdHk6LjR9LnBpZS1ncmlkIC5wZXJjZW50LWxhYmVse2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0OjQwMH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50KTtcbiAgICByZXR1cm4gUGllR3JpZENvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbnZhciBQaWVHcmlkU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBpZUdyaWRTZXJpZXNDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gNzA7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSA4MDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gcGllKClcbiAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kYXRhLnZhbHVlOyB9KVxuICAgICAgICAgICAgLnNvcnQobnVsbCk7XG4gICAgICAgIHRoaXMuYXJjcyA9IHRoaXMuZ2V0QXJjcygpO1xuICAgIH07XG4gICAgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXJjcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0KHRoaXMuZGF0YSkubWFwKGZ1bmN0aW9uIChhcmMkJDEsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBhcmMkJDEuZGF0YS5kYXRhLm5hbWU7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBhcmMkJDEuZGF0YS5kYXRhLm90aGVyO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYXJjJCQxLnN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbG9yID0gX3RoaXMuY29sb3JzKGxhYmVsKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJjJCQxLmRhdGEuZGF0YSxcbiAgICAgICAgICAgICAgICBjbGFzczogJ2FyYyAnICsgJ2FyYycgKyBpbmRleCxcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBvdGhlciA/IDAgOiBhcmMkJDEuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogYXJjJCQxLmVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IF90aGlzLmFuaW1hdGlvbnMgJiYgIW90aGVyLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICFvdGhlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGFbMF0uZGF0YSk7XG4gICAgfTtcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGEubmFtZTtcbiAgICB9O1xuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gKGFyYyQkMSkge1xuICAgICAgICByZXR1cm4gYXJjJCQxLmRhdGEubmFtZTtcbiAgICB9O1xuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKGFyYyQkMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnModGhpcy5sYWJlbChhcmMkJDEpKTtcbiAgICB9O1xuICAgIHZhciBfYTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgUGllR3JpZFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcGllLWdyaWQtc2VyaWVzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIGNsYXNzPVxcXCJwaWUtZ3JpZC1hcmNzXFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtcGllLWFyY1xcbiAgICAgICAgKm5nRm9yPVxcXCJsZXQgYXJjIG9mIGFyY3M7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICBbYXR0ci5jbGFzc109XFxcImFyYy5jbGFzc1xcXCJcXG4gICAgICAgIFtzdGFydEFuZ2xlXT1cXFwiYXJjLnN0YXJ0QW5nbGVcXFwiXFxuICAgICAgICBbZW5kQW5nbGVdPVxcXCJhcmMuZW5kQW5nbGVcXFwiXFxuICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJpbm5lclJhZGl1c1xcXCJcXG4gICAgICAgIFtvdXRlclJhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJjb2xvcihhcmMpXFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYXJjLmRhdGEudmFsdWVcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImFyYy5kYXRhXFxcIlxcbiAgICAgICAgW2dyYWRpZW50XT1cXFwiZmFsc2VcXFwiXFxuICAgICAgICBbcG9pbnRlckV2ZW50c109XFxcImFyYy5wb2ludGVyRXZlbnRzXFxcIlxcbiAgICAgICAgW2FuaW1hdGVdPVxcXCJhcmMuYW5pbWF0ZVxcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gUGllR3JpZFNlcmllc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBQaWVTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGllU2VyaWVzQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gNjA7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSA4MDtcbiAgICAgICAgdGhpcy50cmltTGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXhMYWJlbExlbmd0aCA9IDEwO1xuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRibGNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGllR2VuZXJhdG9yID0gcGllKClcbiAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSlcbiAgICAgICAgICAgIC5zb3J0KG51bGwpO1xuICAgICAgICB2YXIgYXJjRGF0YSA9IHBpZUdlbmVyYXRvcih0aGlzLnNlcmllcyk7XG4gICAgICAgIHRoaXMubWF4ID0gbWF4KGFyY0RhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuY2FsY3VsYXRlTGFiZWxQb3NpdGlvbnMoYXJjRGF0YSk7XG4gICAgICAgIHRoaXMudG9vbHRpcFRleHQgPSB0aGlzLnRvb2x0aXBUZXh0IHx8IHRoaXMuZGVmYXVsdFRvb2x0aXBUZXh0O1xuICAgIH07XG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5taWRBbmdsZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyO1xuICAgIH07XG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vdXRlckFyYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IDEuNTtcbiAgICAgICAgcmV0dXJuIGFyYygpXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5vdXRlclJhZGl1cyAqIGZhY3RvcilcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLm91dGVyUmFkaXVzICogZmFjdG9yKTtcbiAgICB9O1xuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuY2FsY3VsYXRlTGFiZWxQb3NpdGlvbnMgPSBmdW5jdGlvbiAocGllRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmFjdG9yID0gMS41O1xuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSAxMDtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb25zID0gcGllRGF0YTtcbiAgICAgICAgbGFiZWxQb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZC5wb3MgPSBfdGhpcy5vdXRlckFyYygpLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgZC5wb3NbMF0gPSBmYWN0b3IgKiBfdGhpcy5vdXRlclJhZGl1cyAqIChfdGhpcy5taWRBbmdsZShkKSA8IE1hdGguUEkgPyAxIDogLTEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbFBvc2l0aW9ucy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gbGFiZWxQb3NpdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoIXRoaXMubGFiZWxWaXNpYmxlKGEpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsYWJlbFBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBiID0gbGFiZWxQb3NpdGlvbnNbal07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxhYmVsVmlzaWJsZShiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSdyZSBvbiB0aGUgc2FtZSBzaWRlXG4gICAgICAgICAgICAgICAgaWYgKGIucG9zWzBdICogYS5wb3NbMF0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkncmUgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBtaW5EaXN0YW5jZSAtIE1hdGguYWJzKGIucG9zWzFdIC0gYS5wb3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIHNlY29uZCB1cCBvciBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBvc1sxXSArPSBNYXRoLnNpZ24oYi5wb3NbMF0pICogbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxQb3NpdGlvbnM7XG4gICAgfTtcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmxhYmVsVmlzaWJsZSA9IGZ1bmN0aW9uIChteUFyYykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93TGFiZWxzICYmIG15QXJjLmVuZEFuZ2xlIC0gbXlBcmMuc3RhcnRBbmdsZSA+IE1hdGguUEkgLyAzMDtcbiAgICB9O1xuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VG9vbHRpcFRpdGxlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdGhpcy50b29sdGlwVGV4dChhKTtcbiAgICB9O1xuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubGFiZWxUZXh0ID0gZnVuY3Rpb24gKG15QXJjKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsRm9ybWF0dGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3JtYXR0aW5nKG15QXJjLmRhdGEubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwobXlBcmMpO1xuICAgIH07XG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIChteUFyYykge1xuICAgICAgICByZXR1cm4gZm9ybWF0TGFiZWwobXlBcmMuZGF0YS5uYW1lKTtcbiAgICB9O1xuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZGVmYXVsdFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKG15QXJjKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMubGFiZWwobXlBcmMpO1xuICAgICAgICB2YXIgdmFsID0gZm9ybWF0TGFiZWwobXlBcmMuZGF0YS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGVzY2FwZUxhYmVsKGxhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWwgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XG4gICAgfTtcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKG15QXJjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9ycy5nZXRDb2xvcih0aGlzLmxhYmVsKG15QXJjKSk7XG4gICAgfTtcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5uYW1lO1xuICAgIH07XG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93TGFiZWxzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbUxhYmVsc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4TGFiZWxMZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYmxjbGlja1wiLCB2b2lkIDApO1xuICAgIFBpZVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcGllLXNlcmllc10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBhcmMgb2YgZGF0YTsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXBpZS1sYWJlbFxcbiAgICAgICAgKm5nSWY9XFxcImxhYmVsVmlzaWJsZShhcmMpXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJhcmNcXFwiXFxuICAgICAgICBbcmFkaXVzXT1cXFwib3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICBbY29sb3JdPVxcXCJjb2xvcihhcmMpXFxcIlxcbiAgICAgICAgW2xhYmVsXT1cXFwibGFiZWxUZXh0KGFyYylcXFwiXFxuICAgICAgICBbbGFiZWxUcmltXT1cXFwidHJpbUxhYmVsc1xcXCJcXG4gICAgICAgIFtsYWJlbFRyaW1TaXplXT1cXFwibWF4TGFiZWxMZW5ndGhcXFwiXFxuICAgICAgICBbbWF4XT1cXFwibWF4XFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYXJjLnZhbHVlXFxcIlxcbiAgICAgICAgW2V4cGxvZGVTbGljZXNdPVxcXCJleHBsb2RlU2xpY2VzXFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1waWUtYXJjXFxuICAgICAgICBbc3RhcnRBbmdsZV09XFxcImFyYy5zdGFydEFuZ2xlXFxcIlxcbiAgICAgICAgW2VuZEFuZ2xlXT1cXFwiYXJjLmVuZEFuZ2xlXFxcIlxcbiAgICAgICAgW2lubmVyUmFkaXVzXT1cXFwiaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiY29sb3IoYXJjKVxcXCJcXG4gICAgICAgIFt2YWx1ZV09XFxcImFyYy5kYXRhLnZhbHVlXFxcIlxcbiAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImFyYy5kYXRhXFxcIlxcbiAgICAgICAgW21heF09XFxcIm1heFxcXCJcXG4gICAgICAgIFtleHBsb2RlU2xpY2VzXT1cXFwiZXhwbG9kZVNsaWNlc1xcXCJcXG4gICAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlKGFyYy5kYXRhKVxcXCJcXG4gICAgICAgIFthbmltYXRlXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgKGRibGNsaWNrKT1cXFwiZGJsY2xpY2suZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcImdldFRvb2x0aXBUaXRsZShhcmMpXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImFyYy5kYXRhXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudCk7XG4gICAgcmV0dXJuIFBpZVNlcmllc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBQaWVDaGFydE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQaWVDaGFydE1vZHVsZSgpIHtcbiAgICB9XG4gICAgUGllQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgUGllTGFiZWxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgUGllQXJjQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFBpZUNoYXJ0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFBpZUdyaWRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgUGllR3JpZFNlcmllc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBQaWVTZXJpZXNDb21wb25lbnRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBQaWVMYWJlbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBQaWVBcmNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgUGllQ2hhcnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgUGllR3JpZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFBpZVNlcmllc0NvbXBvbmVudFxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIF0sIFBpZUNoYXJ0TW9kdWxlKTtcbiAgICByZXR1cm4gUGllQ2hhcnRNb2R1bGU7XG59KCkpO1xuXG52YXIgUG9sYXJDaGFydE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2xhckNoYXJ0TW9kdWxlKCkge1xuICAgIH1cbiAgICBQb2xhckNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZSwgUGllQ2hhcnRNb2R1bGUsIExpbmVDaGFydE1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBQb2xhckNoYXJ0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIFBvbGFyQ2hhcnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgUG9sYXJTZXJpZXNDb21wb25lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBQb2xhckNoYXJ0TW9kdWxlKTtcbiAgICByZXR1cm4gUG9sYXJDaGFydE1vZHVsZTtcbn0oKSk7XG5cbnZhciBDYXJkQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcmRDb21wb25lbnQoZWxlbWVudCwgY2QsIHpvbmUpIHtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICB0aGlzLnRleHRGb250U2l6ZSA9IDEyO1xuICAgICAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSAnJztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhbmRIZWlnaHQgPSAxMDtcbiAgICAgICAgdGhpcy50ZXh0UGFkZGluZyA9IFsxMCwgMjAsIDUsIDIwXTtcbiAgICAgICAgdGhpcy5sYWJlbEZvbnRTaXplID0gMTU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxKTtcbiAgICB9O1xuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGFzVmFsdWUgPSBfdGhpcy5kYXRhICYmIHR5cGVvZiBfdGhpcy5kYXRhLnZhbHVlICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRpbmcgPSBfdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uIChjYXJkKSB7IHJldHVybiBjYXJkLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH0pO1xuICAgICAgICAgICAgdmFyIGxhYmVsRm9ybWF0dGluZyA9IF90aGlzLmxhYmVsRm9ybWF0dGluZyB8fCAoZnVuY3Rpb24gKGNhcmQpIHsgcmV0dXJuIGVzY2FwZUxhYmVsKHRyaW1MYWJlbChjYXJkLmxhYmVsLCA1NSkpOyB9KTtcbiAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgX3RoaXMueCArIFwiICwgXCIgKyBfdGhpcy55ICsgXCIpXCI7XG4gICAgICAgICAgICBfdGhpcy50ZXh0V2lkdGggPSBNYXRoLm1heCgwLCBfdGhpcy53aWR0aCkgLSBfdGhpcy50ZXh0UGFkZGluZ1sxXSAtIF90aGlzLnRleHRQYWRkaW5nWzNdO1xuICAgICAgICAgICAgX3RoaXMuY2FyZFdpZHRoID0gTWF0aC5tYXgoMCwgX3RoaXMud2lkdGgpO1xuICAgICAgICAgICAgX3RoaXMuY2FyZEhlaWdodCA9IE1hdGgubWF4KDAsIF90aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBfdGhpcy5sYWJlbCA9IF90aGlzLmxhYmVsID8gX3RoaXMubGFiZWwgOiBfdGhpcy5kYXRhLm5hbWU7XG4gICAgICAgICAgICB2YXIgY2FyZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IF90aGlzLmxhYmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IF90aGlzLmRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLmRhdGEudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5mb3JtYXR0ZWRMYWJlbCA9IGxhYmVsRm9ybWF0dGluZyhjYXJkRGF0YSk7XG4gICAgICAgICAgICBfdGhpcy50cmFuc2Zvcm1CYW5kID0gXCJ0cmFuc2xhdGUoMCAsIFwiICsgKF90aGlzLmNhcmRIZWlnaHQgLSBfdGhpcy5iYW5kSGVpZ2h0KSArIFwiKVwiO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaGFzVmFsdWUgPyB2YWx1ZUZvcm1hdHRpbmcoY2FyZERhdGEpIDogJyc7XG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IF90aGlzLnBhZGRlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIF90aGlzLnNldFBhZGRpbmcoKTtcbiAgICAgICAgICAgIF90aGlzLmJhbmRQYXRoID0gcm91bmRlZFJlY3QoMCwgMCwgX3RoaXMuY2FyZFdpZHRoLCBfdGhpcy5iYW5kSGVpZ2h0LCAzLCBbZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlXSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zY2FsZVRleHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZSAmJiAhX3RoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGFydENvdW50KCk7IH0sIDIwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5wYWRkZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5tZWRpYW5TaXplICYmIHRoaXMubWVkaWFuU2l6ZSA+IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcdTIwMDcnLnJlcGVhdCh0aGlzLm1lZGlhblNpemUgLSB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnN0YXJ0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCAmJiB0aGlzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxKTtcbiAgICAgICAgICAgIHZhciB2YWxfMSA9IHRoaXMuZGF0YS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBkZWNzID0gZGVjaW1hbENoZWNrZXIodmFsXzEpO1xuICAgICAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGluZ18xID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uIChjYXJkKSB7IHJldHVybiBjYXJkLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH0pO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIGZpbmlzaGVkID0gX2EuZmluaXNoZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbmlzaGVkID8gdmFsXzEgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZUZvcm1hdHRpbmdfMSh7IGxhYmVsOiBfdGhpcy5sYWJlbCwgZGF0YTogX3RoaXMuZGF0YSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IF90aGlzLnBhZGRlZFZhbHVlKF90aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblJlcSA9IGNvdW50KDAsIHZhbF8xLCBkZWNzLCAxLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUuc2NhbGVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnRleHRFbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHRQYWRkaW5nID0gKF90aGlzLnRleHRQYWRkaW5nWzFdID0gX3RoaXMudGV4dFBhZGRpbmdbM10gPSBfdGhpcy5jYXJkV2lkdGggLyA4KTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IF90aGlzLmNhcmRXaWR0aCAtIDIgKiB0ZXh0UGFkZGluZztcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSBfdGhpcy5jYXJkSGVpZ2h0IC8gMztcbiAgICAgICAgICAgIHZhciByZXNpemVTY2FsZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoIC8gd2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIGhlaWdodCk7XG4gICAgICAgICAgICBfdGhpcy50ZXh0Rm9udFNpemUgPSBNYXRoLmZsb29yKF90aGlzLnRleHRGb250U2l6ZSAqIHJlc2l6ZVNjYWxlKTtcbiAgICAgICAgICAgIF90aGlzLmxhYmVsRm9udFNpemUgPSBNYXRoLm1pbihfdGhpcy50ZXh0Rm9udFNpemUsIDE1KTtcbiAgICAgICAgICAgIF90aGlzLnNldFBhZGRpbmcoKTtcbiAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGV4dFBhZGRpbmdbMV0gPSB0aGlzLnRleHRQYWRkaW5nWzNdID0gdGhpcy5jYXJkV2lkdGggLyA4O1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2FyZEhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMudGV4dFBhZGRpbmdbMF0gPSBwYWRkaW5nIC0gdGhpcy50ZXh0Rm9udFNpemUgLSB0aGlzLmxhYmVsRm9udFNpemUgLyAyO1xuICAgICAgICB0aGlzLnRleHRQYWRkaW5nWzJdID0gcGFkZGluZyAtIHRoaXMubGFiZWxGb250U2l6ZTtcbiAgICB9O1xuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImJhbmRDb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRDb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtZWRpYW5TaXplXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIFZpZXdDaGlsZCgndGV4dEVsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0RWxcIiwgdm9pZCAwKTtcbiAgICBDYXJkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1jYXJkXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImNlbGxcXFwiIChjbGljayk9XFxcIm9uQ2xpY2soKVxcXCI+XFxuICAgICAgPHN2ZzpyZWN0IGNsYXNzPVxcXCJjYXJkXFxcIiBbc3R5bGUuZmlsbF09XFxcImNvbG9yXFxcIiBbYXR0ci53aWR0aF09XFxcImNhcmRXaWR0aFxcXCIgW2F0dHIuaGVpZ2h0XT1cXFwiY2FyZEhlaWdodFxcXCIgcng9XFxcIjNcXFwiIHJ5PVxcXCIzXFxcIiAvPlxcbiAgICAgIDxzdmc6cGF0aFxcbiAgICAgICAgKm5nSWY9XFxcImJhbmRDb2xvciAmJiBiYW5kQ29sb3IgIT09IGNvbG9yXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNhcmQtYmFuZFxcXCJcXG4gICAgICAgIFthdHRyLmZpbGxdPVxcXCJiYW5kQ29sb3JcXFwiXFxuICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1CYW5kXFxcIlxcbiAgICAgICAgc3Ryb2tlPVxcXCJub25lXFxcIlxcbiAgICAgICAgW2F0dHIuZF09XFxcImJhbmRQYXRoXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHRpdGxlPnt7IGxhYmVsIH19PC90aXRsZT5cXG4gICAgICA8c3ZnOmZvcmVpZ25PYmplY3RcXG4gICAgICAgIGNsYXNzPVxcXCJ0cmltbWVkLWxhYmVsXFxcIlxcbiAgICAgICAgeD1cXFwiNVxcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJ0ZXh0UGFkZGluZ1szXVxcXCJcXG4gICAgICAgIFthdHRyLnldPVxcXCJjYXJkSGVpZ2h0IC0gdGV4dFBhZGRpbmdbMl1cXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcInRleHRXaWR0aFxcXCJcXG4gICAgICAgIFthdHRyLmhlaWdodF09XFxcImxhYmVsRm9udFNpemUgKyB0ZXh0UGFkZGluZ1syXVxcXCJcXG4gICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiaGFuZ2luZ1xcXCJcXG4gICAgICA+XFxuICAgICAgICA8eGh0bWw6cFxcbiAgICAgICAgICBbc3R5bGUuY29sb3JdPVxcXCJ0ZXh0Q29sb3JcXFwiXFxuICAgICAgICAgIFtzdHlsZS5mb250U2l6ZS5weF09XFxcImxhYmVsRm9udFNpemVcXFwiXFxuICAgICAgICAgIFtzdHlsZS5saW5lSGVpZ2h0LnB4XT1cXFwibGFiZWxGb250U2l6ZVxcXCJcXG4gICAgICAgICAgW2lubmVySFRNTF09XFxcImZvcm1hdHRlZExhYmVsXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgPC94aHRtbDpwPlxcbiAgICAgIDwvc3ZnOmZvcmVpZ25PYmplY3Q+XFxuICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAjdGV4dEVsXFxuICAgICAgICBjbGFzcz1cXFwidmFsdWUtdGV4dFxcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJ0ZXh0UGFkZGluZ1szXVxcXCJcXG4gICAgICAgIFthdHRyLnldPVxcXCJ0ZXh0UGFkZGluZ1swXVxcXCJcXG4gICAgICAgIFtzdHlsZS5maWxsXT1cXFwidGV4dENvbG9yXFxcIlxcbiAgICAgICAgdGV4dC1hbmNob3I9XFxcInN0YXJ0XFxcIlxcbiAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJoYW5naW5nXFxcIlxcbiAgICAgICAgW3N0eWxlLmZvbnQtc2l6ZS5wdF09XFxcInRleHRGb250U2l6ZVxcXCJcXG4gICAgICA+XFxuICAgICAgICB7eyB2YWx1ZSB9fVxcbiAgICAgIDwvc3ZnOnRleHQ+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2IgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QsIHR5cGVvZiAoX2MgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdCwgdHlwZW9mIChfZCA9IHR5cGVvZiBOZ1pvbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgTmdab25lKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3RdKVxuICAgIF0sIENhcmRDb21wb25lbnQpO1xuICAgIHJldHVybiBDYXJkQ29tcG9uZW50O1xufSgpKTtcblxudmFyIENhcmRTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FyZFNlcmllc0NvbXBvbmVudCgpIHtcbiAgICAgICAgdGhpcy5pbm5lclBhZGRpbmcgPSAxNTtcbiAgICAgICAgdGhpcy5lbXB0eUNvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRpbmdfMSA9IHRoaXMudmFsdWVGb3JtYXR0aW5nIHx8IChmdW5jdGlvbiAoY2FyZCkgeyByZXR1cm4gY2FyZC52YWx1ZS50b0xvY2FsZVN0cmluZygpOyB9KTtcbiAgICAgICAgICAgIHZhciBzb3J0ZWRMZW5ndGhzID0gdGhpcy5kYXRhXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNWYWx1ZSA9IGQgJiYgZC5kYXRhICYmIHR5cGVvZiBkLmRhdGEudmFsdWUgIT09ICd1bmRlZmluZWQnICYmIGQuZGF0YS52YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZUZvcm1hdHRpbmdfMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZCA/IGQuZGF0YS5uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZCAmJiBkLmRhdGEgPyBkLmRhdGEudmFsdWUgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH0pO1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGguY2VpbCh0aGlzLmRhdGEubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICB0aGlzLm1lZGlhblNpemUgPSBzb3J0ZWRMZW5ndGhzW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhcmRzID0gdGhpcy5nZXRDYXJkcygpO1xuICAgICAgICB0aGlzLmNhcmRzID0gY2FyZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmRhdGEudmFsdWUgIT09IG51bGw7IH0pO1xuICAgICAgICB0aGlzLmVtcHR5U2xvdHMgPSBjYXJkcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZGF0YS52YWx1ZSA9PT0gbnVsbDsgfSk7XG4gICAgfTtcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDYXJkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHlQYWRkaW5nID0gdHlwZW9mIHRoaXMuaW5uZXJQYWRkaW5nID09PSAnbnVtYmVyJyA/IHRoaXMuaW5uZXJQYWRkaW5nIDogdGhpcy5pbm5lclBhZGRpbmdbMF0gKyB0aGlzLmlubmVyUGFkZGluZ1syXTtcbiAgICAgICAgdmFyIHhQYWRkaW5nID0gdHlwZW9mIHRoaXMuaW5uZXJQYWRkaW5nID09PSAnbnVtYmVyJyA/IHRoaXMuaW5uZXJQYWRkaW5nIDogdGhpcy5pbm5lclBhZGRpbmdbMV0gKyB0aGlzLmlubmVyUGFkZGluZ1szXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLmRhdGEubmFtZTtcbiAgICAgICAgICAgIGlmIChsYWJlbCAmJiBsYWJlbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbCA/IGxhYmVsLnRvTG9jYWxlU3RyaW5nKCkgOiBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGQuZGF0YS52YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUNvbG9yID0gbGFiZWwgPyBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpIDogX3RoaXMuZW1wdHlDb2xvcjtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IF90aGlzLmNhcmRDb2xvciB8fCB2YWx1ZUNvbG9yIHx8ICcjMDAwJztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZC54LFxuICAgICAgICAgICAgICAgIHk6IGQueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogZC53aWR0aCAtIHhQYWRkaW5nLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZC5oZWlnaHQgLSB5UGFkZGluZyxcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYmFuZENvbG9yOiBfdGhpcy5iYW5kQ29sb3IgfHwgdmFsdWVDb2xvcixcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IF90aGlzLnRleHRDb2xvciB8fCBpbnZlcnRDb2xvcihjb2xvciksXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICB0b29sdGlwVGV4dDogbGFiZWwgKyBcIjogXCIgKyB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBjYXJkKSB7XG4gICAgICAgIHJldHVybiBjYXJkLmxhYmVsO1xuICAgIH07XG4gICAgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNsb3RzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUGFkZGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNhcmRDb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImJhbmRDb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImVtcHR5Q29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0Q29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1jYXJkLXNlcmllc10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6cmVjdFxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGMgb2YgZW1wdHlTbG90czsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICBjbGFzcz1cXFwiY2FyZC1lbXB0eVxcXCJcXG4gICAgICBbYXR0ci54XT1cXFwiYy54XFxcIlxcbiAgICAgIFthdHRyLnldPVxcXCJjLnlcXFwiXFxuICAgICAgW3N0eWxlLmZpbGxdPVxcXCJlbXB0eUNvbG9yXFxcIlxcbiAgICAgIFthdHRyLndpZHRoXT1cXFwiYy53aWR0aFxcXCJcXG4gICAgICBbYXR0ci5oZWlnaHRdPVxcXCJjLmhlaWdodFxcXCJcXG4gICAgICByeD1cXFwiM1xcXCJcXG4gICAgICByeT1cXFwiM1xcXCJcXG4gICAgLz5cXG4gICAgPHN2ZzpnXFxuICAgICAgbmd4LWNoYXJ0cy1jYXJkXFxuICAgICAgKm5nRm9yPVxcXCJsZXQgYyBvZiBjYXJkczsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICBbeF09XFxcImMueFxcXCJcXG4gICAgICBbeV09XFxcImMueVxcXCJcXG4gICAgICBbd2lkdGhdPVxcXCJjLndpZHRoXFxcIlxcbiAgICAgIFtoZWlnaHRdPVxcXCJjLmhlaWdodFxcXCJcXG4gICAgICBbY29sb3JdPVxcXCJjLmNvbG9yXFxcIlxcbiAgICAgIFtiYW5kQ29sb3JdPVxcXCJjLmJhbmRDb2xvclxcXCJcXG4gICAgICBbdGV4dENvbG9yXT1cXFwiYy50ZXh0Q29sb3JcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJjLmRhdGFcXFwiXFxuICAgICAgW2xhYmVsXT1cXFwiYy5sYWJlbFxcXCJcXG4gICAgICBbbWVkaWFuU2l6ZV09XFxcIm1lZGlhblNpemVcXFwiXFxuICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAvPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQpO1xuICAgIHJldHVybiBDYXJkU2VyaWVzQ29tcG9uZW50O1xufSgpKTtcblxudmFyIE51bWJlckNhcmRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlckNhcmRDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyQ2FyZENvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVtcHR5Q29sb3IgPSAncmdiYSgwLCAwLCAwLCAwKSc7XG4gICAgICAgIF90aGlzLmlubmVyUGFkZGluZyA9IDE1O1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDEwLCAxMCwgMTBdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGlja2FibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0Lm9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcbiAgICAgICAgdmFyIHNpemUgPSBncmlkU2l6ZSh0aGlzLmRpbXMsIHRoaXMucmVzdWx0cy5sZW5ndGgsIDE1MCk7XG4gICAgICAgIHZhciBOID0gc2l6ZVswXSAqIHNpemVbMV07XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZXN1bHRzLnNsaWNlKCk7XG4gICAgICAgIHdoaWxlIChkYXRhLmxlbmd0aCA8IE4pIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7IHZhbHVlOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IGdyaWRMYXlvdXQodGhpcy5kaW1zLCBkYXRhLCAxNTAsIHRoaXMuZGVzaWduYXRlZFRvdGFsKTtcbiAgICB9O1xuICAgIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubGFiZWw7IH0pO1xuICAgIH07XG4gICAgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYXJkQ29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYW5kQ29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbXB0eUNvbG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJQYWRkaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dENvbG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVzaWduYXRlZFRvdGFsXCIsIHZvaWQgMCk7XG4gICAgTnVtYmVyQ2FyZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLW51bWJlci1jYXJkJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydCBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCIgW3Nob3dMZWdlbmRdPVxcXCJmYWxzZVxcXCIgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIj5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwibnVtYmVyLWNhcmQgY2hhcnRcXFwiIFtjbGFzcy5jbGlja2FibGVdPVxcXCJjbGlja2FibGVcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtY2FyZC1zZXJpZXNcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW2NhcmRDb2xvcl09XFxcImNhcmRDb2xvclxcXCJcXG4gICAgICAgICAgW2JhbmRDb2xvcl09XFxcImJhbmRDb2xvclxcXCJcXG4gICAgICAgICAgW3RleHRDb2xvcl09XFxcInRleHRDb2xvclxcXCJcXG4gICAgICAgICAgW2VtcHR5Q29sb3JdPVxcXCJlbXB0eUNvbG9yXFxcIlxcbiAgICAgICAgICBbZGF0YV09XFxcImRhdGFcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW2lubmVyUGFkZGluZ109XFxcImlubmVyUGFkZGluZ1xcXCJcXG4gICAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW2xhYmVsRm9ybWF0dGluZ109XFxcImxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCJuZ3gtY2hhcnRzLW51bWJlci1jYXJkIC5jZWxsIC50cmltbWVkLWxhYmVse2ZvbnQtc2l6ZToxMnB4O3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtYWxpZ246bGVmdDtsaW5lLWhlaWdodDoxZW19bmd4LWNoYXJ0cy1udW1iZXItY2FyZCAuY2VsbCAudHJpbW1lZC1sYWJlbCBwe292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aWR0aDoxMDAlO3BhZGRpbmc6MDttYXJnaW46MH1uZ3gtY2hhcnRzLW51bWJlci1jYXJkIC5jZWxsIC52YWx1ZS10ZXh0e3BvaW50ZXItZXZlbnRzOm5vbmV9bmd4LWNoYXJ0cy1udW1iZXItY2FyZCAubnVtYmVyLWNhcmQuY2xpY2thYmxlIC5jZWxsIC5jYXJkLG5neC1jaGFydHMtbnVtYmVyLWNhcmQgLm51bWJlci1jYXJkLmNsaWNrYWJsZSAuY2VsbCAuY2FyZC1iYW5ke2N1cnNvcjpwb2ludGVyfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KVxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQpO1xuICAgIHJldHVybiBOdW1iZXJDYXJkQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIE51bWJlckNhcmRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyQ2FyZE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTnVtYmVyQ2FyZE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgQ2FyZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBDYXJkU2VyaWVzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIE51bWJlckNhcmRDb21wb25lbnRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgQ2FyZENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBDYXJkU2VyaWVzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIE51bWJlckNhcmRDb21wb25lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBOdW1iZXJDYXJkTW9kdWxlKTtcbiAgICByZXR1cm4gTnVtYmVyQ2FyZE1vZHVsZTtcbn0oKSk7XG5cbnZhciBUcmVlTWFwQ2VsbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlTWFwQ2VsbENvbXBvbmVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMudmFsdWVGb3JtYXR0aW5nID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTsgfSk7XG4gICAgICAgIHZhciBsYWJlbEZvcm1hdHRpbmcgPSB0aGlzLmxhYmVsRm9ybWF0dGluZyB8fCAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIGVzY2FwZUxhYmVsKHRyaW1MYWJlbChjZWxsLmxhYmVsLCA1NSkpOyB9KTtcbiAgICAgICAgdmFyIGNlbGxEYXRhID0ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvcm1hdHRlZFZhbHVlID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcoY2VsbERhdGEudmFsdWUpO1xuICAgICAgICB0aGlzLmZvcm1hdHRlZExhYmVsID0gbGFiZWxGb3JtYXR0aW5nKGNlbGxEYXRhKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmdyYWRpZW50VXJsID0gXCJ1cmwoI1wiICsgdGhpcy5ncmFkaWVudElkICsgXCIpXCI7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuZ2V0R3JhZGllbnRTdG9wcygpO1xuICAgIH07XG4gICAgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvQ3VycmVudEZvcm0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5jZWxsJyk7XG4gICAgICAgIG5vZGVcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd4JywgdGhpcy54KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLnkpO1xuICAgICAgICB0aGlzLmFuaW1hdGVUb0N1cnJlbnRGb3JtKCk7XG4gICAgfTtcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGV4dENvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52ZXJ0Q29sb3IodGhpcy5maWxsKTtcbiAgICB9O1xuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5hbmltYXRlVG9DdXJyZW50Rm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5jZWxsJyk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDc1MClcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLngpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLnkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHRoaXMueClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHRoaXMueSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLndpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0YSk7XG4gICAgfTtcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JhZGllbnRTdG9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlVHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgVHJlZU1hcENlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXRyZWUtbWFwLWNlbGxdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmc+XFxuICAgICAgPGRlZnMgKm5nSWY9XFxcImdyYWRpZW50XFxcIj5cXG4gICAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnQgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIiBbbmFtZV09XFxcImdyYWRpZW50SWRcXFwiIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBmaWxsXFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJ3aWR0aFxcXCJcXG4gICAgICAgIFthdHRyLmhlaWdodF09XFxcImhlaWdodFxcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIlxcbiAgICAgICAgW2F0dHIueV09XFxcInlcXFwiXFxuICAgICAgICBbc3R5bGUuY3Vyc29yXT1cXFwiJ3BvaW50ZXInXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNlbGxcXFwiXFxuICAgICAgICAoY2xpY2spPVxcXCJvbkNsaWNrKClcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmZvcmVpZ25PYmplY3RcXG4gICAgICAgICpuZ0lmPVxcXCJ3aWR0aCA+PSA3MCAmJiBoZWlnaHQgPj0gMzVcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwieFxcXCJcXG4gICAgICAgIFthdHRyLnldPVxcXCJ5XFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJ3aWR0aFxcXCJcXG4gICAgICAgIFthdHRyLmhlaWdodF09XFxcImhlaWdodFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJ0cmVlbWFwLWxhYmVsXFxcIlxcbiAgICAgICAgW3N0eWxlLnBvaW50ZXItZXZlbnRzXT1cXFwiJ25vbmUnXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDx4aHRtbDpwIFtzdHlsZS5jb2xvcl09XFxcImdldFRleHRDb2xvcigpXFxcIiBbc3R5bGUuaGVpZ2h0XT1cXFwiaGVpZ2h0ICsgJ3B4J1xcXCIgW3N0eWxlLndpZHRoXT1cXFwid2lkdGggKyAncHgnXFxcIj5cXG4gICAgICAgICAgPHhodG1sOnNwYW4gY2xhc3M9XFxcInRyZWVtYXAtbGFiZWxcXFwiIFtpbm5lckhUTUxdPVxcXCJmb3JtYXR0ZWRMYWJlbFxcXCI+IDwveGh0bWw6c3Bhbj5cXG4gICAgICAgICAgPHhodG1sOmJyIC8+XFxuICAgICAgICAgIDx4aHRtbDpzcGFuXFxuICAgICAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcInRyZWVtYXAtdmFsXFxcIlxcbiAgICAgICAgICAgIG5neC1jaGFydHMtY291bnQtdXBcXG4gICAgICAgICAgICBbY291bnRUb109XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgPC94aHRtbDpzcGFuPlxcbiAgICAgICAgICA8eGh0bWw6c3BhbiAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiIGNsYXNzPVxcXCJ0cmVlbWFwLXZhbFxcXCI+XFxuICAgICAgICAgICAge3sgZm9ybWF0dGVkVmFsdWUgfX1cXG4gICAgICAgICAgPC94aHRtbDpzcGFuPlxcbiAgICAgICAgPC94aHRtbDpwPlxcbiAgICAgIDwvc3ZnOmZvcmVpZ25PYmplY3Q+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50KTtcbiAgICByZXR1cm4gVHJlZU1hcENlbGxDb21wb25lbnQ7XG59KCkpO1xuXG52YXIgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuY2VsbHMgPSB0aGlzLmdldENlbGxzKCk7XG4gICAgfTtcbiAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmRlcHRoID09PSAxO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQuaWQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICB4OiBkLngwLFxuICAgICAgICAgICAgICAgIHk6IGQueTAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGQueDEgLSBkLngwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZC55MSAtIGQueTAsXG4gICAgICAgICAgICAgICAgZmlsbDogX3RoaXMuY29sb3JzLmdldENvbG9yKGxhYmVsKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGQudmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBkLnZhbHVlVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gX2EubGFiZWwsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGVzY2FwZUxhYmVsKGxhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgXCI8L3NwYW4+XFxuICAgIFwiO1xuICAgIH07XG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICAgIH07XG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy10cmVlLW1hcC1jZWxsLXNlcmllc10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtdHJlZS1tYXAtY2VsbFxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGMgb2YgY2VsbHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJjLmRhdGFcXFwiXFxuICAgICAgW3hdPVxcXCJjLnhcXFwiXFxuICAgICAgW3ldPVxcXCJjLnlcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiYy53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYy5oZWlnaHRcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJjLmZpbGxcXFwiXFxuICAgICAgW2xhYmVsXT1cXFwiYy5sYWJlbFxcXCJcXG4gICAgICBbdmFsdWVdPVxcXCJjLnZhbHVlXFxcIlxcbiAgICAgIFt2YWx1ZVR5cGVdPVxcXCJjLnZhbHVlVHlwZVxcXCJcXG4gICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgIFtsYWJlbEZvcm1hdHRpbmddPVxcXCJsYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjKVxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImMuZGF0YVxcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQpO1xuICAgIHJldHVybiBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBUcmVlTWFwQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmVlTWFwQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyZWVNYXBDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZ3JhZGllbnQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDEwLCAxMCwgMTBdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tYWluID0gdGhpcy5nZXREb21haW4oKTtcbiAgICAgICAgdGhpcy50cmVlbWFwID0gdHJlZW1hcCgpLnNpemUoW3RoaXMuZGltcy53aWR0aCwgdGhpcy5kaW1zLmhlaWdodF0pO1xuICAgICAgICB2YXIgcm9vdE5vZGUgPSB7XG4gICAgICAgICAgICBuYW1lOiAncm9vdCcsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGlzUm9vdDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcm9vdCA9IHN0cmF0aWZ5KClcbiAgICAgICAgICAgIC5pZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xuICAgICAgICAgICAgaWYgKGxhYmVsLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdEYXRlJykge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucGFyZW50SWQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkLmlzUm9vdCA/IG51bGwgOiAncm9vdCcpOyB9KShbcm9vdE5vZGVdLmNvbmNhdCh0aGlzLnJlc3VsdHMpKVxuICAgICAgICAgICAgLnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMudHJlZW1hcChyb290KTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XG4gICAgfTtcbiAgICBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xuICAgIH07XG4gICAgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gICAgfTtcbiAgICBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICB2YXIgX2E7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIFRyZWVNYXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy10cmVlLW1hcCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiIFtzaG93TGVnZW5kXT1cXFwiZmFsc2VcXFwiIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCI+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcInRyZWUtbWFwIGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXRyZWUtbWFwLWNlbGwtc2VyaWVzXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLnRyZWUtbWFwIC50cmVlbWFwLXZhbHtmb250LXNpemU6MS4zZW07cGFkZGluZy10b3A6NXB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfS50cmVlLW1hcCAudHJlZW1hcC1sYWJlbCBwe2Rpc3BsYXk6dGFibGUtY2VsbDt0ZXh0LWFsaWduOmNlbnRlcjtsaW5lLWhlaWdodDoxLjJlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudCk7XG4gICAgcmV0dXJuIFRyZWVNYXBDb21wb25lbnQ7XG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xuXG52YXIgVHJlZU1hcE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlTWFwTW9kdWxlKCkge1xuICAgIH1cbiAgICBUcmVlTWFwTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ29tcG9uZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIFRyZWVNYXBDb21wb25lbnRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBUcmVlTWFwTW9kdWxlKTtcbiAgICByZXR1cm4gVHJlZU1hcE1vZHVsZTtcbn0oKSk7XG5cbnZhciBMaW5lYXJHYXVnZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluZWFyR2F1Z2VDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGluZWFyR2F1Z2VDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5taW4gPSAwO1xuICAgICAgICBfdGhpcy5tYXggPSAxMDA7XG4gICAgICAgIF90aGlzLnZhbHVlID0gMDtcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcbiAgICAgICAgX3RoaXMudmFsdWVSZXNpemVTY2FsZSA9IDE7XG4gICAgICAgIF90aGlzLnVuaXRzUmVzaXplU2NhbGUgPSAxO1xuICAgICAgICBfdGhpcy52YWx1ZVRleHRUcmFuc2Zvcm0gPSAnJztcbiAgICAgICAgX3RoaXMudmFsdWVUcmFuc2xhdGUgPSAnJztcbiAgICAgICAgX3RoaXMudW5pdHNUZXh0VHJhbnNmb3JtID0gJyc7XG4gICAgICAgIF90aGlzLnVuaXRzVHJhbnNsYXRlID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zY2FsZVRleHQoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBfdGhpcy5zY2FsZVRleHQoJ3VuaXRzJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYXNQcmV2aW91c1ZhbHVlID0gdGhpcy5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLm1pbiA9IE1hdGgubWluKHRoaXMubWluLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIHRoaXMucHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XG4gICAgICAgIHRoaXMudmFsdWVTY2FsZSA9IHRoaXMuZ2V0VmFsdWVTY2FsZSgpO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZ2V0RGlzcGxheVZhbHVlKCk7XG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5tYXJnaW5bM10gKyB0aGlzLmRpbXMud2lkdGggLyAyO1xuICAgICAgICB2YXIgeU9mZnNldCA9IHRoaXMubWFyZ2luWzBdICsgdGhpcy5kaW1zLmhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4T2Zmc2V0ICsgXCIsIFwiICsgeU9mZnNldCArIFwiKVwiO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUxpbmUgPSBcInRyYW5zbGF0ZShcIiArICh0aGlzLm1hcmdpblszXSArIHRoaXMudmFsdWVTY2FsZSh0aGlzLnByZXZpb3VzVmFsdWUpKSArIFwiLCBcIiArIHlPZmZzZXQgKyBcIilcIjtcbiAgICAgICAgdGhpcy52YWx1ZVRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKDAsIC0xNSlcIjtcbiAgICAgICAgdGhpcy51bml0c1RyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKDAsIDE1KVwiO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlVGV4dCgndmFsdWUnKTsgfSwgNTApO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlVGV4dCgndW5pdHMnKTsgfSwgNTApO1xuICAgIH07XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMubWluLCB0aGlzLm1heF07XG4gICAgfTtcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XG4gICAgfTtcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGlzcGxheVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUZvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgIH07XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnNjYWxlVGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50LCByZXBlYXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJlcGVhdCA9PT0gdm9pZCAwKSB7IHJlcGVhdCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGVsO1xuICAgICAgICB2YXIgcmVzaXplU2NhbGU7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICBlbCA9IHRoaXMudmFsdWVUZXh0RWw7XG4gICAgICAgICAgICByZXNpemVTY2FsZSA9IHRoaXMudmFsdWVSZXNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsID0gdGhpcy51bml0c1RleHRFbDtcbiAgICAgICAgICAgIHJlc2l6ZVNjYWxlID0gdGhpcy51bml0c1Jlc2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IGVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9sZFNjYWxlID0gcmVzaXplU2NhbGU7XG4gICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMuZGltcy53aWR0aDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KHRoaXMuZGltcy5oZWlnaHQgLyAyIC0gMTUsIDApO1xuICAgICAgICB2YXIgcmVzaXplU2NhbGVXaWR0aCA9IE1hdGguZmxvb3IoKGF2YWlsYWJsZVdpZHRoIC8gKHdpZHRoIC8gcmVzaXplU2NhbGUpKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIHZhciByZXNpemVTY2FsZUhlaWdodCA9IE1hdGguZmxvb3IoKGF2YWlsYWJsZUhlaWdodCAvIChoZWlnaHQgLyByZXNpemVTY2FsZSkpICogMTAwKSAvIDEwMDtcbiAgICAgICAgcmVzaXplU2NhbGUgPSBNYXRoLm1pbihyZXNpemVTY2FsZUhlaWdodCwgcmVzaXplU2NhbGVXaWR0aCk7XG4gICAgICAgIGlmIChyZXNpemVTY2FsZSAhPT0gb2xkU2NhbGUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVJlc2l6ZVNjYWxlID0gcmVzaXplU2NhbGU7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVRleHRUcmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgcmVzaXplU2NhbGUgKyBcIiwgXCIgKyByZXNpemVTY2FsZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bml0c1Jlc2l6ZVNjYWxlID0gcmVzaXplU2NhbGU7XG4gICAgICAgICAgICAgICAgdGhpcy51bml0c1RleHRUcmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgcmVzaXplU2NhbGUgKyBcIiwgXCIgKyByZXNpemVTY2FsZSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NhbGVUZXh0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHtcbiAgICAgICAgICAgIG5hbWU6ICdWYWx1ZScsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIFt0aGlzLnZhbHVlXSwgdGhpcy5jdXN0b21Db2xvcnMpO1xuICAgIH07XG4gICAgdmFyIF9hLCBfYjtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ1bml0c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmV2aW91c1ZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBWaWV3Q2hpbGQoJ3ZhbHVlVGV4dEVsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVUZXh0RWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKCd1bml0c1RleHRFbCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInVuaXRzVGV4dEVsXCIsIHZvaWQgMCk7XG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1saW5lYXItZ2F1Z2UnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIiBbc2hvd0xlZ2VuZF09XFxcImZhbHNlXFxcIiBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiIChjbGljayk9XFxcIm9uQ2xpY2soKVxcXCI+XFxuICAgICAgPHN2ZzpnIGNsYXNzPVxcXCJsaW5lYXItZ2F1Z2UgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtYmFyXFxuICAgICAgICAgIGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWJhclxcXCJcXG4gICAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgICAgW2hlaWdodF09XFxcIjNcXFwiXFxuICAgICAgICAgIFt4XT1cXFwibWFyZ2luWzNdXFxcIlxcbiAgICAgICAgICBbeV09XFxcImRpbXMuaGVpZ2h0IC8gMiArIG1hcmdpblswXSAtIDJcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwie31cXFwiXFxuICAgICAgICAgIFtvcmllbnRhdGlvbl09XFxcIidob3Jpem9udGFsJ1xcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWJhclxcbiAgICAgICAgICBbd2lkdGhdPVxcXCJ2YWx1ZVNjYWxlKHZhbHVlKVxcXCJcXG4gICAgICAgICAgW2hlaWdodF09XFxcIjNcXFwiXFxuICAgICAgICAgIFt4XT1cXFwibWFyZ2luWzNdXFxcIlxcbiAgICAgICAgICBbeV09XFxcImRpbXMuaGVpZ2h0IC8gMiArIG1hcmdpblswXSAtIDJcXFwiXFxuICAgICAgICAgIFtmaWxsXT1cXFwiY29sb3JzLmdldENvbG9yKHVuaXRzKVxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJ7fVxcXCJcXG4gICAgICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ2hvcml6b250YWwnXFxcIlxcbiAgICAgICAgICBbcm91bmRFZGdlc109XFxcInRydWVcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcblxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgICpuZ0lmPVxcXCJoYXNQcmV2aW91c1ZhbHVlXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1MaW5lXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgeTE9XFxcIjVcXFwiXFxuICAgICAgICAgIHgyPVxcXCIwXFxcIlxcbiAgICAgICAgICB5Mj1cXFwiMTVcXFwiXFxuICAgICAgICAgIFthdHRyLnN0cm9rZV09XFxcImNvbG9ycy5nZXRDb2xvcih1bml0cylcXFwiXFxuICAgICAgICAvPlxcblxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgICpuZ0lmPVxcXCJoYXNQcmV2aW91c1ZhbHVlXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1MaW5lXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgeTE9XFxcIi01XFxcIlxcbiAgICAgICAgICB4Mj1cXFwiMFxcXCJcXG4gICAgICAgICAgeTI9XFxcIi0xNVxcXCJcXG4gICAgICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwiY29sb3JzLmdldENvbG9yKHVuaXRzKVxcXCJcXG4gICAgICAgIC8+XFxuXFxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInZhbHVlVHJhbnNsYXRlXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAgICN2YWx1ZVRleHRFbFxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgW3N0eWxlLnRleHRBbmNob3JdPVxcXCInbWlkZGxlJ1xcXCJcXG4gICAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInZhbHVlVGV4dFRyYW5zZm9ybVxcXCJcXG4gICAgICAgICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiYWZ0ZXItZWRnZVxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICB7eyBkaXNwbGF5VmFsdWUgfX1cXG4gICAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidW5pdHNUcmFuc2xhdGVcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICAgI3VuaXRzVGV4dEVsXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwidW5pdHNcXFwiXFxuICAgICAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcIidtaWRkbGUnXFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidW5pdHNUZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJiZWZvcmUtZWRnZVxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICB7eyB1bml0cyB9fVxcbiAgICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLCBcIi5saW5lYXItZ2F1Z2V7Y3Vyc29yOnBvaW50ZXJ9LmxpbmVhci1nYXVnZSAuYmFja2dyb3VuZC1iYXIgcGF0aHtmaWxsOnJnYmEoMCwwLDAsLjA1KX0ubGluZWFyLWdhdWdlIC51bml0c3tmaWxsOiM2NjZ9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQpO1xuICAgIHJldHVybiBMaW5lYXJHYXVnZUNvbXBvbmVudDtcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XG5cbnZhciBHYXVnZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2F1Z2VDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2F1Z2VDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xuICAgICAgICBfdGhpcy5taW4gPSAwO1xuICAgICAgICBfdGhpcy5tYXggPSAxMDA7XG4gICAgICAgIF90aGlzLmJpZ1NlZ21lbnRzID0gMTA7XG4gICAgICAgIF90aGlzLnNtYWxsU2VnbWVudHMgPSA1O1xuICAgICAgICBfdGhpcy5zaG93QXhpcyA9IHRydWU7XG4gICAgICAgIF90aGlzLnN0YXJ0QW5nbGUgPSAtMTIwO1xuICAgICAgICBfdGhpcy5hbmdsZVNwYW4gPSAyNDA7XG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnNob3dUZXh0ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIF90aGlzLnJlc2l6ZVNjYWxlID0gMTtcbiAgICAgICAgX3RoaXMucm90YXRpb24gPSAnJztcbiAgICAgICAgX3RoaXMudGV4dFRyYW5zZm9ybSA9ICdzY2FsZSgxLCAxKSc7XG4gICAgICAgIF90aGlzLmNvcm5lclJhZGl1cyA9IDEwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KCk7IH0pO1xuICAgIH07XG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dBeGlzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luID0gWzYwLCAxMDAsIDYwLCAxMDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICUgMzYwKSArIDM2MDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuZ2xlU3BhbiA9IE1hdGgubWluKHRoaXMuYW5nbGVTcGFuLCAzNjApO1xuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tYWluID0gdGhpcy5nZXREb21haW4oKTtcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcbiAgICAgICAgdGhpcy52YWx1ZVNjYWxlID0gdGhpcy5nZXRWYWx1ZVNjYWxlKCk7XG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5nZXREaXNwbGF5VmFsdWUoKTtcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IE1hdGgubWluKHRoaXMuZGltcy53aWR0aCwgdGhpcy5kaW1zLmhlaWdodCkgLyAyO1xuICAgICAgICB0aGlzLmFyY3MgPSB0aGlzLmdldEFyY3MoKTtcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5tYXJnaW5bM10gKyB0aGlzLmRpbXMud2lkdGggLyAyO1xuICAgICAgICB2YXIgeU9mZnNldCA9IHRoaXMubWFyZ2luWzBdICsgdGhpcy5kaW1zLmhlaWdodCAvIDI7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4T2Zmc2V0ICsgXCIsIFwiICsgeU9mZnNldCArIFwiKVwiO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gXCJyb3RhdGUoXCIgKyB0aGlzLnN0YXJ0QW5nbGUgKyBcIilcIjtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2FsZVRleHQoKTsgfSwgNTApO1xuICAgIH07XG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldEFyY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmNzID0gW107XG4gICAgICAgIHZhciBhdmFpbGFibGVSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzICogMC43O1xuICAgICAgICB2YXIgcmFkaXVzUGVyQXJjID0gTWF0aC5taW4oYXZhaWxhYmxlUmFkaXVzIC8gdGhpcy5yZXN1bHRzLmxlbmd0aCwgMTApO1xuICAgICAgICB2YXIgYXJjV2lkdGggPSByYWRpdXNQZXJBcmMgKiAwLjc7XG4gICAgICAgIHRoaXMudGV4dFJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSB0aGlzLnJlc3VsdHMubGVuZ3RoICogcmFkaXVzUGVyQXJjO1xuICAgICAgICB0aGlzLmNvcm5lclJhZGl1cyA9IE1hdGguZmxvb3IoYXJjV2lkdGggLyAyKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGQgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgb3V0ZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gaSAqIHJhZGl1c1BlckFyYztcbiAgICAgICAgICAgIHZhciBpbm5lclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gYXJjV2lkdGg7XG4gICAgICAgICAgICB2YXIgYmFja2dyb3VuZEFyYyA9IHtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogKHRoaXMuYW5nbGVTcGFuICogTWF0aC5QSSkgLyAxODAsXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLm1heCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5uYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUFyYyA9IHtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogKE1hdGgubWluKHRoaXMudmFsdWVTY2FsZShkLnZhbHVlKSwgdGhpcy5hbmdsZVNwYW4pICogTWF0aC5QSSkgLyAxODAsXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFyYyQkMSA9IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQXJjOiBiYWNrZ3JvdW5kQXJjLFxuICAgICAgICAgICAgICAgIHZhbHVlQXJjOiB2YWx1ZUFyY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFyY3MucHVzaChhcmMkJDEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmNzO1xuICAgIH07XG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XG4gICAgfTtcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcbiAgICAgICAgdmFyIGRhdGFNaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgICAgICB2YXIgZGF0YU1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgIGlmICh0aGlzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1pbiA9IE1hdGgubWluKHRoaXMubWluLCBkYXRhTWluKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWluID0gZGF0YU1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgZGF0YU1heCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1heCA9IGRhdGFNYXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLm1pbiwgdGhpcy5tYXhdO1xuICAgIH07XG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuYW5nbGVTcGFuXSlcbiAgICAgICAgICAgIC5uaWNlKClcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XG4gICAgfTtcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGlzcGxheVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9LCAwKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dFZhbHVlICYmIDAgIT09IHRoaXMudGV4dFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUZvcm1hdHRpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgIH07XG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnNjYWxlVGV4dCA9IGZ1bmN0aW9uIChyZXBlYXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJlcGVhdCA9PT0gdm9pZCAwKSB7IHJlcGVhdCA9IHRydWU7IH1cbiAgICAgICAgaWYgKCF0aGlzLnNob3dUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy50ZXh0RWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgdmFyIG9sZFNjYWxlID0gdGhpcy5yZXNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjYWxlID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVTcGFjZSA9IHRoaXMudGV4dFJhZGl1cztcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2NhbGUgPSBNYXRoLmZsb29yKChhdmFpbGFibGVTcGFjZSAvICh3aWR0aCAvIHRoaXMucmVzaXplU2NhbGUpKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzaXplU2NhbGUgIT09IG9sZFNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgdGhpcy5yZXNpemVTY2FsZSArIFwiLCBcIiArIHRoaXMucmVzaXplU2NhbGUgKyBcIilcIjtcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2FsZVRleHQoZmFsc2UpOyB9LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcbiAgICB9O1xuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NhbGVUeXBlOiAnb3JkaW5hbCcsXG4gICAgICAgICAgICBjb2xvcnM6IHRoaXMuY29sb3JzLFxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLmRvbWFpbixcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxlZ2VuZFRpdGxlLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XG4gICAgfTtcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcbiAgICB9O1xuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XG4gICAgfTtcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZUFyYy5kYXRhLm5hbWU7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRWYWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ1bml0c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiaWdTZWdtZW50c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFNlZ21lbnRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0F4aXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmdsZVNwYW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93VGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBPdXRwdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgVmlld0NoaWxkKCd0ZXh0RWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0RWxcIiwgdm9pZCAwKTtcbiAgICBHYXVnZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWdhdWdlJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJnYXVnZSBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgYXJjIG9mIGFyY3M7IHRyYWNrQnk6IHRyYWNrQnlcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInJvdGF0aW9uXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1nYXVnZS1hcmNcXG4gICAgICAgICAgICBbYmFja2dyb3VuZEFyY109XFxcImFyYy5iYWNrZ3JvdW5kQXJjXFxcIlxcbiAgICAgICAgICAgIFt2YWx1ZUFyY109XFxcImFyYy52YWx1ZUFyY1xcXCJcXG4gICAgICAgICAgICBbY29ybmVyUmFkaXVzXT1cXFwiY29ybmVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2lzQWN0aXZlXT1cXFwiaXNBY3RpdmUoYXJjLnZhbHVlQXJjLmRhdGEpXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1nYXVnZS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJzaG93QXhpc1xcXCJcXG4gICAgICAgICAgW2JpZ1NlZ21lbnRzXT1cXFwiYmlnU2VnbWVudHNcXFwiXFxuICAgICAgICAgIFtzbWFsbFNlZ21lbnRzXT1cXFwic21hbGxTZWdtZW50c1xcXCJcXG4gICAgICAgICAgW21pbl09XFxcIm1pblxcXCJcXG4gICAgICAgICAgW21heF09XFxcIm1heFxcXCJcXG4gICAgICAgICAgW3JhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICBbYW5nbGVTcGFuXT1cXFwiYW5nbGVTcGFuXFxcIlxcbiAgICAgICAgICBbdmFsdWVTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtzdGFydEFuZ2xlXT1cXFwic3RhcnRBbmdsZVxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwiYXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuXFxuICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgI3RleHRFbFxcbiAgICAgICAgICAqbmdJZj1cXFwic2hvd1RleHRcXFwiXFxuICAgICAgICAgIFtzdHlsZS50ZXh0QW5jaG9yXT1cXFwiJ21pZGRsZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRleHRUcmFuc2Zvcm1cXFwiXFxuICAgICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiY2VudHJhbFxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHRzcGFuIHg9XFxcIjBcXFwiIGR5PVxcXCIwXFxcIj57eyBkaXNwbGF5VmFsdWUgfX08L3RzcGFuPlxcbiAgICAgICAgICA8dHNwYW4geD1cXFwiMFxcXCIgZHk9XFxcIjEuMmVtXFxcIj57eyB1bml0cyB9fTwvdHNwYW4+XFxuICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLCBcIi5nYXVnZSAuYmFja2dyb3VuZC1hcmMgcGF0aHtmaWxsOnJnYmEoMCwwLDAsLjA1KX0uZ2F1Z2UgLmdhdWdlLXRpY2sgcGF0aHtzdHJva2U6IzY2Nn0uZ2F1Z2UgLmdhdWdlLXRpY2sgdGV4dHtmb250LXNpemU6MTJweDtmaWxsOiM2NjY7Zm9udC13ZWlnaHQ6NzAwfS5nYXVnZSAuZ2F1Z2UtdGljay1sYXJnZSBwYXRoe3N0cm9rZS13aWR0aDoycHh9LmdhdWdlIC5nYXVnZS10aWNrLXNtYWxsIHBhdGh7c3Ryb2tlLXdpZHRoOjFweH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSlcbiAgICBdLCBHYXVnZUNvbXBvbmVudCk7XG4gICAgcmV0dXJuIEdhdWdlQ29tcG9uZW50O1xufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcblxudmFyIEdhdWdlQXJjQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhdWdlQXJjQ29tcG9uZW50KCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZS50b29sdGlwVGV4dCA9IGZ1bmN0aW9uIChhcmMkJDEpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gZm9ybWF0TGFiZWwoYXJjJCQxLmRhdGEubmFtZSk7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlRm9ybWF0dGluZykge1xuICAgICAgICAgICAgdmFsID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcoYXJjJCQxLmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gZm9ybWF0TGFiZWwoYXJjJCQxLmRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGVzY2FwZUxhYmVsKGxhYmVsKSArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWwgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XG4gICAgfTtcbiAgICB2YXIgX2EsIF9iO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQXJjXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQXJjXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBDb2xvckhlbHBlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDb2xvckhlbHBlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgT3V0cHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIE91dHB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XG4gICAgR2F1Z2VBcmNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWdhdWdlLWFyY10nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXBpZS1hcmNcXG4gICAgICBjbGFzcz1cXFwiYmFja2dyb3VuZC1hcmNcXFwiXFxuICAgICAgW3N0YXJ0QW5nbGVdPVxcXCIwXFxcIlxcbiAgICAgIFtlbmRBbmdsZV09XFxcImJhY2tncm91bmRBcmMuZW5kQW5nbGVcXFwiXFxuICAgICAgW2lubmVyUmFkaXVzXT1cXFwiYmFja2dyb3VuZEFyYy5pbm5lclJhZGl1c1xcXCJcXG4gICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJiYWNrZ3JvdW5kQXJjLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgIFtjb3JuZXJSYWRpdXNdPVxcXCJjb3JuZXJSYWRpdXNcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJiYWNrZ3JvdW5kQXJjLmRhdGFcXFwiXFxuICAgICAgW2FuaW1hdGVdPVxcXCJmYWxzZVxcXCJcXG4gICAgICBbcG9pbnRlckV2ZW50c109XFxcImZhbHNlXFxcIj5cXG4gICAgPC9zdmc6Zz5cXG4gICAgPHN2ZzpnIG5neC1jaGFydHMtcGllLWFyY1xcbiAgICAgIFtzdGFydEFuZ2xlXT1cXFwiMFxcXCJcXG4gICAgICBbZW5kQW5nbGVdPVxcXCJ2YWx1ZUFyYy5lbmRBbmdsZVxcXCJcXG4gICAgICBbaW5uZXJSYWRpdXNdPVxcXCJ2YWx1ZUFyYy5pbm5lclJhZGl1c1xcXCJcXG4gICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJ2YWx1ZUFyYy5vdXRlclJhZGl1c1xcXCJcXG4gICAgICBbY29ybmVyUmFkaXVzXT1cXFwiY29ybmVyUmFkaXVzXFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiY29sb3JzLmdldENvbG9yKHZhbHVlQXJjLmRhdGEubmFtZSlcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJ2YWx1ZUFyYy5kYXRhXFxcIlxcbiAgICAgIFthbmltYXRlXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICBbaXNBY3RpdmVdPVxcXCJpc0FjdGl2ZVxcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwic2VsZWN0LmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IHRvb2x0aXBUZXh0KHZhbHVlQXJjKVxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcInZhbHVlQXJjLmRhdGFcXFwiPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSlcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudCk7XG4gICAgcmV0dXJuIEdhdWdlQXJjQ29tcG9uZW50O1xufSgpKTtcblxudmFyIEdhdWdlQXhpc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHYXVnZUF4aXNDb21wb25lbnQoKSB7XG4gICAgICAgIHRoaXMucm90YXRlID0gJyc7XG4gICAgfVxuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm90YXRpb25BbmdsZSA9IC05MCArIHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgdGhpcy5yb3RhdGUgPSBcInJvdGF0ZShcIiArIHRoaXMucm90YXRpb25BbmdsZSArIFwiKVwiO1xuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuICAgIH07XG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUaWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJpZ1RpY2tTZWdtZW50ID0gdGhpcy5hbmdsZVNwYW4gLyB0aGlzLmJpZ1NlZ21lbnRzO1xuICAgICAgICB2YXIgc21hbGxUaWNrU2VnbWVudCA9IGJpZ1RpY2tTZWdtZW50IC8gKHRoaXMuc21hbGxTZWdtZW50cyk7XG4gICAgICAgIHZhciB0aWNrTGVuZ3RoID0gMjA7XG4gICAgICAgIHZhciB0aWNrcyA9IHtcbiAgICAgICAgICAgIGJpZzogW10sXG4gICAgICAgICAgICBzbWFsbDogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YXJ0RGlzdGFuY2UgPSB0aGlzLnJhZGl1cyArIDEwO1xuICAgICAgICB2YXIgdGV4dERpc3QgPSBzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCArIDEwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0aGlzLmJpZ1NlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbmdsZURlZyA9IGkgKiBiaWdUaWNrU2VnbWVudDtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGFuZ2xlRGVnICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgIHZhciB0ZXh0QW5jaG9yID0gdGhpcy5nZXRUZXh0QW5jaG9yKGFuZ2xlRGVnKTtcbiAgICAgICAgICAgIHZhciBza2lwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiB0aGlzLmFuZ2xlU3BhbiA9PT0gMzYwKSB7XG4gICAgICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMudmFsdWVTY2FsZS5pbnZlcnQoYW5nbGVEZWcpLnRvU3RyaW5nKCkpLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMudGlja0Zvcm1hdHRpbmcodGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpY2tzLmJpZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5nZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoLCBhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRUcmFuc2Zvcm06IFwiXFxuICAgICAgICAgICAgdHJhbnNsYXRlKFwiICsgdGV4dERpc3QgKiBNYXRoLmNvcyhhbmdsZSkgKyBcIiwgXCIgKyB0ZXh0RGlzdCAqIE1hdGguc2luKGFuZ2xlKSArIFwiKSByb3RhdGUoXCIgKyAtdGhpcy5yb3RhdGlvbkFuZ2xlICsgXCIpXFxuICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5iaWdTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPD0gdGhpcy5zbWFsbFNlZ21lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxBbmdsZURlZyA9IGFuZ2xlRGVnICsgaiAqIHNtYWxsVGlja1NlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsQW5nbGUgPSBzbWFsbEFuZ2xlRGVnICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICAgICAgICB0aWNrcy5zbWFsbC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5nZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoIC8gMiwgc21hbGxBbmdsZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLmdldFRleHRBbmNob3IgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgLy8gWzAsIDQ1XSA9ICdtaWRkbGUnO1xuICAgICAgICAvLyBbNDYsIDEzNV0gPSAnc3RhcnQnO1xuICAgICAgICAvLyBbMTM2LCAyMjVdID0gJ21pZGRsZSc7XG4gICAgICAgIC8vIFsyMjYsIDMxNV0gPSAnZW5kJztcbiAgICAgICAgYW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgYW5nbGUpICUgMzYwO1xuICAgICAgICB2YXIgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICBpZiAoYW5nbGUgPiA0NSAmJiBhbmdsZSA8PSAxMzUpIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFuZ2xlID4gMjI1ICYmIGFuZ2xlIDw9IDMxNSkge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0QW5jaG9yO1xuICAgIH07XG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUaWNrUGF0aCA9IGZ1bmN0aW9uIChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoLCBhbmdsZSkge1xuICAgICAgICB2YXIgeTEgPSBzdGFydERpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgeTIgPSAoc3RhcnREaXN0YW5jZSArIHRpY2tMZW5ndGgpICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgeDEgPSBzdGFydERpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgeDIgPSAoc3RhcnREaXN0YW5jZSArIHRpY2tMZW5ndGgpICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgcG9pbnRzID0gW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dO1xuICAgICAgICB2YXIgbGluZUdlbmVyYXRvciA9IGxpbmUoKS54KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLng7IH0pLnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQueTsgfSk7XG4gICAgICAgIHJldHVybiBsaW5lR2VuZXJhdG9yKHBvaW50cyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImJpZ1NlZ21lbnRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFNlZ21lbnRzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBJbnB1dCgpLFxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5nbGVTcGFuXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIElucHV0KCksXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlU2NhbGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgSW5wdXQoKSxcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudCh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1nYXVnZS1heGlzXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInJvdGF0ZVxcXCI+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrcy5iaWdcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1sYXJnZVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpwYXRoIFthdHRyLmRdPVxcXCJ0aWNrLmxpbmVcXFwiIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3MuYmlnXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJnYXVnZS10aWNrIGdhdWdlLXRpY2stbGFyZ2VcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcInRpY2sudGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGljay50ZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImNlbnRyYWxcXFwiPlxcbiAgICAgICAgICAgICAgICB7e3RpY2sudGV4dH19XFxuICAgICAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrcy5zbWFsbFxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiZ2F1Z2UtdGljayBnYXVnZS10aWNrLXNtYWxsXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOnBhdGggW2F0dHIuZF09XFxcInRpY2subGluZVxcXCIgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50KTtcbiAgICByZXR1cm4gR2F1Z2VBeGlzQ29tcG9uZW50O1xufSgpKTtcblxudmFyIEdhdWdlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdhdWdlTW9kdWxlKCkge1xuICAgIH1cbiAgICBHYXVnZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBOZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGUsIFBpZUNoYXJ0TW9kdWxlLCBCYXJDaGFydE1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBMaW5lYXJHYXVnZUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBHYXVnZUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBHYXVnZUFyY0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBHYXVnZUF4aXNDb21wb25lbnRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTGluZWFyR2F1Z2VDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgR2F1Z2VDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgR2F1Z2VBcmNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgR2F1Z2VBeGlzQ29tcG9uZW50XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgXSwgR2F1Z2VNb2R1bGUpO1xuICAgIHJldHVybiBHYXVnZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBOZ3hDaGFydHNNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmd4Q2hhcnRzTW9kdWxlKCkge1xuICAgIH1cbiAgICBOZ3hDaGFydHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIENoYXJ0Q29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIEFyZWFDaGFydE1vZHVsZSxcbiAgICAgICAgICAgICAgICBCYXJDaGFydE1vZHVsZSxcbiAgICAgICAgICAgICAgICBCdWJibGVDaGFydE1vZHVsZSxcbiAgICAgICAgICAgICAgICBGb3JjZURpcmVjdGVkR3JhcGhNb2R1bGUsXG4gICAgICAgICAgICAgICAgSGVhdE1hcE1vZHVsZSxcbiAgICAgICAgICAgICAgICBMaW5lQ2hhcnRNb2R1bGUsXG4gICAgICAgICAgICAgICAgUG9sYXJDaGFydE1vZHVsZSxcbiAgICAgICAgICAgICAgICBOdW1iZXJDYXJkTW9kdWxlLFxuICAgICAgICAgICAgICAgIFBpZUNoYXJ0TW9kdWxlLFxuICAgICAgICAgICAgICAgIFRyZWVNYXBNb2R1bGUsXG4gICAgICAgICAgICAgICAgR2F1Z2VNb2R1bGVcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICBdLCBOZ3hDaGFydHNNb2R1bGUpO1xuICAgIHJldHVybiBOZ3hDaGFydHNNb2R1bGU7XG59KCkpO1xuXG5mdW5jdGlvbiB0aWNrRm9ybWF0KGZpZWxkVHlwZSwgZ3JvdXBCeVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gJ05vIFZhbHVlJyB8fCBsYWJlbCA9PT0gJ090aGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUgPT09ICdkYXRlJyAmJiBncm91cEJ5VHlwZSA9PT0gJ2dyb3VwQnknKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdGltZUZvcm1hdCgnTU0vREQvWVlZWScpO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcihsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVsLnRvU3RyaW5nKCk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgTmd4Q2hhcnRzTW9kdWxlLCBDaGFydENvbW1vbk1vZHVsZSwgTGVnZW5kQ29tcG9uZW50LCBTY2FsZUxlZ2VuZENvbXBvbmVudCwgTGVnZW5kRW50cnlDb21wb25lbnQsIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LCBUb29sdGlwTW9kdWxlLCBUb29sdGlwU2VydmljZSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQsIFRvb2x0aXBEaXJlY3RpdmUsIFN0eWxlVHlwZXMsIEFsaWdubWVudFR5cGVzLCBTaG93VHlwZXMsIEF4ZXNNb2R1bGUsIEF4aXNMYWJlbENvbXBvbmVudCwgWEF4aXNDb21wb25lbnQsIFhBeGlzVGlja3NDb21wb25lbnQsIFlBeGlzQ29tcG9uZW50LCBZQXhpc1RpY2tzQ29tcG9uZW50LCByZWR1Y2VUaWNrcywgQ291bnRVcERpcmVjdGl2ZSwgY291bnQsIGRlY2ltYWxDaGVja2VyLCBUaW1lbGluZSwgQ29sb3JIZWxwZXIsIENoYXJ0Q29tcG9uZW50LCBBcmVhQ29tcG9uZW50LCBCYXNlQ2hhcnRDb21wb25lbnQsIENpcmNsZUNvbXBvbmVudCwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LCBncmlkU2l6ZSwgZ3JpZExheW91dCwgR3JpZFBhbmVsQ29tcG9uZW50LCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQsIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCwgVG9vbHRpcEFyZWEsIHRpY2tGb3JtYXQsIHRyaW1MYWJlbCwgY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMsIGZvcm1hdExhYmVsLCBlc2NhcGVMYWJlbCwgZ2V0VW5pcXVlWERvbWFpblZhbHVlcywgZ2V0U2NhbGVUeXBlLCBBcmVhQ2hhcnRNb2R1bGUsIEFyZWFDaGFydENvbXBvbmVudCwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCwgQXJlYVNlcmllc0NvbXBvbmVudCwgQmFyQ2hhcnRNb2R1bGUsIEJhckNvbXBvbmVudCwgQmFySG9yaXpvbnRhbENvbXBvbmVudCwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQsIFNlcmllc0hvcml6b250YWwsIEJhckxhYmVsQ29tcG9uZW50LCBCYXJWZXJ0aWNhbENvbXBvbmVudCwgQmFyVmVydGljYWwyRENvbXBvbmVudCwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQsIEQwVHlwZXMsIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LCBCdWJibGVDaGFydE1vZHVsZSwgQnViYmxlQ2hhcnRDb21wb25lbnQsIGdldERvbWFpbiwgZ2V0U2NhbGUsIEJ1YmJsZVNlcmllc0NvbXBvbmVudCwgRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQsIEhlYXRNYXBNb2R1bGUsIEhlYXRNYXBDb21wb25lbnQsIEhlYXRNYXBDZWxsQ29tcG9uZW50LCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudCwgTGluZUNoYXJ0TW9kdWxlLCBMaW5lQ2hhcnRDb21wb25lbnQsIExpbmVDb21wb25lbnQsIExpbmVTZXJpZXNDb21wb25lbnQsIFBvbGFyQ2hhcnRNb2R1bGUsIFBvbGFyQ2hhcnRDb21wb25lbnQsIFBvbGFyU2VyaWVzQ29tcG9uZW50LCBOdW1iZXJDYXJkTW9kdWxlLCBOdW1iZXJDYXJkQ29tcG9uZW50LCBDYXJkQ29tcG9uZW50LCBDYXJkU2VyaWVzQ29tcG9uZW50LCBQaWVDaGFydE1vZHVsZSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCwgUGllQ2hhcnRDb21wb25lbnQsIFBpZUFyY0NvbXBvbmVudCwgUGllR3JpZENvbXBvbmVudCwgUGllR3JpZFNlcmllc0NvbXBvbmVudCwgUGllU2VyaWVzQ29tcG9uZW50LCBQaWVMYWJlbENvbXBvbmVudCwgVHJlZU1hcE1vZHVsZSwgVHJlZU1hcENvbXBvbmVudCwgVHJlZU1hcENlbGxDb21wb25lbnQsIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LCBHYXVnZU1vZHVsZSwgR2F1Z2VBcmNDb21wb25lbnQsIEdhdWdlQXhpc0NvbXBvbmVudCwgR2F1Z2VDb21wb25lbnQsIExpbmVhckdhdWdlQ29tcG9uZW50IH07XG4iXX0=
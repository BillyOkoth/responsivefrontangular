import { Directive, Input, forwardRef, NgModule } from '@angular/core';
import { NG_VALIDATORS, Validators } from '@angular/forms';
import { delay } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class AbstractControlUtil {
    /**
     * @param {?} control
     * @return {?}
     */
    static isNotPresent(control) {
        /** @type {?} */
        let value = control.value;
        if (value === undefined || value === null) {
            return true;
        }
        return value !== '' ? false : true;
    }
    ;
    /**
     * @param {?} control
     * @param {?} errorId
     * @param {?} value
     * @return {?}
     */
    static addError(control, errorId, value) {
        if (!control.errors) {
            control.setErrors({ [errorId]: value });
        }
        else if (!control.hasError(errorId)) {
            control.errors[errorId] = value;
        }
    }
    /**
     * @param {?} control
     * @param {?} errorId
     * @return {?}
     */
    static removeError(control, errorId) {
        if (control.errors && control.hasError(errorId)) {
            if (Object.keys(control.errors).length > 1) {
                delete control.errors[errorId];
            }
            else {
                control.setErrors(null);
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
// tslint:disable-next-line:variable-name
class PasswordValidators {
    /**
     * @param {?} repeatCount
     * @return {?}
     */
    static repeatCharacterRegexRule(repeatCount) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let repeatDec = repeatCount - 1;
            /** @type {?} */
            let pattern = '([^\\x00-\\x1F])\\1{' + repeatDec + '}';
            if (control.value !== '' && new RegExp(pattern).test(control.value)) {
                return { 'repeatCharacterRegexRule': { 'repeatCount': repeatCount } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?} allowedChars
     * @return {?}
     */
    static allowedCharacterRule(allowedChars) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            /** @type {?} */
            let valid = true;
            /** @type {?} */
            let invalidChars = [];
            for (let char of value) {
                if (allowedChars.indexOf(char) === -1) {
                    valid = false;
                    if (invalidChars.indexOf(char) === -1) {
                        invalidChars.push(char);
                    }
                }
            }
            if (!valid) {
                return { 'allowedCharacterRule': { 'invalidChars': invalidChars, 'allowedChars': allowedChars } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?} amount
     * @return {?}
     */
    static alphabeticalCharacterRule(amount) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            let pattern = /[^A-Za-z]+/g;
            /** @type {?} */
            let stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'alphabeticalCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?} amount
     * @return {?}
     */
    static digitCharacterRule(amount) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            let pattern = /[^0-9\.]+/g;
            /** @type {?} */
            let stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'digitCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?} amount
     * @return {?}
     */
    static lowercaseCharacterRule(amount) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            let pattern = /[^a-z]+/g;
            /** @type {?} */
            let stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'lowercaseCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?} amount
     * @return {?}
     */
    static uppercaseCharacterRule(amount) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            let pattern = /[^A-Z]+/g;
            /** @type {?} */
            let stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'uppercaseCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?} amount
     * @return {?}
     */
    static specialCharacterRule(amount) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            let pattern = /[\w\s]+/g;
            /** @type {?} */
            let stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'specialCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    }
    ;
    /**
     * @param {?=} passwordControlName
     * @param {?=} confirmPasswordControlName
     * @return {?}
     */
    static mismatchedPasswords(passwordControlName, confirmPasswordControlName) {
        /** @type {?} */
        const validator = (group) => {
            /** @type {?} */
            let newPasswordValue = group.get(passwordControlName ? passwordControlName : 'newPassword').value;
            /** @type {?} */
            let newPasswordConfirmValue = group.get(confirmPasswordControlName ? confirmPasswordControlName : 'confirmPassword').value;
            if (newPasswordValue !== newPasswordConfirmValue) {
                AbstractControlUtil.addError(group.get(confirmPasswordControlName ? confirmPasswordControlName : 'confirmPassword'), 'mismatchedPasswords', true);
                return { 'mismatchedPasswords': true };
            }
            else {
                AbstractControlUtil.removeError(group.get(confirmPasswordControlName ? confirmPasswordControlName : 'confirmPassword'), 'mismatchedPasswords');
            }
            return undefined;
        };
        return validator;
    }
    ;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class EmailSuggestion {
    constructor() {
        this.defaultOptions = {
            domains: ['msn.com', 'bellsouth.net',
                'telus.net', 'comcast.net', 'optusnet.com.au',
                'earthlink.net', 'qq.com', 'sky.com', 'icloud.com',
                'mac.com', 'sympatico.ca', 'googlemail.com',
                'att.net', 'xtra.co.nz', 'web.de',
                'cox.net', 'gmail.com', 'ymail.com', 'yahoo.com',
                'aim.com', 'rogers.com', 'verizon.net',
                'rocketmail.com', 'google.com', 'optonline.net',
                'sbcglobal.net', 'aol.com', 'me.com', 'btinternet.com',
                'charter.net', 'shaw.ca'],
            secondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],
            topLevelDomains: ["com", "com.au", "com.tw", "ca", "co.nz", "co.uk", "de",
                "fr", "it", "ru", "net", "org", "edu", "gov", "jp", "nl", "kr", "se", "eu",
                "ie", "co.il", "us", "at", "be", "dk", "hk", "es", "gr", "ch", "no", "cz",
                "in", "net", "net.au", "info", "biz", "mil", "co.jp", "sg", "hu", "uk"]
        };
    }
    /**
     * @param {?} email
     * @param {?=} options
     * @return {?}
     */
    suggest(email, options) {
        /** @type {?} */
        let opt = this.defaultOptions;
        if (options != undefined) {
            opt = options;
        }
        /** @type {?} */
        let emailParts = this.splitEmail(email.toLowerCase());
        if (!emailParts) {
            return undefined;
        }
        if (opt.secondLevelDomains && opt.topLevelDomains) {
            // If the email is a valid 2nd-level + top-level, do not suggest anything.
            if (opt.secondLevelDomains.indexOf(emailParts.secondLevelDomain) !== -1 && opt.topLevelDomains.indexOf(emailParts.topLevelDomain) !== -1) {
                return undefined;
            }
        }
        /** @type {?} */
        let closestDomain = this.findClosestDomain(emailParts.domain, opt.domains, 2);
        if (closestDomain) {
            if (closestDomain == emailParts.domain) {
                // The email address exactly matches one of the supplied domains; do not return a suggestion.
                return undefined;
            }
            else {
                // The email address closely matches one of the supplied domains; return a suggestion
                return { suggestion: { address: emailParts.address, domain: closestDomain, full: emailParts.address + "@" + closestDomain } };
            }
        }
        /** @type {?} */
        let closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, opt.secondLevelDomains, 2);
        /** @type {?} */
        let closestTopLevelDomain = this.findClosestDomain(emailParts.topLevelDomain, opt.topLevelDomains, 2);
        if (emailParts.domain) {
            closestDomain = emailParts.domain;
            /** @type {?} */
            let rtrn = false;
            if (closestSecondLevelDomain && closestSecondLevelDomain != emailParts.secondLevelDomain) {
                // The email address may have a mispelled second-level domain; return a suggestion
                closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain);
                rtrn = true;
            }
            if (closestTopLevelDomain && closestTopLevelDomain != emailParts.topLevelDomain && emailParts.secondLevelDomain !== '') {
                // The email address may have a mispelled top-level domain; return a suggestion
                closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain);
                rtrn = true;
            }
            if (rtrn) {
                return { suggestion: { address: emailParts.address, domain: closestDomain, full: emailParts.address + "@" + closestDomain } };
            }
        }
        /* The email address exactly matches one of the supplied domains, does not closely
         * match any domain and does not appear to simply have a mispelled top-level domain,
         * or is an invalid email address; do not return a suggestion.
         */
        return undefined;
    }
    ;
    /**
     * @param {?} email
     * @return {?}
     */
    splitEmail(email) {
        /** @type {?} */
        let parts = email.trim().split('@');
        if (parts.length < 2) {
            return undefined;
        }
        for (var i = 0; i < parts.length; i++) {
            if (parts[i] === '') {
                return undefined;
            }
        }
        /** @type {?} */
        let result = {
            topLevelDomain: "",
            secondLevelDomain: "",
            domain: parts.pop(),
            address: ''
        };
        /** @type {?} */
        let domainParts = result.domain.split('.');
        if (domainParts.length === 0) {
            return undefined;
        }
        else if (domainParts.length == 1) {
            result.topLevelDomain = domainParts[0];
        }
        else {
            // The address has a domain and a top-level domain
            result.secondLevelDomain = domainParts[0];
            for (let j = 1; j < domainParts.length; j++) {
                result.topLevelDomain += domainParts[j] + '.';
            }
            result.topLevelDomain = result.topLevelDomain.substring(0, result.topLevelDomain.length - 1);
        }
        result.address = parts.join('@');
        return result;
    }
    /**
     * @param {?} domain
     * @param {?} domains
     * @param {?} threshold
     * @return {?}
     */
    findClosestDomain(domain, domains, threshold) {
        /** @type {?} */
        let dist;
        /** @type {?} */
        let minDist = Infinity;
        /** @type {?} */
        let closestDomain = null;
        if (!domain || !domains) {
            return undefined;
        }
        for (let i = 0; i < domains.length; i++) {
            if (domain === domains[i]) {
                return domain;
            }
            dist = this.sift4Distance(domain, domains[i], 5);
            if (dist < minDist) {
                minDist = dist;
                closestDomain = domains[i];
            }
        }
        if (minDist <= threshold && closestDomain !== null) {
            return closestDomain;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?} s1
     * @param {?} s2
     * @param {?} maxOffset
     * @return {?}
     */
    sift4Distance(s1, s2, maxOffset) {
        // sift4: https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
        if (maxOffset === undefined) {
            maxOffset = 5; //default
        }
        if (!s1 || !s1.length) {
            if (!s2) {
                return 0;
            }
            return s2.length;
        }
        if (!s2 || !s2.length) {
            return s1.length;
        }
        /** @type {?} */
        let l1 = s1.length;
        /** @type {?} */
        let l2 = s2.length;
        /** @type {?} */
        let c1 = 0;
        //cursor for string 1
        /** @type {?} */
        let c2 = 0;
        //cursor for string 2
        /** @type {?} */
        let lcss = 0;
        //largest common subsequence
        /** @type {?} */
        let local_cs = 0;
        //local common substring
        /** @type {?} */
        let trans = 0;
        //number of transpositions ('ab' vs 'ba')
        /** @type {?} */
        let offset_arr = [];
        while ((c1 < l1) && (c2 < l2)) {
            if (s1.charAt(c1) == s2.charAt(c2)) {
                local_cs++;
                /** @type {?} */
                let isTrans = false;
                //see if current match is a transposition
                /** @type {?} */
                let i = 0;
                while (i < offset_arr.length) {
                    /** @type {?} */
                    let ofs = offset_arr[i];
                    if (c1 <= ofs.c1 || c2 <= ofs.c2) {
                        // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                        isTrans = Math.abs(c2 - c1) >= Math.abs(ofs.c2 - ofs.c1);
                        if (isTrans) {
                            trans++;
                        }
                        else {
                            if (!ofs.trans) {
                                ofs.trans = true;
                                trans++;
                            }
                        }
                        break;
                    }
                    else {
                        if (c1 > ofs.c2 && c2 > ofs.c1) {
                            offset_arr.splice(i, 1);
                        }
                        else {
                            i++;
                        }
                    }
                }
                offset_arr.push({
                    c1: c1,
                    c2: c2,
                    trans: isTrans
                });
            }
            else {
                lcss += local_cs;
                local_cs = 0;
                if (c1 != c2) {
                    c1 = c2 = Math.min(c1, c2); //using min allows the computation of transpositions
                }
                //if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
                //so that we can have only one code block handling matches 
                for (let j = 0; j < maxOffset && (c1 + j < l1 || c2 + j < l2); j++) {
                    if ((c1 + j < l1) && (s1.charAt(c1 + j) == s2.charAt(c2))) {
                        c1 += j - 1;
                        c2--;
                        break;
                    }
                    if ((c2 + j < l2) && (s1.charAt(c1) == s2.charAt(c2 + j))) {
                        c1--;
                        c2 += j - 1;
                        break;
                    }
                }
            }
            c1++;
            c2++;
            // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
            if ((c1 >= l1) || (c2 >= l2)) {
                lcss += local_cs;
                local_cs = 0;
                c1 = c2 = Math.min(c1, c2);
            }
        }
        lcss += local_cs;
        return Math.round(Math.max(l1, l2) - lcss + trans); //add the cost of transpositions to the final result
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class EmailValidators {
    /**
     * @param {?} control
     * @return {?}
     */
    static simple(control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        /** @type {?} */
        let pattern = /.+@.+\..+/i;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { 'simpleEmailRule': true };
    }
    ;
    // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    /**
     * @param {?} control
     * @return {?}
     */
    static normal(control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        // tslint:disable-next-line:max-line-length
        /** @type {?} */
        let pattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { 'normalEmailRule': true };
    }
    ;
    /**
     * @param {?=} options
     * @return {?}
     */
    static suggest(options) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control)) {
                return undefined;
            }
            return this.emailSuggestion.suggest(control.value, options);
        };
        return validator;
    }
    ;
}
EmailValidators.emailSuggestion = new EmailSuggestion();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class UniversalValidators {
    /**
     * @param {?} control
     * @return {?}
     */
    static noWhitespace(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        /** @type {?} */
        let pattern = '\\s';
        if (new RegExp(pattern).test(control.value)) {
            return { 'noWhitespaceRequired': true };
        }
        return undefined;
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static noEmptyString(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (control.value.trim().length === 0) {
            return { 'noEmptyString': true };
        }
        return undefined;
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static isNumber(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (isNaN(control.value)) {
            return { 'numberRequired': true };
        }
        return undefined;
    }
    ;
    /**
     * @param {?} minValue
     * @param {?} maxValue
     * @return {?}
     */
    static isInRange(minValue, maxValue) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (isNaN(control.value)) {
                return { 'numberRequired': true };
            }
            if (+control.value < minValue) {
                return { 'rangeValueToSmall': { 'requiredMinValue': minValue, 'requiredMaxValue': maxValue, 'actual': control.value } };
            }
            if (+control.value > maxValue) {
                return { 'rangeValueToBig': { 'requiredMinValue': minValue, 'requiredMaxValue': maxValue, 'actual': control.value } };
            }
            else {
                return undefined;
            }
        };
        return validator;
    }
    ;
    /**
     * @param {?} minLength
     * @return {?}
     */
    static minLength(minLength) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (value.length >= minLength) {
                return undefined;
            }
            return { 'minLength': { 'requiredMinLength': minLength, 'actualLength': value.length } };
        };
        return validator;
    }
    ;
    /**
     * @param {?} maxLength
     * @return {?}
     */
    static maxLength(maxLength) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (maxLength >= value.length) {
                return undefined;
            }
            return { 'maxLength': { 'requiredMaxLength': maxLength, 'actualLength': value.length } };
        };
        return validator;
    }
    ;
    /**
     * @param {?} min
     * @return {?}
     */
    static min(min) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (isNaN(control.value)) {
                return { 'numberRequired': true };
            }
            if (+value >= min) {
                return undefined;
            }
            return { 'min': { 'required': min, 'actual': control.value } };
        };
        return validator;
    }
    ;
    /**
     * @param {?} max
     * @return {?}
     */
    static max(max) {
        /** @type {?} */
        const validator = (control) => {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            let value = control.value;
            if (isNaN(control.value)) {
                return { 'numberRequired': true };
            }
            if (max >= +value) {
                return undefined;
            }
            return { 'max': { 'required': max, 'actual': control.value } };
        };
        return validator;
    }
    ;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const visaRegex = '^(?:4[0-9]{12})(?:[0-9]{3})?$';
/** @type {?} */
const americanExpressRegex = '^(?:3[47][0-9]{13})$';
/** @type {?} */
const maestroRegex = '^(?:(?:5[0678]\\d\\d|6304|6390|67\\d\\d)\\d{8,15})$';
/** @type {?} */
const jcbRegex = '^(?:(?:2131|1800|35\\d{3})\\d{11})$';
/** @type {?} */
const discoverRegex = '^(?:6(?:011|5[0-9]{2})(?:[0-9]{12}))$';
/** @type {?} */
const dinersclubRegex = '^(?:3(?:0[0-5]|[68][0-9])[0-9]{11})$';
/** @type {?} */
const mastercardRegex = '^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$';
class CreditCardValidators {
    /**
     * @param {?} control
     * @return {?}
     */
    static isCreditCard(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex + '|' +
            visaRegex + '|' +
            maestroRegex + '|' +
            jcbRegex + '|' +
            discoverRegex + '|' +
            mastercardRegex + '|' +
            dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { 'creditcard': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static americanExpress(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex).test(control.value)) {
            return undefined;
        }
        return { 'americanExpress': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static dinersclub(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { 'dinersclub': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static discover(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(discoverRegex).test(control.value)) {
            return undefined;
        }
        return { 'discover': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static jcb(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(jcbRegex).test(control.value)) {
            return undefined;
        }
        return { 'jcb': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static maestro(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(maestroRegex).test(control.value)) {
            return undefined;
        }
        return { 'maestro': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static mastercard(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(mastercardRegex).test(control.value)) {
            return undefined;
        }
        return { 'mastercard': true };
    }
    ;
    /**
     * @param {?} control
     * @return {?}
     */
    static visa(control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(visaRegex).test(control.value)) {
            return undefined;
        }
        return { 'visa': true };
    }
    ;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class PasswordValidatorDirective {
    constructor() {
        this.repeatCharacter = 4;
        this.alphabeticalCharacter = 1;
        this.digitCharacter = 1;
        this.lowercaseCharacter = 1;
        this.uppercaseCharacter = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(this.repeatCharacter);
        this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(this.alphabeticalCharacter);
        this.digitCharacterValidator = PasswordValidators.digitCharacterRule(this.digitCharacter);
        this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(this.lowercaseCharacter);
        this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(this.uppercaseCharacter);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        /** @type {?} */
        let compose = Validators.compose([this.repeatCharacterValidator,
            this.digitCharacterValidator, this.alphabeticalCharacterValidator,
            this.lowercaseCharacterValidator, this.uppercaseCharacterValidator]);
        return compose(c);
    }
}
PasswordValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[password][formControlName],[password][formControl],[password][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => PasswordValidatorDirective),
                        multi: true
                    }]
            },] }
];
PasswordValidatorDirective.propDecorators = {
    repeatCharacter: [{ type: Input }],
    alphabeticalCharacter: [{ type: Input }],
    digitCharacter: [{ type: Input }],
    lowercaseCharacter: [{ type: Input }],
    uppercaseCharacter: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class EmailValidatorDirective {
    constructor() {
        this.email = 'normal';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        switch (this.email) {
            case 'simple':
                this.validator = EmailValidators.simple;
                break;
            case 'normal':
                this.validator = EmailValidators.normal;
                break;
            default:
                this.validator = EmailValidators.normal;
                break;
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
EmailValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[email][formControlName],[email][formControl],[email][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => EmailValidatorDirective),
                        multi: true
                    }]
            },] }
];
EmailValidatorDirective.propDecorators = {
    email: [{ type: Input }]
};
class EmailSuggestValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = EmailValidators.suggest(this.emailSuggest);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
EmailSuggestValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[emailSuggest][formControlName],[emailSuggest][formControl],[emailSuggest][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => EmailSuggestValidatorDirective),
                        multi: true
                    }]
            },] }
];
EmailSuggestValidatorDirective.propDecorators = {
    emailSuggest: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class WhiteSpaceValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = UniversalValidators.noWhitespace;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
WhiteSpaceValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => WhiteSpaceValidatorDirective),
                        multi: true
                    }]
            },] }
];
class EmptyStringValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = UniversalValidators.noEmptyString;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
EmptyStringValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => EmptyStringValidatorDirective),
                        multi: true
                    }]
            },] }
];
class IsNumberValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = UniversalValidators.isNumber;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
IsNumberValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => IsNumberValidatorDirective),
                        multi: true
                    }]
            },] }
];
class IsInRangeValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
IsInRangeValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => IsInRangeValidatorDirective),
                        multi: true
                    }]
            },] }
];
IsInRangeValidatorDirective.propDecorators = {
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }]
};
class MaxValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = UniversalValidators.max(this.max);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
MaxValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => MaxValidatorDirective),
                        multi: true
                    }]
            },] }
];
MaxValidatorDirective.propDecorators = {
    max: [{ type: Input }]
};
class MinValidatorDirective {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = UniversalValidators.min(this.min);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
MinValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => MinValidatorDirective),
                        multi: true
                    }]
            },] }
];
MinValidatorDirective.propDecorators = {
    min: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class CreditCardValidatorDirective {
    constructor() {
        this.creditCard = 'all';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        switch (this.creditCard) {
            case 'all':
                this.validator = CreditCardValidators.isCreditCard;
                break;
            case 'americanExpress':
                this.validator = CreditCardValidators.americanExpress;
                break;
            case 'dinersclub':
                this.validator = CreditCardValidators.dinersclub;
                break;
            case 'discover':
                this.validator = CreditCardValidators.discover;
                break;
            case 'jcb':
                this.validator = CreditCardValidators.jcb;
                break;
            case 'maestro':
                this.validator = CreditCardValidators.maestro;
                break;
            case 'mastercard':
                this.validator = CreditCardValidators.mastercard;
                break;
            case 'visa':
                this.validator = CreditCardValidators.visa;
                break;
            default:
                this.validator = CreditCardValidators.isCreditCard;
                break;
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
CreditCardValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => CreditCardValidatorDirective),
                        multi: true
                    }]
            },] }
];
CreditCardValidatorDirective.propDecorators = {
    creditCard: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class EqualToDirective {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        /** @type {?} */
        const otherControl = typeof this.equalTo === 'string' ? c.parent.get(this.equalTo) : this.equalTo;
        if (!this.subscription) {
            this.subscription = otherControl.valueChanges
                .pipe(delay(1)).subscribe(() => {
                c.updateValueAndValidity();
            });
        }
        return c.value !== otherControl.value ? { notEqualTo: true } : null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
EqualToDirective.decorators = [
    { type: Directive, args: [{
                selector: '[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(() => EqualToDirective),
                        multi: true
                    }]
            },] }
];
EqualToDirective.propDecorators = {
    equalTo: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class ValidatorsModule {
}
ValidatorsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CreditCardValidatorDirective,
                    EmailValidatorDirective,
                    EmailSuggestValidatorDirective,
                    PasswordValidatorDirective,
                    IsInRangeValidatorDirective,
                    IsNumberValidatorDirective,
                    MaxValidatorDirective,
                    MinValidatorDirective,
                    WhiteSpaceValidatorDirective,
                    EmptyStringValidatorDirective,
                    EqualToDirective
                ],
                exports: [
                    CreditCardValidatorDirective,
                    EmailValidatorDirective,
                    EmailSuggestValidatorDirective,
                    PasswordValidatorDirective,
                    IsInRangeValidatorDirective,
                    IsNumberValidatorDirective,
                    MaxValidatorDirective,
                    MinValidatorDirective,
                    WhiteSpaceValidatorDirective,
                    EmptyStringValidatorDirective,
                    EqualToDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class EqualToValidator {
    /**
     * @param {?} c1Name
     * @param {?} c2Name
     * @return {?}
     */
    static equalTo(c1Name, c2Name) {
        /** @type {?} */
        const validator = (parent) => {
            /** @type {?} */
            const c1 = parent.get(c1Name);
            /** @type {?} */
            const c2 = parent.get(c2Name);
            if (c1.value === c2.value) {
                AbstractControlUtil.removeError(c2, 'notEqualTo');
            }
            else {
                AbstractControlUtil.addError(c2, 'notEqualTo', true);
            }
        };
        return validator;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { PasswordValidators, EmailValidators, UniversalValidators, CreditCardValidators, PasswordValidatorDirective, EmailValidatorDirective, EmailSuggestValidatorDirective, IsInRangeValidatorDirective, IsNumberValidatorDirective, MaxValidatorDirective, MinValidatorDirective, WhiteSpaceValidatorDirective, EmptyStringValidatorDirective, CreditCardValidatorDirective, ValidatorsModule, AbstractControlUtil, EmailSuggestion, EqualToDirective, EqualToValidator };

//# sourceMappingURL=ngx-validators.js.map
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { delay } from 'rxjs/operators';
var EqualToDirective = /** @class */ (function () {
    function EqualToDirective() {
    }
    /**
     * @param {?} c
     * @return {?}
     */
    EqualToDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        /** @type {?} */
        var otherControl = typeof this.equalTo === 'string' ? c.parent.get(this.equalTo) : this.equalTo;
        if (!this.subscription) {
            this.subscription = otherControl.valueChanges
                .pipe(delay(1)).subscribe(function () {
                c.updateValueAndValidity();
            });
        }
        return c.value !== otherControl.value ? { notEqualTo: true } : null;
    };
    /**
     * @return {?}
     */
    EqualToDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    EqualToDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]',
                    providers: [{
                            provide: NG_VALIDATORS,
                            // tslint:disable-next-line:no-forward-ref
                            useExisting: forwardRef(function () { return EqualToDirective; }),
                            multi: true
                        }]
                },] }
    ];
    EqualToDirective.propDecorators = {
        equalTo: [{ type: Input }]
    };
    return EqualToDirective;
}());
export { EqualToDirective };
if (false) {
    /** @type {?} */
    EqualToDirective.prototype.equalTo;
    /** @type {?} */
    EqualToDirective.prototype.subscription;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXF1YWwtdG8uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXZhbGlkYXRvcnMvIiwic291cmNlcyI6WyJjb21wb25lbnRzL2VxdWFsLXRvL2VxdWFsLXRvLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ3hFLE9BQU8sRUFBbUIsYUFBYSxFQUErQixNQUFNLGdCQUFnQixDQUFDO0FBRTdGLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV2QztJQUFBO0lBNkJBLENBQUM7Ozs7O0lBZEMsbUNBQVE7Ozs7SUFBUixVQUFTLENBQWtCOztZQUNuQixZQUFZLEdBQUcsT0FBTyxJQUFJLENBQUMsT0FBTyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTztRQUNqRyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxZQUFZO2lCQUMxQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO2dCQUN4QixDQUFDLENBQUMsc0JBQXNCLEVBQUUsQ0FBQTtZQUM1QixDQUFDLENBQUMsQ0FBQztTQUNOO1FBQ0QsT0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUMsVUFBVSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDcEUsQ0FBQzs7OztJQUVELHNDQUFXOzs7SUFBWDtRQUNFLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbEMsQ0FBQzs7Z0JBNUJGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsd0VBQXdFO29CQUNsRixTQUFTLEVBQUUsQ0FBQzs0QkFDVixPQUFPLEVBQUUsYUFBYTs7NEJBRXRCLFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBTSxPQUFBLGdCQUFnQixFQUFoQixDQUFnQixDQUFDOzRCQUMvQyxLQUFLLEVBQUUsSUFBSTt5QkFDWixDQUFDO2lCQUNIOzs7MEJBR0UsS0FBSzs7SUFrQlIsdUJBQUM7Q0FBQSxBQTdCRCxJQTZCQztTQXBCWSxnQkFBZ0I7OztJQUUzQixtQ0FBMkM7O0lBRTNDLHdDQUFtQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbZXF1YWxUb11bbmdNb2RlbF0sIFtlcXVhbFRvXVtmb3JtQ29udHJvbE5hbWVdLCBbZXF1YWxUb11bZm9ybUNvbnRyb2xdJyxcbiAgcHJvdmlkZXJzOiBbe1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWZvcndhcmQtcmVmXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRXF1YWxUb0RpcmVjdGl2ZSksXG4gICAgbXVsdGk6IHRydWVcbiAgfV1cbn0pXG5leHBvcnQgY2xhc3MgRXF1YWxUb0RpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBlcXVhbFRvOiBzdHJpbmcgfCBBYnN0cmFjdENvbnRyb2w7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgY29uc3Qgb3RoZXJDb250cm9sID0gdHlwZW9mIHRoaXMuZXF1YWxUbyA9PT0gJ3N0cmluZycgPyBjLnBhcmVudC5nZXQodGhpcy5lcXVhbFRvKSA6IHRoaXMuZXF1YWxUbztcbiAgICBpZiAoIXRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG90aGVyQ29udHJvbC52YWx1ZUNoYW5nZXNcbiAgICAgICAgLnBpcGUoZGVsYXkoMSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgYy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjLnZhbHVlICE9PSBvdGhlckNvbnRyb2wudmFsdWUgPyB7bm90RXF1YWxUbzogdHJ1ZX0gOiBudWxsO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19
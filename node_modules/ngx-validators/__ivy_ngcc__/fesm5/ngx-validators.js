import { __values } from 'tslib';
import { Directive, Input, forwardRef, NgModule } from '@angular/core';
import { NG_VALIDATORS, Validators } from '@angular/forms';
import { delay } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
var AbstractControlUtil = /** @class */ (function () {
    function AbstractControlUtil() {
    }
    /**
     * @param {?} control
     * @return {?}
     */
    AbstractControlUtil.isNotPresent = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var value = control.value;
        if (value === undefined || value === null) {
            return true;
        }
        return value !== '' ? false : true;
    };
    /**
     * @param {?} control
     * @param {?} errorId
     * @param {?} value
     * @return {?}
     */
    AbstractControlUtil.addError = /**
     * @param {?} control
     * @param {?} errorId
     * @param {?} value
     * @return {?}
     */
    function (control, errorId, value) {
        var _a;
        if (!control.errors) {
            control.setErrors((_a = {}, _a[errorId] = value, _a));
        }
        else if (!control.hasError(errorId)) {
            control.errors[errorId] = value;
        }
    };
    /**
     * @param {?} control
     * @param {?} errorId
     * @return {?}
     */
    AbstractControlUtil.removeError = /**
     * @param {?} control
     * @param {?} errorId
     * @return {?}
     */
    function (control, errorId) {
        if (control.errors && control.hasError(errorId)) {
            if (Object.keys(control.errors).length > 1) {
                delete control.errors[errorId];
            }
            else {
                control.setErrors(null);
            }
        }
    };
    return AbstractControlUtil;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
// tslint:disable-next-line:variable-name
var  
// tslint:disable-next-line:variable-name
PasswordValidators = /** @class */ (function () {
    function PasswordValidators() {
    }
    /**
     * @param {?} repeatCount
     * @return {?}
     */
    PasswordValidators.repeatCharacterRegexRule = /**
     * @param {?} repeatCount
     * @return {?}
     */
    function (repeatCount) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var repeatDec = repeatCount - 1;
            /** @type {?} */
            var pattern = '([^\\x00-\\x1F])\\1{' + repeatDec + '}';
            if (control.value !== '' && new RegExp(pattern).test(control.value)) {
                return { 'repeatCharacterRegexRule': { 'repeatCount': repeatCount } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?} allowedChars
     * @return {?}
     */
    PasswordValidators.allowedCharacterRule = /**
     * @param {?} allowedChars
     * @return {?}
     */
    function (allowedChars) {
        /** @type {?} */
        var validator = function (control) {
            var e_1, _a;
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            /** @type {?} */
            var valid = true;
            /** @type {?} */
            var invalidChars = [];
            try {
                for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                    var char = value_1_1.value;
                    if (allowedChars.indexOf(char) === -1) {
                        valid = false;
                        if (invalidChars.indexOf(char) === -1) {
                            invalidChars.push(char);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!valid) {
                return { 'allowedCharacterRule': { 'invalidChars': invalidChars, 'allowedChars': allowedChars } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?} amount
     * @return {?}
     */
    PasswordValidators.alphabeticalCharacterRule = /**
     * @param {?} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var pattern = /[^A-Za-z]+/g;
            /** @type {?} */
            var stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'alphabeticalCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?} amount
     * @return {?}
     */
    PasswordValidators.digitCharacterRule = /**
     * @param {?} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var pattern = /[^0-9\.]+/g;
            /** @type {?} */
            var stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'digitCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?} amount
     * @return {?}
     */
    PasswordValidators.lowercaseCharacterRule = /**
     * @param {?} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var pattern = /[^a-z]+/g;
            /** @type {?} */
            var stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'lowercaseCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?} amount
     * @return {?}
     */
    PasswordValidators.uppercaseCharacterRule = /**
     * @param {?} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var pattern = /[^A-Z]+/g;
            /** @type {?} */
            var stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'uppercaseCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?} amount
     * @return {?}
     */
    PasswordValidators.specialCharacterRule = /**
     * @param {?} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (value.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var pattern = /[\w\s]+/g;
            /** @type {?} */
            var stripped = value.replace(pattern, '');
            if (stripped.length < amount) {
                return { 'specialCharacterRule': { 'required': amount, 'actual': stripped.length } };
            }
            return undefined;
        };
        return validator;
    };
    /**
     * @param {?=} passwordControlName
     * @param {?=} confirmPasswordControlName
     * @return {?}
     */
    PasswordValidators.mismatchedPasswords = /**
     * @param {?=} passwordControlName
     * @param {?=} confirmPasswordControlName
     * @return {?}
     */
    function (passwordControlName, confirmPasswordControlName) {
        /** @type {?} */
        var validator = function (group) {
            /** @type {?} */
            var newPasswordValue = group.get(passwordControlName ? passwordControlName : 'newPassword').value;
            /** @type {?} */
            var newPasswordConfirmValue = group.get(confirmPasswordControlName ? confirmPasswordControlName : 'confirmPassword').value;
            if (newPasswordValue !== newPasswordConfirmValue) {
                AbstractControlUtil.addError(group.get(confirmPasswordControlName ? confirmPasswordControlName : 'confirmPassword'), 'mismatchedPasswords', true);
                return { 'mismatchedPasswords': true };
            }
            else {
                AbstractControlUtil.removeError(group.get(confirmPasswordControlName ? confirmPasswordControlName : 'confirmPassword'), 'mismatchedPasswords');
            }
            return undefined;
        };
        return validator;
    };
    return PasswordValidators;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var EmailSuggestion = /** @class */ (function () {
    function EmailSuggestion() {
        this.defaultOptions = {
            domains: ['msn.com', 'bellsouth.net',
                'telus.net', 'comcast.net', 'optusnet.com.au',
                'earthlink.net', 'qq.com', 'sky.com', 'icloud.com',
                'mac.com', 'sympatico.ca', 'googlemail.com',
                'att.net', 'xtra.co.nz', 'web.de',
                'cox.net', 'gmail.com', 'ymail.com', 'yahoo.com',
                'aim.com', 'rogers.com', 'verizon.net',
                'rocketmail.com', 'google.com', 'optonline.net',
                'sbcglobal.net', 'aol.com', 'me.com', 'btinternet.com',
                'charter.net', 'shaw.ca'],
            secondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],
            topLevelDomains: ["com", "com.au", "com.tw", "ca", "co.nz", "co.uk", "de",
                "fr", "it", "ru", "net", "org", "edu", "gov", "jp", "nl", "kr", "se", "eu",
                "ie", "co.il", "us", "at", "be", "dk", "hk", "es", "gr", "ch", "no", "cz",
                "in", "net", "net.au", "info", "biz", "mil", "co.jp", "sg", "hu", "uk"]
        };
    }
    /**
     * @param {?} email
     * @param {?=} options
     * @return {?}
     */
    EmailSuggestion.prototype.suggest = /**
     * @param {?} email
     * @param {?=} options
     * @return {?}
     */
    function (email, options) {
        /** @type {?} */
        var opt = this.defaultOptions;
        if (options != undefined) {
            opt = options;
        }
        /** @type {?} */
        var emailParts = this.splitEmail(email.toLowerCase());
        if (!emailParts) {
            return undefined;
        }
        if (opt.secondLevelDomains && opt.topLevelDomains) {
            // If the email is a valid 2nd-level + top-level, do not suggest anything.
            if (opt.secondLevelDomains.indexOf(emailParts.secondLevelDomain) !== -1 && opt.topLevelDomains.indexOf(emailParts.topLevelDomain) !== -1) {
                return undefined;
            }
        }
        /** @type {?} */
        var closestDomain = this.findClosestDomain(emailParts.domain, opt.domains, 2);
        if (closestDomain) {
            if (closestDomain == emailParts.domain) {
                // The email address exactly matches one of the supplied domains; do not return a suggestion.
                return undefined;
            }
            else {
                // The email address closely matches one of the supplied domains; return a suggestion
                return { suggestion: { address: emailParts.address, domain: closestDomain, full: emailParts.address + "@" + closestDomain } };
            }
        }
        /** @type {?} */
        var closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, opt.secondLevelDomains, 2);
        /** @type {?} */
        var closestTopLevelDomain = this.findClosestDomain(emailParts.topLevelDomain, opt.topLevelDomains, 2);
        if (emailParts.domain) {
            closestDomain = emailParts.domain;
            /** @type {?} */
            var rtrn = false;
            if (closestSecondLevelDomain && closestSecondLevelDomain != emailParts.secondLevelDomain) {
                // The email address may have a mispelled second-level domain; return a suggestion
                closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain);
                rtrn = true;
            }
            if (closestTopLevelDomain && closestTopLevelDomain != emailParts.topLevelDomain && emailParts.secondLevelDomain !== '') {
                // The email address may have a mispelled top-level domain; return a suggestion
                closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain);
                rtrn = true;
            }
            if (rtrn) {
                return { suggestion: { address: emailParts.address, domain: closestDomain, full: emailParts.address + "@" + closestDomain } };
            }
        }
        /* The email address exactly matches one of the supplied domains, does not closely
         * match any domain and does not appear to simply have a mispelled top-level domain,
         * or is an invalid email address; do not return a suggestion.
         */
        return undefined;
    };
    /**
     * @param {?} email
     * @return {?}
     */
    EmailSuggestion.prototype.splitEmail = /**
     * @param {?} email
     * @return {?}
     */
    function (email) {
        /** @type {?} */
        var parts = email.trim().split('@');
        if (parts.length < 2) {
            return undefined;
        }
        for (var i = 0; i < parts.length; i++) {
            if (parts[i] === '') {
                return undefined;
            }
        }
        /** @type {?} */
        var result = {
            topLevelDomain: "",
            secondLevelDomain: "",
            domain: parts.pop(),
            address: ''
        };
        /** @type {?} */
        var domainParts = result.domain.split('.');
        if (domainParts.length === 0) {
            return undefined;
        }
        else if (domainParts.length == 1) {
            result.topLevelDomain = domainParts[0];
        }
        else {
            // The address has a domain and a top-level domain
            result.secondLevelDomain = domainParts[0];
            for (var j = 1; j < domainParts.length; j++) {
                result.topLevelDomain += domainParts[j] + '.';
            }
            result.topLevelDomain = result.topLevelDomain.substring(0, result.topLevelDomain.length - 1);
        }
        result.address = parts.join('@');
        return result;
    };
    /**
     * @param {?} domain
     * @param {?} domains
     * @param {?} threshold
     * @return {?}
     */
    EmailSuggestion.prototype.findClosestDomain = /**
     * @param {?} domain
     * @param {?} domains
     * @param {?} threshold
     * @return {?}
     */
    function (domain, domains, threshold) {
        /** @type {?} */
        var dist;
        /** @type {?} */
        var minDist = Infinity;
        /** @type {?} */
        var closestDomain = null;
        if (!domain || !domains) {
            return undefined;
        }
        for (var i = 0; i < domains.length; i++) {
            if (domain === domains[i]) {
                return domain;
            }
            dist = this.sift4Distance(domain, domains[i], 5);
            if (dist < minDist) {
                minDist = dist;
                closestDomain = domains[i];
            }
        }
        if (minDist <= threshold && closestDomain !== null) {
            return closestDomain;
        }
        else {
            return undefined;
        }
    };
    /**
     * @param {?} s1
     * @param {?} s2
     * @param {?} maxOffset
     * @return {?}
     */
    EmailSuggestion.prototype.sift4Distance = /**
     * @param {?} s1
     * @param {?} s2
     * @param {?} maxOffset
     * @return {?}
     */
    function (s1, s2, maxOffset) {
        // sift4: https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
        if (maxOffset === undefined) {
            maxOffset = 5; //default
        }
        if (!s1 || !s1.length) {
            if (!s2) {
                return 0;
            }
            return s2.length;
        }
        if (!s2 || !s2.length) {
            return s1.length;
        }
        /** @type {?} */
        var l1 = s1.length;
        /** @type {?} */
        var l2 = s2.length;
        /** @type {?} */
        var c1 = 0;
        //cursor for string 1
        /** @type {?} */
        var c2 = 0;
        //cursor for string 2
        /** @type {?} */
        var lcss = 0;
        //largest common subsequence
        /** @type {?} */
        var local_cs = 0;
        //local common substring
        /** @type {?} */
        var trans = 0;
        //number of transpositions ('ab' vs 'ba')
        /** @type {?} */
        var offset_arr = [];
        while ((c1 < l1) && (c2 < l2)) {
            if (s1.charAt(c1) == s2.charAt(c2)) {
                local_cs++;
                /** @type {?} */
                var isTrans = false;
                //see if current match is a transposition
                /** @type {?} */
                var i = 0;
                while (i < offset_arr.length) {
                    /** @type {?} */
                    var ofs = offset_arr[i];
                    if (c1 <= ofs.c1 || c2 <= ofs.c2) {
                        // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                        isTrans = Math.abs(c2 - c1) >= Math.abs(ofs.c2 - ofs.c1);
                        if (isTrans) {
                            trans++;
                        }
                        else {
                            if (!ofs.trans) {
                                ofs.trans = true;
                                trans++;
                            }
                        }
                        break;
                    }
                    else {
                        if (c1 > ofs.c2 && c2 > ofs.c1) {
                            offset_arr.splice(i, 1);
                        }
                        else {
                            i++;
                        }
                    }
                }
                offset_arr.push({
                    c1: c1,
                    c2: c2,
                    trans: isTrans
                });
            }
            else {
                lcss += local_cs;
                local_cs = 0;
                if (c1 != c2) {
                    c1 = c2 = Math.min(c1, c2); //using min allows the computation of transpositions
                }
                //if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
                //so that we can have only one code block handling matches 
                for (var j = 0; j < maxOffset && (c1 + j < l1 || c2 + j < l2); j++) {
                    if ((c1 + j < l1) && (s1.charAt(c1 + j) == s2.charAt(c2))) {
                        c1 += j - 1;
                        c2--;
                        break;
                    }
                    if ((c2 + j < l2) && (s1.charAt(c1) == s2.charAt(c2 + j))) {
                        c1--;
                        c2 += j - 1;
                        break;
                    }
                }
            }
            c1++;
            c2++;
            // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
            if ((c1 >= l1) || (c2 >= l2)) {
                lcss += local_cs;
                local_cs = 0;
                c1 = c2 = Math.min(c1, c2);
            }
        }
        lcss += local_cs;
        return Math.round(Math.max(l1, l2) - lcss + trans); //add the cost of transpositions to the final result
    };
    return EmailSuggestion;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var EmailValidators = /** @class */ (function () {
    function EmailValidators() {
    }
    /**
     * @param {?} control
     * @return {?}
     */
    EmailValidators.simple = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        /** @type {?} */
        var pattern = /.+@.+\..+/i;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { 'simpleEmailRule': true };
    };
    // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    /**
     * @param {?} control
     * @return {?}
     */
    EmailValidators.normal = 
    // https://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control)) {
            return undefined;
        }
        // tslint:disable-next-line:max-line-length
        /** @type {?} */
        var pattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        if (pattern.test(control.value)) {
            return undefined;
        }
        return { 'normalEmailRule': true };
    };
    /**
     * @param {?=} options
     * @return {?}
     */
    EmailValidators.suggest = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control)) {
                return undefined;
            }
            return _this.emailSuggestion.suggest(control.value, options);
        };
        return validator;
    };
    EmailValidators.emailSuggestion = new EmailSuggestion();
    return EmailValidators;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var UniversalValidators = /** @class */ (function () {
    function UniversalValidators() {
    }
    /**
     * @param {?} control
     * @return {?}
     */
    UniversalValidators.noWhitespace = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        /** @type {?} */
        var pattern = '\\s';
        if (new RegExp(pattern).test(control.value)) {
            return { 'noWhitespaceRequired': true };
        }
        return undefined;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    UniversalValidators.noEmptyString = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (control.value.trim().length === 0) {
            return { 'noEmptyString': true };
        }
        return undefined;
    };
    /**
     * @param {?} control
     * @return {?}
     */
    UniversalValidators.isNumber = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (isNaN(control.value)) {
            return { 'numberRequired': true };
        }
        return undefined;
    };
    /**
     * @param {?} minValue
     * @param {?} maxValue
     * @return {?}
     */
    UniversalValidators.isInRange = /**
     * @param {?} minValue
     * @param {?} maxValue
     * @return {?}
     */
    function (minValue, maxValue) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            if (isNaN(control.value)) {
                return { 'numberRequired': true };
            }
            if (+control.value < minValue) {
                return { 'rangeValueToSmall': { 'requiredMinValue': minValue, 'requiredMaxValue': maxValue, 'actual': control.value } };
            }
            if (+control.value > maxValue) {
                return { 'rangeValueToBig': { 'requiredMinValue': minValue, 'requiredMaxValue': maxValue, 'actual': control.value } };
            }
            else {
                return undefined;
            }
        };
        return validator;
    };
    /**
     * @param {?} minLength
     * @return {?}
     */
    UniversalValidators.minLength = /**
     * @param {?} minLength
     * @return {?}
     */
    function (minLength) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (value.length >= minLength) {
                return undefined;
            }
            return { 'minLength': { 'requiredMinLength': minLength, 'actualLength': value.length } };
        };
        return validator;
    };
    /**
     * @param {?} maxLength
     * @return {?}
     */
    UniversalValidators.maxLength = /**
     * @param {?} maxLength
     * @return {?}
     */
    function (maxLength) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (maxLength >= value.length) {
                return undefined;
            }
            return { 'maxLength': { 'requiredMaxLength': maxLength, 'actualLength': value.length } };
        };
        return validator;
    };
    /**
     * @param {?} min
     * @return {?}
     */
    UniversalValidators.min = /**
     * @param {?} min
     * @return {?}
     */
    function (min) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (isNaN(control.value)) {
                return { 'numberRequired': true };
            }
            if (+value >= min) {
                return undefined;
            }
            return { 'min': { 'required': min, 'actual': control.value } };
        };
        return validator;
    };
    /**
     * @param {?} max
     * @return {?}
     */
    UniversalValidators.max = /**
     * @param {?} max
     * @return {?}
     */
    function (max) {
        /** @type {?} */
        var validator = function (control) {
            if (AbstractControlUtil.isNotPresent(control))
                return undefined;
            /** @type {?} */
            var value = control.value;
            if (isNaN(control.value)) {
                return { 'numberRequired': true };
            }
            if (max >= +value) {
                return undefined;
            }
            return { 'max': { 'required': max, 'actual': control.value } };
        };
        return validator;
    };
    return UniversalValidators;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var visaRegex = '^(?:4[0-9]{12})(?:[0-9]{3})?$';
/** @type {?} */
var americanExpressRegex = '^(?:3[47][0-9]{13})$';
/** @type {?} */
var maestroRegex = '^(?:(?:5[0678]\\d\\d|6304|6390|67\\d\\d)\\d{8,15})$';
/** @type {?} */
var jcbRegex = '^(?:(?:2131|1800|35\\d{3})\\d{11})$';
/** @type {?} */
var discoverRegex = '^(?:6(?:011|5[0-9]{2})(?:[0-9]{12}))$';
/** @type {?} */
var dinersclubRegex = '^(?:3(?:0[0-5]|[68][0-9])[0-9]{11})$';
/** @type {?} */
var mastercardRegex = '^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$';
var CreditCardValidators = /** @class */ (function () {
    function CreditCardValidators() {
    }
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.isCreditCard = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex + '|' +
            visaRegex + '|' +
            maestroRegex + '|' +
            jcbRegex + '|' +
            discoverRegex + '|' +
            mastercardRegex + '|' +
            dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { 'creditcard': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.americanExpress = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(americanExpressRegex).test(control.value)) {
            return undefined;
        }
        return { 'americanExpress': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.dinersclub = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(dinersclubRegex).test(control.value)) {
            return undefined;
        }
        return { 'dinersclub': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.discover = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(discoverRegex).test(control.value)) {
            return undefined;
        }
        return { 'discover': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.jcb = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(jcbRegex).test(control.value)) {
            return undefined;
        }
        return { 'jcb': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.maestro = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(maestroRegex).test(control.value)) {
            return undefined;
        }
        return { 'maestro': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.mastercard = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(mastercardRegex).test(control.value)) {
            return undefined;
        }
        return { 'mastercard': true };
    };
    /**
     * @param {?} control
     * @return {?}
     */
    CreditCardValidators.visa = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (AbstractControlUtil.isNotPresent(control))
            return undefined;
        if (new RegExp(visaRegex).test(control.value)) {
            return undefined;
        }
        return { 'visa': true };
    };
    return CreditCardValidators;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var PasswordValidatorDirective = /** @class */ (function () {
    function PasswordValidatorDirective() {
        this.repeatCharacter = 4;
        this.alphabeticalCharacter = 1;
        this.digitCharacter = 1;
        this.lowercaseCharacter = 1;
        this.uppercaseCharacter = 1;
    }
    /**
     * @return {?}
     */
    PasswordValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.repeatCharacterValidator = PasswordValidators.repeatCharacterRegexRule(this.repeatCharacter);
        this.alphabeticalCharacterValidator = PasswordValidators.alphabeticalCharacterRule(this.alphabeticalCharacter);
        this.digitCharacterValidator = PasswordValidators.digitCharacterRule(this.digitCharacter);
        this.lowercaseCharacterValidator = PasswordValidators.lowercaseCharacterRule(this.lowercaseCharacter);
        this.uppercaseCharacterValidator = PasswordValidators.uppercaseCharacterRule(this.uppercaseCharacter);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    PasswordValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        /** @type {?} */
        var compose = Validators.compose([this.repeatCharacterValidator,
            this.digitCharacterValidator, this.alphabeticalCharacterValidator,
            this.lowercaseCharacterValidator, this.uppercaseCharacterValidator]);
        return compose(c);
    };
    PasswordValidatorDirective.propDecorators = {
        repeatCharacter: [{ type: Input }],
        alphabeticalCharacter: [{ type: Input }],
        digitCharacter: [{ type: Input }],
        lowercaseCharacter: [{ type: Input }],
        uppercaseCharacter: [{ type: Input }]
    };
PasswordValidatorDirective.ɵfac = function PasswordValidatorDirective_Factory(t) { return new (t || PasswordValidatorDirective)(); };
PasswordValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PasswordValidatorDirective, selectors: [["", "password", "", "formControlName", ""], ["", "password", "", "formControl", ""], ["", "password", "", "ngModel", ""]], inputs: { repeatCharacter: "repeatCharacter", alphabeticalCharacter: "alphabeticalCharacter", digitCharacter: "digitCharacter", lowercaseCharacter: "lowercaseCharacter", uppercaseCharacter: "uppercaseCharacter" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return PasswordValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PasswordValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[password][formControlName],[password][formControl],[password][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return PasswordValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { repeatCharacter: [{
            type: Input
        }], alphabeticalCharacter: [{
            type: Input
        }], digitCharacter: [{
            type: Input
        }], lowercaseCharacter: [{
            type: Input
        }], uppercaseCharacter: [{
            type: Input
        }] }); })();
    return PasswordValidatorDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var EmailValidatorDirective = /** @class */ (function () {
    function EmailValidatorDirective() {
        this.email = 'normal';
    }
    /**
     * @return {?}
     */
    EmailValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        switch (this.email) {
            case 'simple':
                this.validator = EmailValidators.simple;
                break;
            case 'normal':
                this.validator = EmailValidators.normal;
                break;
            default:
                this.validator = EmailValidators.normal;
                break;
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    EmailValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    EmailValidatorDirective.propDecorators = {
        email: [{ type: Input }]
    };
EmailValidatorDirective.ɵfac = function EmailValidatorDirective_Factory(t) { return new (t || EmailValidatorDirective)(); };
EmailValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EmailValidatorDirective, selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]], inputs: { email: "email" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return EmailValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmailValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[email][formControlName],[email][formControl],[email][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return EmailValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { email: [{
            type: Input
        }] }); })();
    return EmailValidatorDirective;
}());
var EmailSuggestValidatorDirective = /** @class */ (function () {
    function EmailSuggestValidatorDirective() {
    }
    /**
     * @return {?}
     */
    EmailSuggestValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = EmailValidators.suggest(this.emailSuggest);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    EmailSuggestValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    EmailSuggestValidatorDirective.propDecorators = {
        emailSuggest: [{ type: Input }]
    };
EmailSuggestValidatorDirective.ɵfac = function EmailSuggestValidatorDirective_Factory(t) { return new (t || EmailSuggestValidatorDirective)(); };
EmailSuggestValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EmailSuggestValidatorDirective, selectors: [["", "emailSuggest", "", "formControlName", ""], ["", "emailSuggest", "", "formControl", ""], ["", "emailSuggest", "", "ngModel", ""]], inputs: { emailSuggest: "emailSuggest" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return EmailSuggestValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmailSuggestValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[emailSuggest][formControlName],[emailSuggest][formControl],[emailSuggest][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return EmailSuggestValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { emailSuggest: [{
            type: Input
        }] }); })();
    return EmailSuggestValidatorDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var WhiteSpaceValidatorDirective = /** @class */ (function () {
    function WhiteSpaceValidatorDirective() {
    }
    /**
     * @return {?}
     */
    WhiteSpaceValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = UniversalValidators.noWhitespace;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    WhiteSpaceValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
WhiteSpaceValidatorDirective.ɵfac = function WhiteSpaceValidatorDirective_Factory(t) { return new (t || WhiteSpaceValidatorDirective)(); };
WhiteSpaceValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: WhiteSpaceValidatorDirective, selectors: [["", "noWhitespace", "", "formControlName", ""], ["", "noWhitespace", "", "formControl", ""], ["", "noWhitespace", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return WhiteSpaceValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(WhiteSpaceValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[noWhitespace][formControlName],[noWhitespace][formControl],[noWhitespace][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return WhiteSpaceValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, null); })();
    return WhiteSpaceValidatorDirective;
}());
var EmptyStringValidatorDirective = /** @class */ (function () {
    function EmptyStringValidatorDirective() {
    }
    /**
     * @return {?}
     */
    EmptyStringValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = UniversalValidators.noEmptyString;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    EmptyStringValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
EmptyStringValidatorDirective.ɵfac = function EmptyStringValidatorDirective_Factory(t) { return new (t || EmptyStringValidatorDirective)(); };
EmptyStringValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EmptyStringValidatorDirective, selectors: [["", "noEmptyString", "", "formControlName", ""], ["", "noEmptyString", "", "formControl", ""], ["", "noEmptyString", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return EmptyStringValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmptyStringValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[noEmptyString][formControlName],[noEmptyString][formControl],[noEmptyString][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return EmptyStringValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, null); })();
    return EmptyStringValidatorDirective;
}());
var IsNumberValidatorDirective = /** @class */ (function () {
    function IsNumberValidatorDirective() {
    }
    /**
     * @return {?}
     */
    IsNumberValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = UniversalValidators.isNumber;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    IsNumberValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
IsNumberValidatorDirective.ɵfac = function IsNumberValidatorDirective_Factory(t) { return new (t || IsNumberValidatorDirective)(); };
IsNumberValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IsNumberValidatorDirective, selectors: [["", "isNumber", "", "formControlName", ""], ["", "isNumber", "", "formControl", ""], ["", "isNumber", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return IsNumberValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsNumberValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[isNumber][formControlName],[isNumber][formControl],[isNumber][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return IsNumberValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, null); })();
    return IsNumberValidatorDirective;
}());
var IsInRangeValidatorDirective = /** @class */ (function () {
    function IsInRangeValidatorDirective() {
    }
    /**
     * @return {?}
     */
    IsInRangeValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = UniversalValidators.isInRange(this.minValue, this.maxValue);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    IsInRangeValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    IsInRangeValidatorDirective.propDecorators = {
        minValue: [{ type: Input }],
        maxValue: [{ type: Input }]
    };
IsInRangeValidatorDirective.ɵfac = function IsInRangeValidatorDirective_Factory(t) { return new (t || IsInRangeValidatorDirective)(); };
IsInRangeValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IsInRangeValidatorDirective, selectors: [["", "isInRange", "", "formControlName", ""], ["", "isInRange", "", "formControl", ""], ["", "isInRange", "", "ngModel", ""]], inputs: { minValue: "minValue", maxValue: "maxValue" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return IsInRangeValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IsInRangeValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[isInRange][formControlName],[isInRange][formControl],[isInRange][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return IsInRangeValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }] }); })();
    return IsInRangeValidatorDirective;
}());
var MaxValidatorDirective = /** @class */ (function () {
    function MaxValidatorDirective() {
    }
    /**
     * @return {?}
     */
    MaxValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = UniversalValidators.max(this.max);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    MaxValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    MaxValidatorDirective.propDecorators = {
        max: [{ type: Input }]
    };
MaxValidatorDirective.ɵfac = function MaxValidatorDirective_Factory(t) { return new (t || MaxValidatorDirective)(); };
MaxValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MaxValidatorDirective, selectors: [["input", "type", "text", "max", "", "formControlName", ""], ["input", "type", "text", "max", "", "formControl", ""], ["input", "type", "text", "max", "", "ngModel", ""]], inputs: { max: "max" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return MaxValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MaxValidatorDirective, [{
        type: Directive,
        args: [{
                selector: 'input[type=text][max][formControlName],input[type=text][max][formControl],input[type=text][max][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return MaxValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { max: [{
            type: Input
        }] }); })();
    return MaxValidatorDirective;
}());
var MinValidatorDirective = /** @class */ (function () {
    function MinValidatorDirective() {
    }
    /**
     * @return {?}
     */
    MinValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = UniversalValidators.min(this.min);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    MinValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    MinValidatorDirective.propDecorators = {
        min: [{ type: Input }]
    };
MinValidatorDirective.ɵfac = function MinValidatorDirective_Factory(t) { return new (t || MinValidatorDirective)(); };
MinValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MinValidatorDirective, selectors: [["input", "type", "text", "min", "", "formControlName", ""], ["input", "type", "text", "min", "", "formControl", ""], ["input", "type", "text", "min", "", "ngModel", ""]], inputs: { min: "min" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return MinValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MinValidatorDirective, [{
        type: Directive,
        args: [{
                selector: 'input[type=text][min][formControlName],input[type=text][min][formControl],input[type=text][min][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return MinValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { min: [{
            type: Input
        }] }); })();
    return MinValidatorDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var CreditCardValidatorDirective = /** @class */ (function () {
    function CreditCardValidatorDirective() {
        this.creditCard = 'all';
    }
    /**
     * @return {?}
     */
    CreditCardValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        switch (this.creditCard) {
            case 'all':
                this.validator = CreditCardValidators.isCreditCard;
                break;
            case 'americanExpress':
                this.validator = CreditCardValidators.americanExpress;
                break;
            case 'dinersclub':
                this.validator = CreditCardValidators.dinersclub;
                break;
            case 'discover':
                this.validator = CreditCardValidators.discover;
                break;
            case 'jcb':
                this.validator = CreditCardValidators.jcb;
                break;
            case 'maestro':
                this.validator = CreditCardValidators.maestro;
                break;
            case 'mastercard':
                this.validator = CreditCardValidators.mastercard;
                break;
            case 'visa':
                this.validator = CreditCardValidators.visa;
                break;
            default:
                this.validator = CreditCardValidators.isCreditCard;
                break;
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    CreditCardValidatorDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.validator(c);
    };
    CreditCardValidatorDirective.propDecorators = {
        creditCard: [{ type: Input }]
    };
CreditCardValidatorDirective.ɵfac = function CreditCardValidatorDirective_Factory(t) { return new (t || CreditCardValidatorDirective)(); };
CreditCardValidatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CreditCardValidatorDirective, selectors: [["", "creditCard", "", "formControlName", ""], ["", "creditCard", "", "formControl", ""], ["", "creditCard", "", "ngModel", ""]], inputs: { creditCard: "creditCard" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return CreditCardValidatorDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CreditCardValidatorDirective, [{
        type: Directive,
        args: [{
                selector: '[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return CreditCardValidatorDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { creditCard: [{
            type: Input
        }] }); })();
    return CreditCardValidatorDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var EqualToDirective = /** @class */ (function () {
    function EqualToDirective() {
    }
    /**
     * @param {?} c
     * @return {?}
     */
    EqualToDirective.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        /** @type {?} */
        var otherControl = typeof this.equalTo === 'string' ? c.parent.get(this.equalTo) : this.equalTo;
        if (!this.subscription) {
            this.subscription = otherControl.valueChanges
                .pipe(delay(1)).subscribe(function () {
                c.updateValueAndValidity();
            });
        }
        return c.value !== otherControl.value ? { notEqualTo: true } : null;
    };
    /**
     * @return {?}
     */
    EqualToDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    EqualToDirective.propDecorators = {
        equalTo: [{ type: Input }]
    };
EqualToDirective.ɵfac = function EqualToDirective_Factory(t) { return new (t || EqualToDirective)(); };
EqualToDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EqualToDirective, selectors: [["", "equalTo", "", "ngModel", ""], ["", "equalTo", "", "formControlName", ""], ["", "equalTo", "", "formControl", ""]], inputs: { equalTo: "equalTo" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALIDATORS,
                // tslint:disable-next-line:no-forward-ref
                useExisting: forwardRef(function () { return EqualToDirective; }),
                multi: true
            }])] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EqualToDirective, [{
        type: Directive,
        args: [{
                selector: '[equalTo][ngModel], [equalTo][formControlName], [equalTo][formControl]',
                providers: [{
                        provide: NG_VALIDATORS,
                        // tslint:disable-next-line:no-forward-ref
                        useExisting: forwardRef(function () { return EqualToDirective; }),
                        multi: true
                    }]
            }]
    }], function () { return []; }, { equalTo: [{
            type: Input
        }] }); })();
    return EqualToDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var ValidatorsModule = /** @class */ (function () {
    function ValidatorsModule() {
    }
ValidatorsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ValidatorsModule });
ValidatorsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ValidatorsModule_Factory(t) { return new (t || ValidatorsModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ValidatorsModule, { declarations: [CreditCardValidatorDirective,
        EmailValidatorDirective,
        EmailSuggestValidatorDirective,
        PasswordValidatorDirective,
        IsInRangeValidatorDirective,
        IsNumberValidatorDirective,
        MaxValidatorDirective,
        MinValidatorDirective,
        WhiteSpaceValidatorDirective,
        EmptyStringValidatorDirective,
        EqualToDirective], exports: [CreditCardValidatorDirective,
        EmailValidatorDirective,
        EmailSuggestValidatorDirective,
        PasswordValidatorDirective,
        IsInRangeValidatorDirective,
        IsNumberValidatorDirective,
        MaxValidatorDirective,
        MinValidatorDirective,
        WhiteSpaceValidatorDirective,
        EmptyStringValidatorDirective,
        EqualToDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ValidatorsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    CreditCardValidatorDirective,
                    EmailValidatorDirective,
                    EmailSuggestValidatorDirective,
                    PasswordValidatorDirective,
                    IsInRangeValidatorDirective,
                    IsNumberValidatorDirective,
                    MaxValidatorDirective,
                    MinValidatorDirective,
                    WhiteSpaceValidatorDirective,
                    EmptyStringValidatorDirective,
                    EqualToDirective
                ],
                exports: [
                    CreditCardValidatorDirective,
                    EmailValidatorDirective,
                    EmailSuggestValidatorDirective,
                    PasswordValidatorDirective,
                    IsInRangeValidatorDirective,
                    IsNumberValidatorDirective,
                    MaxValidatorDirective,
                    MinValidatorDirective,
                    WhiteSpaceValidatorDirective,
                    EmptyStringValidatorDirective,
                    EqualToDirective
                ]
            }]
    }], function () { return []; }, null); })();
    return ValidatorsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var EqualToValidator = /** @class */ (function () {
    function EqualToValidator() {
    }
    /**
     * @param {?} c1Name
     * @param {?} c2Name
     * @return {?}
     */
    EqualToValidator.equalTo = /**
     * @param {?} c1Name
     * @param {?} c2Name
     * @return {?}
     */
    function (c1Name, c2Name) {
        /** @type {?} */
        var validator = function (parent) {
            /** @type {?} */
            var c1 = parent.get(c1Name);
            /** @type {?} */
            var c2 = parent.get(c2Name);
            if (c1.value === c2.value) {
                AbstractControlUtil.removeError(c2, 'notEqualTo');
            }
            else {
                AbstractControlUtil.addError(c2, 'notEqualTo', true);
            }
        };
        return validator;
    };
    return EqualToValidator;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { PasswordValidators, EmailValidators, UniversalValidators, CreditCardValidators, PasswordValidatorDirective, EmailValidatorDirective, EmailSuggestValidatorDirective, IsInRangeValidatorDirective, IsNumberValidatorDirective, MaxValidatorDirective, MinValidatorDirective, WhiteSpaceValidatorDirective, EmptyStringValidatorDirective, CreditCardValidatorDirective, ValidatorsModule, AbstractControlUtil, EmailSuggestion, EqualToDirective, EqualToValidator };

//# sourceMappingURL=ngx-validators.js.map
import { EventEmitter } from '@angular/core';
import { WizardStepSymbolDirective } from '../directives/wizard-step-symbol.directive';
import { WizardStepTitleDirective } from '../directives/wizard-step-title.directive';
import { MovingDirection } from './moving-direction.enum';
import { NavigationSymbol } from './navigation-symbol.interface';
/**
 * Basic functionality every type of wizard step needs to provide
 *
 * @author Marc Arndt
 */
import * as ɵngcc0 from '@angular/core';
export declare abstract class WizardStep {
    /**
     * A step title property, which contains the visible header title of the step.
     * This title is then shown inside the navigation bar.
     * Compared to `stepTitle` this property can contain any html content and not only plain text
     */
    stepTitleTemplate: WizardStepTitleDirective;
    /**
     * A step symbol property that, if defined, overrides `navigationSymbol`.
     * Allows to display arbitrary content as a step symbol instead of plain text.
     */
    stepSymbolTemplate: WizardStepSymbolDirective;
    /**
     * A step id, unique to the step
     */
    stepId: string;
    /**
     * A step title property, which contains the visible header title of the step.
     * This title is only shown inside the navigation bar, if `stepTitleTemplate` is not defined or null.
     */
    stepTitle: string;
    /**
     * A symbol property, which contains an optional symbol for the step inside the navigation bar.
     * Takes effect when `stepSymbolTemplate` is not defined or null.
     */
    navigationSymbol: NavigationSymbol;
    /**
     * A boolean describing if the wizard step is currently selected
     */
    selected: boolean;
    /**
     * A boolean describing if the wizard step has been completed
     */
    completed: boolean;
    /**
     * A boolean describing if the wizard step is shown as completed when the wizard is presented to the user
     *
     * Users will typically use `CompletedStepDirective` to set this flag
     */
    initiallyCompleted: boolean;
    /**
     * A boolean describing if the wizard step is being edited after being competed
     *
     * This flag can only be true when `selected` is true.
     */
    editing: boolean;
    /**
     * A boolean describing, if the wizard step should be selected by default, i.e. after the wizard has been initialized as the initial step
     */
    defaultSelected: boolean;
    /**
     * A boolean describing if the wizard step is an optional step
     */
    optional: boolean;
    /**
     * A function or boolean deciding, if this step can be entered
     */
    canEnter: ((direction: MovingDirection) => boolean) | ((direction: MovingDirection) => Promise<boolean>) | boolean;
    /**
     * A function or boolean deciding, if this step can be exited
     */
    canExit: ((direction: MovingDirection) => boolean) | ((direction: MovingDirection) => Promise<boolean>) | boolean;
    /**
     * This [[EventEmitter]] is called when the step is entered.
     * The bound method should be used to do initialization work.
     */
    stepEnter: EventEmitter<MovingDirection>;
    /**
     * This [[EventEmitter]] is called when the step is exited.
     * The bound method can be used to do cleanup work.
     */
    stepExit: EventEmitter<MovingDirection>;
    /**
     * Returns if this wizard step should be visible to the user.
     * If the step should be visible to the user false is returned, otherwise true
     */
    readonly hidden: boolean;
    /**
     * This method returns true, if this wizard step can be transitioned with a given direction.
     * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.
     *
     * @param condition A condition variable, deciding if the step can be transitioned
     * @param direction The direction in which this step should be transitioned
     * @returns A [[Promise]] containing `true`, if this step can transitioned in the given direction
     * @throws An `Error` is thrown if `condition` is neither a function nor a boolean
     */
    private static canTransitionStep;
    /**
     * A function called when the step is entered
     *
     * @param direction The direction in which the step is entered
     */
    enter(direction: MovingDirection): void;
    /**
     * A function called when the step is exited
     *
     * @param direction The direction in which the step is exited
     */
    exit(direction: MovingDirection): void;
    /**
     * This method returns true, if this wizard step can be entered from the given direction.
     * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean
     * nor a function.
     *
     * @param direction The direction in which this step should be entered
     * @returns A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise
     * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean
     */
    canEnterStep(direction: MovingDirection): Promise<boolean>;
    /**
     * This method returns true, if this wizard step can be exited into given direction.
     * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean
     * nor a function.
     *
     * @param direction The direction in which this step should be left
     * @returns A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise
     * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean
     */
    canExitStep(direction: MovingDirection): Promise<boolean>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<WizardStep, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<WizardStep, never, never, { "navigationSymbol": "navigationSymbol"; "canEnter": "canEnter"; "canExit": "canExit"; "stepId": "stepId"; "stepTitle": "stepTitle"; }, { "stepEnter": "stepEnter"; "stepExit": "stepExit"; }, ["stepTitleTemplate", "stepSymbolTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l6YXJkLXN0ZXAuaW50ZXJmYWNlLmQudHMiLCJzb3VyY2VzIjpbIndpemFyZC1zdGVwLmludGVyZmFjZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaXphcmRTdGVwU3ltYm9sRGlyZWN0aXZlIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy93aXphcmQtc3RlcC1zeW1ib2wuZGlyZWN0aXZlJztcbmltcG9ydCB7IFdpemFyZFN0ZXBUaXRsZURpcmVjdGl2ZSB9IGZyb20gJy4uL2RpcmVjdGl2ZXMvd2l6YXJkLXN0ZXAtdGl0bGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IE1vdmluZ0RpcmVjdGlvbiB9IGZyb20gJy4vbW92aW5nLWRpcmVjdGlvbi5lbnVtJztcbmltcG9ydCB7IE5hdmlnYXRpb25TeW1ib2wgfSBmcm9tICcuL25hdmlnYXRpb24tc3ltYm9sLmludGVyZmFjZSc7XG4vKipcbiAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgZXZlcnkgdHlwZSBvZiB3aXphcmQgc3RlcCBuZWVkcyB0byBwcm92aWRlXG4gKlxuICogQGF1dGhvciBNYXJjIEFybmR0XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIFdpemFyZFN0ZXAge1xuICAgIC8qKlxuICAgICAqIEEgc3RlcCB0aXRsZSBwcm9wZXJ0eSwgd2hpY2ggY29udGFpbnMgdGhlIHZpc2libGUgaGVhZGVyIHRpdGxlIG9mIHRoZSBzdGVwLlxuICAgICAqIFRoaXMgdGl0bGUgaXMgdGhlbiBzaG93biBpbnNpZGUgdGhlIG5hdmlnYXRpb24gYmFyLlxuICAgICAqIENvbXBhcmVkIHRvIGBzdGVwVGl0bGVgIHRoaXMgcHJvcGVydHkgY2FuIGNvbnRhaW4gYW55IGh0bWwgY29udGVudCBhbmQgbm90IG9ubHkgcGxhaW4gdGV4dFxuICAgICAqL1xuICAgIHN0ZXBUaXRsZVRlbXBsYXRlOiBXaXphcmRTdGVwVGl0bGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQSBzdGVwIHN5bWJvbCBwcm9wZXJ0eSB0aGF0LCBpZiBkZWZpbmVkLCBvdmVycmlkZXMgYG5hdmlnYXRpb25TeW1ib2xgLlxuICAgICAqIEFsbG93cyB0byBkaXNwbGF5IGFyYml0cmFyeSBjb250ZW50IGFzIGEgc3RlcCBzeW1ib2wgaW5zdGVhZCBvZiBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIHN0ZXBTeW1ib2xUZW1wbGF0ZTogV2l6YXJkU3RlcFN5bWJvbERpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBBIHN0ZXAgaWQsIHVuaXF1ZSB0byB0aGUgc3RlcFxuICAgICAqL1xuICAgIHN0ZXBJZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEEgc3RlcCB0aXRsZSBwcm9wZXJ0eSwgd2hpY2ggY29udGFpbnMgdGhlIHZpc2libGUgaGVhZGVyIHRpdGxlIG9mIHRoZSBzdGVwLlxuICAgICAqIFRoaXMgdGl0bGUgaXMgb25seSBzaG93biBpbnNpZGUgdGhlIG5hdmlnYXRpb24gYmFyLCBpZiBgc3RlcFRpdGxlVGVtcGxhdGVgIGlzIG5vdCBkZWZpbmVkIG9yIG51bGwuXG4gICAgICovXG4gICAgc3RlcFRpdGxlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQSBzeW1ib2wgcHJvcGVydHksIHdoaWNoIGNvbnRhaW5zIGFuIG9wdGlvbmFsIHN5bWJvbCBmb3IgdGhlIHN0ZXAgaW5zaWRlIHRoZSBuYXZpZ2F0aW9uIGJhci5cbiAgICAgKiBUYWtlcyBlZmZlY3Qgd2hlbiBgc3RlcFN5bWJvbFRlbXBsYXRlYCBpcyBub3QgZGVmaW5lZCBvciBudWxsLlxuICAgICAqL1xuICAgIG5hdmlnYXRpb25TeW1ib2w6IE5hdmlnYXRpb25TeW1ib2w7XG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGRlc2NyaWJpbmcgaWYgdGhlIHdpemFyZCBzdGVwIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNlbGVjdGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgYm9vbGVhbiBkZXNjcmliaW5nIGlmIHRoZSB3aXphcmQgc3RlcCBoYXMgYmVlbiBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBjb21wbGV0ZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGRlc2NyaWJpbmcgaWYgdGhlIHdpemFyZCBzdGVwIGlzIHNob3duIGFzIGNvbXBsZXRlZCB3aGVuIHRoZSB3aXphcmQgaXMgcHJlc2VudGVkIHRvIHRoZSB1c2VyXG4gICAgICpcbiAgICAgKiBVc2VycyB3aWxsIHR5cGljYWxseSB1c2UgYENvbXBsZXRlZFN0ZXBEaXJlY3RpdmVgIHRvIHNldCB0aGlzIGZsYWdcbiAgICAgKi9cbiAgICBpbml0aWFsbHlDb21wbGV0ZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGRlc2NyaWJpbmcgaWYgdGhlIHdpemFyZCBzdGVwIGlzIGJlaW5nIGVkaXRlZCBhZnRlciBiZWluZyBjb21wZXRlZFxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGNhbiBvbmx5IGJlIHRydWUgd2hlbiBgc2VsZWN0ZWRgIGlzIHRydWUuXG4gICAgICovXG4gICAgZWRpdGluZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIGJvb2xlYW4gZGVzY3JpYmluZywgaWYgdGhlIHdpemFyZCBzdGVwIHNob3VsZCBiZSBzZWxlY3RlZCBieSBkZWZhdWx0LCBpLmUuIGFmdGVyIHRoZSB3aXphcmQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYXMgdGhlIGluaXRpYWwgc3RlcFxuICAgICAqL1xuICAgIGRlZmF1bHRTZWxlY3RlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIGJvb2xlYW4gZGVzY3JpYmluZyBpZiB0aGUgd2l6YXJkIHN0ZXAgaXMgYW4gb3B0aW9uYWwgc3RlcFxuICAgICAqL1xuICAgIG9wdGlvbmFsOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gb3IgYm9vbGVhbiBkZWNpZGluZywgaWYgdGhpcyBzdGVwIGNhbiBiZSBlbnRlcmVkXG4gICAgICovXG4gICAgY2FuRW50ZXI6ICgoZGlyZWN0aW9uOiBNb3ZpbmdEaXJlY3Rpb24pID0+IGJvb2xlYW4pIHwgKChkaXJlY3Rpb246IE1vdmluZ0RpcmVjdGlvbikgPT4gUHJvbWlzZTxib29sZWFuPikgfCBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gb3IgYm9vbGVhbiBkZWNpZGluZywgaWYgdGhpcyBzdGVwIGNhbiBiZSBleGl0ZWRcbiAgICAgKi9cbiAgICBjYW5FeGl0OiAoKGRpcmVjdGlvbjogTW92aW5nRGlyZWN0aW9uKSA9PiBib29sZWFuKSB8ICgoZGlyZWN0aW9uOiBNb3ZpbmdEaXJlY3Rpb24pID0+IFByb21pc2U8Ym9vbGVhbj4pIHwgYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIFtbRXZlbnRFbWl0dGVyXV0gaXMgY2FsbGVkIHdoZW4gdGhlIHN0ZXAgaXMgZW50ZXJlZC5cbiAgICAgKiBUaGUgYm91bmQgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGRvIGluaXRpYWxpemF0aW9uIHdvcmsuXG4gICAgICovXG4gICAgc3RlcEVudGVyOiBFdmVudEVtaXR0ZXI8TW92aW5nRGlyZWN0aW9uPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIFtbRXZlbnRFbWl0dGVyXV0gaXMgY2FsbGVkIHdoZW4gdGhlIHN0ZXAgaXMgZXhpdGVkLlxuICAgICAqIFRoZSBib3VuZCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZG8gY2xlYW51cCB3b3JrLlxuICAgICAqL1xuICAgIHN0ZXBFeGl0OiBFdmVudEVtaXR0ZXI8TW92aW5nRGlyZWN0aW9uPjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoaXMgd2l6YXJkIHN0ZXAgc2hvdWxkIGJlIHZpc2libGUgdG8gdGhlIHVzZXIuXG4gICAgICogSWYgdGhlIHN0ZXAgc2hvdWxkIGJlIHZpc2libGUgdG8gdGhlIHVzZXIgZmFsc2UgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSB0cnVlXG4gICAgICovXG4gICAgcmVhZG9ubHkgaGlkZGVuOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSwgaWYgdGhpcyB3aXphcmQgc3RlcCBjYW4gYmUgdHJhbnNpdGlvbmVkIHdpdGggYSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgICogVHJhbnNpdGlvbmVkIGluIHRoaXMgY2FzZSBtZWFucyBlaXRoZXIgZW50ZXJlZCBvciBleGl0ZWQsIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gYGNvbmRpdGlvbmAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBBIGNvbmRpdGlvbiB2YXJpYWJsZSwgZGVjaWRpbmcgaWYgdGhlIHN0ZXAgY2FuIGJlIHRyYW5zaXRpb25lZFxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGlzIHN0ZXAgc2hvdWxkIGJlIHRyYW5zaXRpb25lZFxuICAgICAqIEByZXR1cm5zIEEgW1tQcm9taXNlXV0gY29udGFpbmluZyBgdHJ1ZWAsIGlmIHRoaXMgc3RlcCBjYW4gdHJhbnNpdGlvbmVkIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICAgKiBAdGhyb3dzIEFuIGBFcnJvcmAgaXMgdGhyb3duIGlmIGBjb25kaXRpb25gIGlzIG5laXRoZXIgYSBmdW5jdGlvbiBub3IgYSBib29sZWFuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2FuVHJhbnNpdGlvblN0ZXA7XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgc3RlcCBpcyBlbnRlcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIHN0ZXAgaXMgZW50ZXJlZFxuICAgICAqL1xuICAgIGVudGVyKGRpcmVjdGlvbjogTW92aW5nRGlyZWN0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBzdGVwIGlzIGV4aXRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSBzdGVwIGlzIGV4aXRlZFxuICAgICAqL1xuICAgIGV4aXQoZGlyZWN0aW9uOiBNb3ZpbmdEaXJlY3Rpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSwgaWYgdGhpcyB3aXphcmQgc3RlcCBjYW4gYmUgZW50ZXJlZCBmcm9tIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgICogQmVjYXVzZSB0aGlzIG1ldGhvZCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBgY2FuRW50ZXJgLCBpdCB3aWxsIHRocm93IGFuIGVycm9yLCBpZiBgY2FuRW50ZXJgIGlzIG5laXRoZXIgYSBib29sZWFuXG4gICAgICogbm9yIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhpcyBzdGVwIHNob3VsZCBiZSBlbnRlcmVkXG4gICAgICogQHJldHVybnMgQSBbW1Byb21pc2VdXSBjb250YWluaW5nIGB0cnVlYCwgaWYgdGhlIHN0ZXAgY2FuIGJlIGVudGVyZWQgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHRocm93cyBBbiBgRXJyb3JgIGlzIHRocm93biBpZiBgYW5FbnRlcmAgaXMgbmVpdGhlciBhIGZ1bmN0aW9uIG5vciBhIGJvb2xlYW5cbiAgICAgKi9cbiAgICBjYW5FbnRlclN0ZXAoZGlyZWN0aW9uOiBNb3ZpbmdEaXJlY3Rpb24pOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdHJ1ZSwgaWYgdGhpcyB3aXphcmQgc3RlcCBjYW4gYmUgZXhpdGVkIGludG8gZ2l2ZW4gZGlyZWN0aW9uLlxuICAgICAqIEJlY2F1c2UgdGhpcyBtZXRob2QgZGVwZW5kcyBvbiB0aGUgdmFsdWUgYGNhbkV4aXRgLCBpdCB3aWxsIHRocm93IGFuIGVycm9yLCBpZiBgY2FuRXhpdGAgaXMgbmVpdGhlciBhIGJvb2xlYW5cbiAgICAgKiBub3IgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGlzIHN0ZXAgc2hvdWxkIGJlIGxlZnRcbiAgICAgKiBAcmV0dXJucyBBIFtbUHJvbWlzZV1dIGNvbnRhaW5pbmcgYHRydWVgLCBpZiB0aGUgc3RlcCBjYW4gYmUgZXhpdGVkIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEB0aHJvd3MgQW4gYEVycm9yYCBpcyB0aHJvd24gaWYgYGNhbkV4aXRgIGlzIG5laXRoZXIgYSBmdW5jdGlvbiBub3IgYSBib29sZWFuXG4gICAgICovXG4gICAgY2FuRXhpdFN0ZXAoZGlyZWN0aW9uOiBNb3ZpbmdEaXJlY3Rpb24pOiBQcm9taXNlPGJvb2xlYW4+O1xufVxuIl19